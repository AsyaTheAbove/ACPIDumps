
Intel ACPI Component Architecture
ACPI Binary Table Extraction Utility version 20141107-64 [Apr  6 2015]
Copyright (c) 2000 - 2014 Intel Corporation


Signature  Length      Revision   OemId    OemTableId   OemRevision CompilerId CompilerRevision

   RSDP                          "LENOVO"
   RSDT   0x00000060     0x01    "LENOVO"  "TP-7S   "   0x00001240    " LTP"     0x00000000
   XSDT   0x0000009C     0x01    "LENOVO"  "TP-7S   "   0x00001240    " LTP"     0x00000000
   DSDT   0x0000E973     0x01    "LENOVO"  "TP-7S   "   0x00001240    "MSFT"     0x03000000
   FACS   0x00000040
   FACP   0x000000F4     0x03    "LENOVO"  "TP-7S   "   0x00001240    "LNVO"     0x00000001
   SSDT   0x00000227     0x01    "LENOVO"  "TP-7S   "   0x00001240    "MSFT"     0x03000000
   ECDT   0x00000052     0x01    "LENOVO"  "TP-7S   "   0x00001240    "LNVO"     0x00000001
   TCPA   0x00000032     0x02    "LENOVO"  "TP-7S   "   0x00001240    "LNVO"     0x00000001
   APIC   0x00000068     0x01    "LENOVO"  "TP-7S   "   0x00001240    "LNVO"     0x00000001
   MCFG   0x0000003C     0x01    "LENOVO"  "TP-7S   "   0x00001240    "LNVO"     0x00000001
   HPET   0x00000038     0x01    "LENOVO"  "TP-7S   "   0x00001240    "LNVO"     0x00000001
   SLIC   0x00000176     0x01    "LENOVO"  "TP-7S   "   0x00001240    " LTP"     0x00000000
   BOOT   0x00000028     0x01    "LENOVO"  "TP-7S   "   0x00001240    " LTP"     0x00000001
   ASF!   0x00000072     0x10    "LENOVO"  "TP-7S   "   0x00001240    "PTL "     0x00000001
   SSDT   0x0000025F     0x01    "LENOVO"  "TP-7S   "   0x00001240    "INTL"     0x20050513
   SSDT   0x000000A6     0x01    "LENOVO"  "TP-7S   "   0x00001240    "INTL"     0x20050513
   SSDT   0x000004F7     0x01    "LENOVO"  "TP-7S   "   0x00001240    "INTL"     0x20050513
   SSDT   0x000008BD     0x01    "LENOVO"  "TP-7S   "   0x00001240    "INTL"     0x20050513
   SSDT   0x0000069C     0x01    "LENOVO"  "TP-7S   "   0x00001240    "INTL"     0x20050513
   SSDT   0x00000282     0x01    "PmRef "  "Cpu0Ist "   0x00000100    "INTL"     0x20050513
   SSDT   0x0000061E     0x01    "PmRef "  "Cpu0Cst "   0x00000100    "INTL"     0x20050513
   SSDT   0x000000C8     0x01    "PmRef "  "Cpu1Ist "   0x00000100    "INTL"     0x20050513
   SSDT   0x00000085     0x01    "PmRef "  "Cpu1Cst "   0x00000100    "INTL"     0x20050513

Found 24 ACPI tables

APIC
----
[000h 0000   4]                    Signature : "APIC"    [Multiple APIC Description Table (MADT)]
[004h 0004   4]                 Table Length : 00000068
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : 41
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : "LNVO"
[020h 0032   4]        Asl Compiler Revision : 00000001

[024h 0036   4]           Local Apic Address : FEE00000
[028h 0040   4]        Flags (decoded below) : 00000001
                         PC-AT Compatibility : 1

[02Ch 0044   1]                Subtable Type : 00 [Processor Local APIC]
[02Dh 0045   1]                       Length : 08
[02Eh 0046   1]                 Processor ID : 00
[02Fh 0047   1]                Local Apic ID : 00
[030h 0048   4]        Flags (decoded below) : 00000001
                           Processor Enabled : 1

[034h 0052   1]                Subtable Type : 00 [Processor Local APIC]
[035h 0053   1]                       Length : 08
[036h 0054   1]                 Processor ID : 01
[037h 0055   1]                Local Apic ID : 01
[038h 0056   4]        Flags (decoded below) : 00000001
                           Processor Enabled : 1

[03Ch 0060   1]                Subtable Type : 01 [I/O APIC]
[03Dh 0061   1]                       Length : 0C
[03Eh 0062   1]                  I/O Apic ID : 01
[03Fh 0063   1]                     Reserved : 00
[040h 0064   4]                      Address : FEC00000
[044h 0068   4]                    Interrupt : 00000000

[048h 0072   1]                Subtable Type : 02 [Interrupt Source Override]
[049h 0073   1]                       Length : 0A
[04Ah 0074   1]                          Bus : 00
[04Bh 0075   1]                       Source : 00
[04Ch 0076   4]                    Interrupt : 00000002
[050h 0080   2]        Flags (decoded below) : 0000
                                    Polarity : 0
                                Trigger Mode : 0

[052h 0082   1]                Subtable Type : 02 [Interrupt Source Override]
[053h 0083   1]                       Length : 0A
[054h 0084   1]                          Bus : 00
[055h 0085   1]                       Source : 09
[056h 0086   4]                    Interrupt : 00000009
[05Ah 0090   2]        Flags (decoded below) : 000D
                                    Polarity : 1
                                Trigger Mode : 3

[05Ch 0092   1]                Subtable Type : 04 [Local APIC NMI]
[05Dh 0093   1]                       Length : 06
[05Eh 0094   1]                 Processor ID : 00
[05Fh 0095   2]        Flags (decoded below) : 0005
                                    Polarity : 1
                                Trigger Mode : 1
[061h 0097   1]         Interrupt Input LINT : 01

[062h 0098   1]                Subtable Type : 04 [Local APIC NMI]
[063h 0099   1]                       Length : 06
[064h 0100   1]                 Processor ID : 01
[065h 0101   2]        Flags (decoded below) : 0005
                                    Polarity : 1
                                Trigger Mode : 1
[067h 0103   1]         Interrupt Input LINT : 01

Raw Table Data: Length 104 (0x68)

  0000: 41 50 49 43 68 00 00 00 01 41 4C 45 4E 4F 56 4F  APICh....ALENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 4C 4E 56 4F  TP-7S   @...LNVO
  0020: 01 00 00 00 00 00 E0 FE 01 00 00 00 00 08 00 00  ................
  0030: 01 00 00 00 00 08 01 01 01 00 00 00 01 0C 01 00  ................
  0040: 00 00 C0 FE 00 00 00 00 02 0A 00 00 02 00 00 00  ................
  0050: 00 00 02 0A 00 09 09 00 00 00 0D 00 04 06 00 05  ................
  0060: 00 01 04 06 01 05 00 01                          ........


ASF!
----
[000h 0000   4]                    Signature : "ASF!"    [Alert Standard Format table]
[004h 0004   4]                 Table Length : 00000072
[008h 0008   1]                     Revision : 10
[009h 0009   1]                     Checksum : 76
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : "PTL "
[020h 0032   4]        Asl Compiler Revision : 00000001

[024h 0036   1]                Subtable Type : 00 [ASF Information]
[025h 0037   1]                     Reserved : 00
[026h 0038   2]                       Length : 0010
[028h 0040   1]          Minimum Reset Value : 00
[029h 0041   1]     Minimum Polling Interval : 02
[02Ah 0042   2]                    System ID : 2003
[02Ch 0044   4]              Manufacturer ID : 00004A66
[030h 0048   1]                        Flags : 00
[031h 0049   3]                     Reserved : 000000

[034h 0052   1]                Subtable Type : 02 [ASF Remote Control]
[035h 0053   1]                     Reserved : 00
[036h 0054   2]                       Length : 0018
[038h 0056   1]                Control Count : 04
[039h 0057   1]          Control Data Length : 04
[03Ah 0058   2]                     Reserved : 0000

[03Ch 0060   1]                     Function : 02
[03Dh 0061   1]                      Address : 88
[03Eh 0062   1]                      Command : 00
[03Fh 0063   1]                        Value : 01

[040h 0064   1]                     Function : 01
[041h 0065   1]                      Address : 88
[042h 0066   1]                      Command : 00
[043h 0067   1]                        Value : 02

[044h 0068   1]                     Function : 00
[045h 0069   1]                      Address : 88
[046h 0070   1]                      Command : 00
[047h 0071   1]                        Value : 03

[048h 0072   1]                     Function : 03
[049h 0073   1]                      Address : 88
[04Ah 0074   1]                      Command : 00
[04Bh 0075   1]                        Value : 04

[04Ch 0076   1]                Subtable Type : 03 [ASF RMCP Boot Options]
[04Dh 0077   1]                     Reserved : 00
[04Eh 0078   2]                       Length : 0017
[050h 0080   7]                 Capabilities : 20 00 00 00 00 13 F0
[057h 0087   1]              Completion Code : 00
[058h 0088   4]                Enterprise ID : FF53F000
[05Ch 0092   1]                      Command : 00
[05Dh 0093   2]                    Parameter : E2C3
[05Fh 0095   2]                 Boot Options : 00E2
[061h 0097   2]               Oem Parameters : 53F0

[063h 0099   1]                Subtable Type : 84 [ASF Address]
[064h 0100   1]                     Reserved : 00
[065h 0101   2]                       Length : 000F
[067h 0103   1]                Eprom Address : 00
[068h 0104   1]                 Device Count : 09
[069h 0105   1]                    Addresses : 88 A0 A2 A8 AA AC AE B8 D2 


Raw Table Data: Length 114 (0x72)

  0000: 41 53 46 21 72 00 00 00 10 76 4C 45 4E 4F 56 4F  ASF!r....vLENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 50 54 4C 20  TP-7S   @...PTL 
  0020: 01 00 00 00 00 00 10 00 00 02 03 20 66 4A 00 00  ........... fJ..
  0030: 00 00 00 00 02 00 18 00 04 04 00 00 02 88 00 01  ................
  0040: 01 88 00 02 00 88 00 03 03 88 00 04 03 00 17 00  ................
  0050: 20 00 00 00 00 13 F0 00 00 F0 53 FF 00 C3 E2 E2   .........S.....
  0060: 00 F0 53 84 00 0F 00 00 09 88 A0 A2 A8 AA AC AE  ..S.............
  0070: B8 D2                                            ..


BOOT
----
[000h 0000   4]                    Signature : "BOOT"    [Simple Boot Flag Table]
[004h 0004   4]                 Table Length : 00000028
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : 7D
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : " LTP"
[020h 0032   4]        Asl Compiler Revision : 00000001

[024h 0036   1]          Boot Register Index : 35
[025h 0037   3]                     Reserved : 000000

Raw Table Data: Length 40 (0x28)

  0000: 42 4F 4F 54 28 00 00 00 01 7D 4C 45 4E 4F 56 4F  BOOT(....}LENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 20 4C 54 50  TP-7S   @... LTP
  0020: 01 00 00 00 35 00 00 00                          ....5...


DSDT
----
DefinitionBlock ("dsdt.aml", "DSDT", 1, "LENOVO", "TP-7S   ", 0x00001240)
{
    /*
     * iASL Warning: There were 1 external control methods found during
     * disassembly, but additional ACPI tables to resolve these externals
     * were not specified. This resulting disassembler output file may not
     * compile because the disassembler did not know how many arguments
     * to assign to these methods. To specify the tables needed to resolve
     * external control method references, the -e option can be used to
     * specify the filenames. Example iASL invocations:
     *     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml
     *     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml
     *     iasl -e ssdt*.aml -d dsdt.aml
     *
     * In addition, the -fe option can be used to specify a file containing
     * control method external declarations with the associated method
     * argument counts. Each line of the file must be of the form:
     *     External (<method pathname>, MethodObj, <argument count>)
     * Invocation:
     *     iasl -fe refs.txt -d dsdt.aml
     *
     * The following methods were unresolved and many not compile properly
     * because the disassembler had to guess at the number of arguments
     * required for each:
     */
    External (_SB_.PCI0.SATA.SCND._STM, MethodObj)    // Warning: Unresolved method, guessing 3 arguments

    External (_SB_.PCI0.SATA.SCND._ADR, IntObj)
    External (_SB_.PCI0.SATA.SCND.MSTR, UnknownObj)
    External (_SB_.PCI0.SATA.SCND.MSTR._ADR, IntObj)
    External (_SB_.PCI0.SATA.SCND.MSTR._GTF, IntObj)
    External (CFGD, UnknownObj)

    OperationRegion (PORT, SystemIO, 0x80, 0x01)
    Field (PORT, ByteAcc, NoLock, Preserve)
    {
        P80H,   8
    }

    Scope (\_PR)
    {
        Processor (CPU0, 0x00, 0x00001010, 0x06) {}
        Processor (CPU1, 0x01, 0x00001010, 0x06) {}
    }

    OperationRegion (MNVS, SystemMemory, 0x7E6E4000, 0x1000)
    Field (MNVS, DWordAcc, NoLock, Preserve)
    {
        Offset (0xF00), 
        GAPA,   32, 
        GAPL,   32, 
        DCKI,   32, 
        DCKS,   32, 
        VCDL,   1, 
        VCDC,   1, 
        VCDT,   1, 
        VCDD,   1, 
        VIGD,   1, 
        VCSS,   1, 
        VCDB,   1, 
        VCIN,   1, 
        VPDF,   1, 
        Offset (0xF12), 
        VLID,   4, 
        VVPO,   4, 
        BRLV,   4, 
        BRFQ,   2, 
        BRHB,   1, 
        BREV,   1, 
        CDFL,   8, 
        CDAH,   8, 
        PMOD,   2, 
        PDIR,   1, 
        PDMA,   1, 
        Offset (0xF17), 
        LFDC,   1, 
        Offset (0xF18), 
        C2NA,   1, 
        C3NA,   1, 
        C4NA,   1, 
        Offset (0xF19), 
        SPEN,   1, 
            ,   1, 
            ,   1, 
            ,   1, 
        MPEN,   1, 
        Offset (0xF1A), 
        OSPX,   1, 
        OSC4,   1, 
        OSSS,   1, 
        NHPS,   1, 
        NPME,   1, 
        Offset (0xF1B), 
        UOPT,   8, 
        BTID,   32, 
        LWST,   8, 
        LPST,   8, 
        TCRT,   16, 
        TPSV,   16, 
        TTC1,   16, 
        TTC2,   16, 
        TTSP,   16, 
        SRAH,   8, 
        SRHE,   8, 
        SRE0,   8, 
        SRE1,   8, 
        SRE2,   8, 
        SRE3,   8, 
        SRE4,   8, 
        SRE5,   8, 
        SRU0,   8, 
        SRU1,   8, 
        SRU2,   8, 
        SRU7,   8, 
        SRU3,   8, 
        SRU4,   8, 
        SRU8,   8, 
        SRPB,   8, 
        SRLP,   8, 
        SRSA,   8, 
        SRSM,   8, 
        CWAC,   1, 
        CWAS,   1, 
        CWUE,   1, 
        CWUS,   1, 
        Offset (0xF40), 
        CWAP,   16, 
        CWAT,   16, 
        DBGC,   1, 
        Offset (0xF45), 
        FS1L,   16, 
        FS1M,   16, 
        FS1H,   16, 
        FS2L,   16, 
        FS2M,   16, 
        FS2H,   16, 
        FS3L,   16, 
        FS3M,   16, 
        FS3H,   16, 
        TATC,   1, 
            ,   6, 
        TATL,   1, 
        TATW,   8, 
        TNFT,   4, 
        TNTT,   4, 
        TDFA,   4, 
        TDTA,   4, 
        TDFD,   4, 
        TDTD,   4, 
        TCFA,   4, 
        TCTA,   4, 
        TCFD,   4, 
        TCTD,   4, 
        TSFT,   4, 
        TSTT,   4, 
        TIT0,   8, 
        TCR0,   16, 
        TPS0,   16, 
        TIT1,   8, 
        TCR1,   16, 
        TPS1,   16, 
        TIT2,   8, 
        TCR2,   16, 
        TPS2,   16, 
        TIF0,   8, 
        TIF1,   8, 
        TIF2,   8, 
        Offset (0xF75), 
        TCZ1,   8, 
        TCZ2,   8, 
        TCZ3,   8, 
        BTHI,   1, 
        Offset (0xF79), 
        HDIR,   1, 
        HDEH,   1, 
        HDSP,   1, 
        HDPP,   1, 
        HDUB,   1, 
        Offset (0xF7A), 
        TPMP,   1, 
        TPMS,   1, 
        Offset (0xF7B), 
        BIDE,   8, 
            ,   1, 
        DTSE,   1, 
        Offset (0xF7D), 
        DTS0,   8, 
        DTS1,   8, 
        DT00,   1, 
        DT01,   1, 
        DT02,   1, 
        DT03,   1, 
        Offset (0xF80), 
        LIDB,   1, 
        C4WR,   1, 
        C4AC,   1, 
        Offset (0xF81), 
        PH01,   8, 
        PH02,   8, 
        PH03,   8, 
        PH04,   8, 
        PH05,   8, 
        PH06,   8, 
        PH07,   8, 
        PH08,   8, 
        PH09,   8, 
        PH0A,   8, 
        PH0B,   8, 
        DATD,   1, 
        Offset (0xF8D), 
        IPAT,   4, 
        IPSC,   1, 
        IDMM,   1, 
        IDMS,   2, 
        HVCO,   3, 
        IF1E,   1, 
        ISSC,   1, 
        LIDS,   1, 
        IBIA,   2, 
        IBTT,   8, 
        ITVF,   4, 
        ITVM,   4, 
        TCG0,   1, 
        TCG1,   1, 
        Offset (0xF92), 
        SWGP,   8, 
        IPMS,   8, 
        IPMB,   120, 
        IPMR,   24, 
        IPMO,   24, 
        IPMA,   8, 
        ASLB,   32, 
        ASFT,   8, 
        Offset (0xFB1), 
        CHKC,   32, 
        CHKE,   32
    }

    Field (MNVS, ByteAcc, NoLock, Preserve)
    {
        Offset (0xE00), 
        DDC1,   1024, 
        Offset (0xF00)
    }

    Field (MNVS, ByteAcc, NoLock, Preserve)
    {
        Offset (0xE00), 
        DDC2,   2048
    }

    Scope (\_SB)
    {
        Method (_INI, 0, NotSerialized)  // _INI: Initialize
        {
            If ((\SCMP (\_OS, "Microsoft Windows") == Zero))
            {
                \W98F = 0x01
            }
            Else
            {
                If (CondRefOf (\_OSI, Local0))
                {
                    If (\_OSI ("Windows 2001"))
                    {
                        \WNTF = 0x01
                        \WXPF = 0x01
                        \WSPV = 0x00
                    }

                    If (\_OSI ("Windows 2001 SP1"))
                    {
                        \WSPV = 0x01
                    }

                    If (\_OSI ("Windows 2001 SP2"))
                    {
                        \WSPV = 0x02
                    }

                    If (\_OSI ("Windows 2006"))
                    {
                        \WVIS = 0x01
                    }

                    If (\_OSI ("Linux"))
                    {
                        \LNUX = 0x01
                    }

                    If (\_OSI ("FreeBSD"))
                    {
                        \LNUX = 0x01
                    }
                }
                Else
                {
                    If ((\SCMP (\_OS, "Microsoft Windows NT") == Zero))
                    {
                        \WNTF = 0x01
                    }
                    Else
                    {
                        If ((\SCMP (\_OS, "Microsoft WindowsME: Millennium Edition") == Zero))
                        {
                            \WMEF = 0x01
                            \W98F = 0x01
                        }
                    }
                }
            }

            If ((\_REV >= 0x02))
            {
                \H8DR = 0x01
            }

            \OSIF = 0x01
            If ((\RBEC (0x46) & 0x10))
            {
                \C4AC = 0x00
            }
            Else
            {
                \C4AC = 0x01
            }

            If (\LNUX)
            {
                \_SB.PCI0.LPC.EC.SAUM (0x02)
                \UCMS (0x1C)
            }

            \_SB.PCI0.RID = \SRAH
            If (VIGD)
            {
                \_SB.PCI0.VID.RID = \SRHE
            }
            Else
            {
                \_SB.PCI0.AGP.RID = \SRHE
            }

            \_SB.PCI0.EXP0.RID = \SRE0
            \_SB.PCI0.EXP1.RID = \SRE1
            \_SB.PCI0.EXP2.RID = \SRE2
            \_SB.PCI0.EXP3.RID = \SRE3
            \_SB.PCI0.USB0.RID = \SRU0
            \_SB.PCI0.USB1.RID = \SRU1
            \_SB.PCI0.USB3.RID = \SRU3
            \_SB.PCI0.EHC0.RID = \SRU7
            \_SB.PCI0.USB3.RID = \SRU3
            \_SB.PCI0.USB4.RID = \SRU4
            \_SB.PCI0.EHC1.RID = \SRU8
            \_SB.PCI0.PCI1.RID = \SRPB
            \_SB.PCI0.LPC.RID = \SRLP
            \_SB.PCI0.IDE0.RID = \SRSA
            \_SB.PCI0.SATA.RID = \SRSA
            \_SB.PCI0.SMBU.RID = \SRSM
        }

        Device (LNKA)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x01)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRA))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRA |= 0x80
            }

            Name (BUFA, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y00)
                    {}
            })
            CreateWordField (BUFA, \_SB.LNKA._Y00._INT, IRA1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRA & 0x8F)
                If (VPIR (Local0))
                {
                    IRA1 = (0x01 << Local0)
                }
                Else
                {
                    IRA1 = 0x00
                }

                Return (BUFA) /* \_SB_.LNKA.BUFA */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRA2)
                FindSetRightBit (IRA2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRA & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRA = Local1
            }
        }

        Device (LNKB)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x02)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRB))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRB |= 0x80
            }

            Name (BUFB, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y01)
                    {}
            })
            CreateWordField (BUFB, \_SB.LNKB._Y01._INT, IRB1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRB & 0x8F)
                If (VPIR (Local0))
                {
                    IRB1 = (0x01 << Local0)
                }
                Else
                {
                    IRB1 = 0x00
                }

                Return (BUFB) /* \_SB_.LNKB.BUFB */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRB2)
                FindSetRightBit (IRB2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRB & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRB = Local1
            }
        }

        Device (LNKC)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x03)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRC))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRC |= 0x80
            }

            Name (BUFC, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y02)
                    {}
            })
            CreateWordField (BUFC, \_SB.LNKC._Y02._INT, IRC1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRC & 0x8F)
                If (VPIR (Local0))
                {
                    IRC1 = (0x01 << Local0)
                }
                Else
                {
                    IRC1 = 0x00
                }

                Return (BUFC) /* \_SB_.LNKC.BUFC */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRC2)
                FindSetRightBit (IRC2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRC & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRC = Local1
            }
        }

        Device (LNKD)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x04)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRD))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRD |= 0x80
            }

            Name (BUFD, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y03)
                    {}
            })
            CreateWordField (BUFD, \_SB.LNKD._Y03._INT, IRD1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRD & 0x8F)
                If (VPIR (Local0))
                {
                    IRD1 = (0x01 << Local0)
                }
                Else
                {
                    IRD1 = 0x00
                }

                Return (BUFD) /* \_SB_.LNKD.BUFD */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRD2)
                FindSetRightBit (IRD2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRD & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRD = Local1
            }
        }

        Device (LNKE)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x05)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRE))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRE |= 0x80
            }

            Name (BUFE, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y04)
                    {}
            })
            CreateWordField (BUFE, \_SB.LNKE._Y04._INT, IRE1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRE & 0x8F)
                If (VPIR (Local0))
                {
                    IRE1 = (0x01 << Local0)
                }
                Else
                {
                    IRE1 = 0x00
                }

                Return (BUFE) /* \_SB_.LNKE.BUFE */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRE2)
                FindSetRightBit (IRE2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRE & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRE = Local1
            }
        }

        Device (LNKF)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x06)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRF))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRF |= 0x80
            }

            Name (BUFF, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y05)
                    {}
            })
            CreateWordField (BUFF, \_SB.LNKF._Y05._INT, IRF1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRF & 0x8F)
                If (VPIR (Local0))
                {
                    IRF1 = (0x01 << Local0)
                }
                Else
                {
                    IRF1 = 0x00
                }

                Return (BUFF) /* \_SB_.LNKF.BUFF */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRF2)
                FindSetRightBit (IRF2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRF & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRF = Local1
            }
        }

        Device (LNKG)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x07)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRG))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRG |= 0x80
            }

            Name (BUFG, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y06)
                    {}
            })
            CreateWordField (BUFG, \_SB.LNKG._Y06._INT, IRG1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRG & 0x8F)
                If (VPIR (Local0))
                {
                    IRG1 = (0x01 << Local0)
                }
                Else
                {
                    IRG1 = 0x00
                }

                Return (BUFG) /* \_SB_.LNKG.BUFG */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRG2)
                FindSetRightBit (IRG2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRG & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRG = Local1
            }
        }

        Device (LNKH)
        {
            Name (_HID, EisaId ("PNP0C0F") /* PCI Interrupt Link Device */)  // _HID: Hardware ID
            Name (_UID, 0x08)  // _UID: Unique ID
            Method (_STA, 0, NotSerialized)  // _STA: Status
            {
                If (!VPIR (\_SB.PCI0.LPC.PIRH))
                {
                    Return (0x09)
                }
                Else
                {
                    Return (0x0B)
                }
            }

            Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
            {
                IRQ (Level, ActiveLow, Shared, )
                    {3,4,5,6,7,9,10,11}
            })
            Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
            {
                \_SB.PCI0.LPC.PIRH |= 0x80
            }

            Name (BUFH, ResourceTemplate ()
            {
                IRQ (Level, ActiveLow, Shared, _Y07)
                    {}
            })
            CreateWordField (BUFH, \_SB.LNKH._Y07._INT, IRH1)  // _INT: Interrupts
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                Local0 = (\_SB.PCI0.LPC.PIRH & 0x8F)
                If (VPIR (Local0))
                {
                    IRH1 = (0x01 << Local0)
                }
                Else
                {
                    IRH1 = 0x00
                }

                Return (BUFH) /* \_SB_.LNKH.BUFH */
            }

            Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
            {
                CreateWordField (Arg0, 0x01, IRH2)
                FindSetRightBit (IRH2, Local0)
                Local1 = (\_SB.PCI0.LPC.PIRH & 0x70)
                Local1 |= Local0--
                \_SB.PCI0.LPC.PIRH = Local1
            }
        }

        Method (VPIR, 1, NotSerialized)
        {
            Local0 = 0x01
            If ((Arg0 & 0x80))
            {
                Local0 = 0x00
            }
            Else
            {
                Local1 = (Arg0 & 0x0F)
                If ((Local1 < 0x03))
                {
                    Local0 = 0x00
                }
                Else
                {
                    If (((Local1 == 0x08) || (Local1 == 0x0D)))
                    {
                        Local0 = 0x00
                    }
                }
            }

            Return (Local0)
        }

        Device (MEM)
        {
            Name (_HID, EisaId ("PNP0C01") /* System Board */)  // _HID: Hardware ID
            Name (ME98, ResourceTemplate ()
            {
                Memory32Fixed (ReadWrite,
                    0x00000000,         // Address Base
                    0x000A0000,         // Address Length
                    )
                Memory32Fixed (ReadOnly,
                    0x000E0000,         // Address Base
                    0x00020000,         // Address Length
                    )
                Memory32Fixed (ReadWrite,
                    0x00100000,         // Address Base
                    0x01EE0000,         // Address Length
                    _Y08)
                Memory32Fixed (ReadOnly,
                    0xFEC00000,         // Address Base
                    0x00140000,         // Address Length
                    )
                Memory32Fixed (ReadOnly,
                    0xFED4C000,         // Address Base
                    0x012B4000,         // Address Length
                    )
            })
            CreateDWordField (ME98, \_SB.MEM._Y08._BAS, MEB0)  // _BAS: Base Address
            CreateDWordField (ME98, \_SB.MEM._Y08._LEN, MEL0)  // _LEN: Length
            Name (MGAP, ResourceTemplate ()
            {
                Memory32Fixed (ReadOnly,
                    0x00000000,         // Address Base
                    0x00000000,         // Address Length
                    _Y09)
            })
            CreateDWordField (MGAP, \_SB.MEM._Y09._BAS, MGPB)  // _BAS: Base Address
            CreateDWordField (MGAP, \_SB.MEM._Y09._LEN, MGPL)  // _LEN: Length
            Name (MEMS, ResourceTemplate ()
            {
                Memory32Fixed (ReadWrite,
                    0x00000000,         // Address Base
                    0x000A0000,         // Address Length
                    )
                Memory32Fixed (ReadOnly,
                    0x000C0000,         // Address Base
                    0x00000000,         // Address Length
                    _Y0A)
                Memory32Fixed (ReadOnly,
                    0x000C4000,         // Address Base
                    0x00000000,         // Address Length
                    _Y0B)
                Memory32Fixed (ReadOnly,
                    0x000C8000,         // Address Base
                    0x00000000,         // Address Length
                    _Y0C)
                Memory32Fixed (ReadOnly,
                    0x000CC000,         // Address Base
                    0x00000000,         // Address Length
                    _Y0D)
                Memory32Fixed (ReadOnly,
                    0x000D0000,         // Address Base
                    0x00000000,         // Address Length
                    _Y0E)
                Memory32Fixed (ReadOnly,
                    0x000D4000,         // Address Base
                    0x00000000,         // Address Length
                    _Y0F)
                Memory32Fixed (ReadOnly,
                    0x000D8000,         // Address Base
                    0x00000000,         // Address Length
                    _Y10)
                Memory32Fixed (ReadOnly,
                    0x000DC000,         // Address Base
                    0x00000000,         // Address Length
                    _Y11)
                Memory32Fixed (ReadOnly,
                    0x000E0000,         // Address Base
                    0x00000000,         // Address Length
                    _Y12)
                Memory32Fixed (ReadOnly,
                    0x000E4000,         // Address Base
                    0x00000000,         // Address Length
                    _Y13)
                Memory32Fixed (ReadOnly,
                    0x000E8000,         // Address Base
                    0x00000000,         // Address Length
                    _Y14)
                Memory32Fixed (ReadOnly,
                    0x000EC000,         // Address Base
                    0x00000000,         // Address Length
                    _Y15)
                Memory32Fixed (ReadOnly,
                    0x000F0000,         // Address Base
                    0x00010000,         // Address Length
                    )
                Memory32Fixed (ReadWrite,
                    0x00100000,         // Address Base
                    0x01EE0000,         // Address Length
                    _Y16)
                Memory32Fixed (ReadOnly,
                    0xFEC00000,         // Address Base
                    0x00140000,         // Address Length
                    _Y17)
                Memory32Fixed (ReadOnly,
                    0xFED4C000,         // Address Base
                    0x012B4000,         // Address Length
                    _Y18)
            })
            CreateDWordField (MEMS, \_SB.MEM._Y0A._LEN, MC0L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y0B._LEN, MC4L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y0C._LEN, MC8L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y0D._LEN, MCCL)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y0E._LEN, MD0L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y0F._LEN, MD4L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y10._LEN, MD8L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y11._LEN, MDCL)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y12._LEN, ME0L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y13._LEN, ME4L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y14._LEN, ME8L)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y15._LEN, MECL)  // _LEN: Length
            CreateBitField (MEMS, \_SB.MEM._Y0A._RW, MC0W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y0B._RW, MC4W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y0C._RW, MC8W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y0D._RW, MCCW)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y0E._RW, MD0W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y0F._RW, MD4W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y10._RW, MD8W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y11._RW, MDCW)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y12._RW, ME0W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y13._RW, ME4W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y14._RW, ME8W)  // _RW_: Read-Write Status
            CreateBitField (MEMS, \_SB.MEM._Y15._RW, MECW)  // _RW_: Read-Write Status
            CreateDWordField (MEMS, \_SB.MEM._Y16._BAS, MEB1)  // _BAS: Base Address
            CreateDWordField (MEMS, \_SB.MEM._Y16._LEN, MEL1)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y17._LEN, MEL2)  // _LEN: Length
            CreateDWordField (MEMS, \_SB.MEM._Y18._LEN, MEL3)  // _LEN: Length
            Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
            {
                If (\W98F)
                {
                    MEL0 = (\MEMX - MEB0) /* \_SB_.MEM_.MEB0 */
                    MGPB = \GAPA
                    MGPL = \GAPL
                    If ((MGPB && MGPL))
                    {
                        Local0 = (SizeOf (ME98) - 0x02)
                        Name (MBF0, Buffer (Local0) {})
                        Local0 += SizeOf (MGAP)
                        Name (MBF1, Buffer (Local0) {})
                        MBF0 = ME98 /* \_SB_.MEM_.ME98 */
                        Concatenate (MBF0, MGAP, MBF1) /* \_SB_.MEM_._CRS.MBF1 */
                        If ((\_SB.PCI0.LPC.TPM._STA () != 0x0F))
                        {
                            Local0 = (SizeOf (MBF1) - 0x02)
                            Name (MBF2, Buffer (Local0) {})
                            Local0 += SizeOf (\_SB.PCI0.LPC.TPM._CRS)
                            Name (MBF3, Buffer (Local0) {})
                            MBF2 = MBF1 /* \_SB_.MEM_._CRS.MBF1 */
                            Concatenate (MBF2, \_SB.PCI0.LPC.TPM._CRS, MBF3) /* \_SB_.MEM_._CRS.MBF3 */
                            Return (MBF3) /* \_SB_.MEM_._CRS.MBF3 */
                        }
                        Else
                        {
                            Return (MBF1) /* \_SB_.MEM_._CRS.MBF1 */
                        }
                    }
                    Else
                    {
                        If ((\_SB.PCI0.LPC.TPM._STA () != 0x0F))
                        {
                            Local0 = (SizeOf (ME98) - 0x02)
                            Name (MBF4, Buffer (Local0) {})
                            Local0 += SizeOf (\_SB.PCI0.LPC.TPM._CRS)
                            Name (MBF5, Buffer (Local0) {})
                            MBF4 = ME98 /* \_SB_.MEM_.ME98 */
                            Concatenate (MBF4, \_SB.PCI0.LPC.TPM._CRS, MBF5) /* \_SB_.MEM_._CRS.MBF5 */
                            Return (MBF5) /* \_SB_.MEM_._CRS.MBF5 */
                        }
                        Else
                        {
                            Return (ME98) /* \_SB_.MEM_.ME98 */
                        }
                    }
                }

                Local0 = (\_SB.PCI0.PAM1 & 0x03)
                If (Local0)
                {
                    MC0L = 0x4000
                    If ((Local0 & 0x02))
                    {
                        MC0W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM1 & 0x30)
                If (Local0)
                {
                    MC4L = 0x4000
                    If ((Local0 & 0x20))
                    {
                        MC4W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM2 & 0x03)
                If (Local0)
                {
                    MC8L = 0x4000
                    If ((Local0 & 0x02))
                    {
                        MC8W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM2 & 0x30)
                If (Local0)
                {
                    MCCL = 0x4000
                    If ((Local0 & 0x20))
                    {
                        MCCW = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM3 & 0x03)
                If (Local0)
                {
                    MD0L = 0x4000
                    If ((Local0 & 0x02))
                    {
                        MD0W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM3 & 0x30)
                If (Local0)
                {
                    MD4L = 0x4000
                    If ((Local0 & 0x20))
                    {
                        MD4W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM4 & 0x03)
                If (Local0)
                {
                    MD8L = 0x4000
                    If ((Local0 & 0x02))
                    {
                        MD8W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM4 & 0x30)
                If (Local0)
                {
                    MDCL = 0x4000
                    If ((Local0 & 0x20))
                    {
                        MDCW = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM5 & 0x03)
                If (Local0)
                {
                    ME0L = 0x4000
                    If ((Local0 & 0x02))
                    {
                        ME0W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM5 & 0x30)
                If (Local0)
                {
                    ME4L = 0x4000
                    If ((Local0 & 0x20))
                    {
                        ME4W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM6 & 0x03)
                If (Local0)
                {
                    ME8L = 0x4000
                    If ((Local0 & 0x02))
                    {
                        ME8W = 0x01
                    }
                }

                Local0 = (\_SB.PCI0.PAM6 & 0x30)
                If (Local0)
                {
                    MECL = 0x4000
                    If ((Local0 & 0x20))
                    {
                        MECW = 0x01
                    }
                }

                MEL1 = (\MEMX - MEB1) /* \_SB_.MEM_.MEB1 */
                If ((\_SB.PCI0.LPC.TPM._STA () != 0x0F))
                {
                    MEL2 = 0x01400000
                    MEL3 = 0x00
                }

                Return (MEMS) /* \_SB_.MEM_.MEMS */
            }
        }

        Device (LID)
        {
            Name (_HID, EisaId ("PNP0C0D") /* Lid Device */)  // _HID: Hardware ID
            Method (_LID, 0, NotSerialized)  // _LID: Lid Status
            {
                If (\H8DR)
                {
                    Return (\_SB.PCI0.LPC.EC.HPLD)
                }
                Else
                {
                    If ((\RBEC (0x46) & 0x04))
                    {
                        Return (0x01)
                    }
                    Else
                    {
                        Return (0x00)
                    }
                }
            }

            Method (_PRW, 0, NotSerialized)  // _PRW: Power Resources for Wake
            {
                If ((\W98F && !\WMEF))
                {
                    Return (Package (0x02)
                    {
                        0x18, 
                        0x04
                    })
                }
                Else
                {
                    Return (Package (0x02)
                    {
                        0x18, 
                        0x03
                    })
                }
            }

            Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
            {
                If (\H8DR)
                {
                    If (Arg0)
                    {
                        \_SB.PCI0.LPC.EC.HWLO = 0x01
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.EC.HWLO = 0x00
                    }
                }
                Else
                {
                    If (Arg0)
                    {
                        \MBEC (0x32, 0xFF, 0x04)
                    }
                    Else
                    {
                        \MBEC (0x32, 0xFB, 0x00)
                    }
                }
            }
        }

        Device (SLPB)
        {
            Name (_HID, EisaId ("PNP0C0E") /* Sleep Button Device */)  // _HID: Hardware ID
            Method (_PRW, 0, NotSerialized)  // _PRW: Power Resources for Wake
            {
                If ((\W98F && !\WMEF))
                {
                    Return (Package (0x02)
                    {
                        0x18, 
                        0x04
                    })
                }
                Else
                {
                    Return (Package (0x02)
                    {
                        0x18, 
                        0x03
                    })
                }
            }

            Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
            {
                If (\H8DR)
                {
                    If (Arg0)
                    {
                        \_SB.PCI0.LPC.EC.HWFN = 0x01
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.EC.HWFN = 0x00
                    }
                }
                Else
                {
                    If (Arg0)
                    {
                        \MBEC (0x32, 0xFF, 0x10)
                    }
                    Else
                    {
                        \MBEC (0x32, 0xEF, 0x00)
                    }
                }
            }
        }

        Device (PCI0)
        {
            Device (LPC)
            {
                Name (_ADR, 0x001F0000)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                Device (SIO)
                {
                    Name (_HID, EisaId ("PNP0C02") /* PNP Motherboard Resources */)  // _HID: Hardware ID
                    Name (_UID, 0x00)  // _UID: Unique ID
                    Name (SCRS, ResourceTemplate ()
                    {
                        IO (Decode16,
                            0x0010,             // Range Minimum
                            0x0010,             // Range Maximum
                            0x01,               // Alignment
                            0x10,               // Length
                            )
                        IO (Decode16,
                            0x0090,             // Range Minimum
                            0x0090,             // Range Maximum
                            0x01,               // Alignment
                            0x10,               // Length
                            )
                        IO (Decode16,
                            0x0024,             // Range Minimum
                            0x0024,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x0028,             // Range Minimum
                            0x0028,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x002C,             // Range Minimum
                            0x002C,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x0030,             // Range Minimum
                            0x0030,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x0034,             // Range Minimum
                            0x0034,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x0038,             // Range Minimum
                            0x0038,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x003C,             // Range Minimum
                            0x003C,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x00A4,             // Range Minimum
                            0x00A4,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x00A8,             // Range Minimum
                            0x00A8,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x00AC,             // Range Minimum
                            0x00AC,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x00B0,             // Range Minimum
                            0x00B0,             // Range Maximum
                            0x01,               // Alignment
                            0x06,               // Length
                            )
                        IO (Decode16,
                            0x00B8,             // Range Minimum
                            0x00B8,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x00BC,             // Range Minimum
                            0x00BC,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x0050,             // Range Minimum
                            0x0050,             // Range Maximum
                            0x01,               // Alignment
                            0x04,               // Length
                            )
                        IO (Decode16,
                            0x0072,             // Range Minimum
                            0x0072,             // Range Maximum
                            0x01,               // Alignment
                            0x06,               // Length
                            )
                        IO (Decode16,
                            0x164E,             // Range Minimum
                            0x164E,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x002E,             // Range Minimum
                            0x002E,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x1000,             // Range Minimum
                            0x1000,             // Range Maximum
                            0x01,               // Alignment
                            0x80,               // Length
                            )
                        IO (Decode16,
                            0x1180,             // Range Minimum
                            0x1180,             // Range Maximum
                            0x01,               // Alignment
                            0x40,               // Length
                            )
                        IO (Decode16,
                            0x0800,             // Range Minimum
                            0x0800,             // Range Maximum
                            0x01,               // Alignment
                            0x10,               // Length
                            )
                        IO (Decode16,
                            0x15E0,             // Range Minimum
                            0x15E0,             // Range Maximum
                            0x01,               // Alignment
                            0x10,               // Length
                            )
                        IO (Decode16,
                            0x1600,             // Range Minimum
                            0x1600,             // Range Maximum
                            0x01,               // Alignment
                            0x60,               // Length
                            )
                        Memory32Fixed (ReadWrite,
                            0xF0000000,         // Address Base
                            0x04000000,         // Address Length
                            )
                        Memory32Fixed (ReadWrite,
                            0xFED1C000,         // Address Base
                            0x00004000,         // Address Length
                            )
                        Memory32Fixed (ReadWrite,
                            0xFED14000,         // Address Base
                            0x00004000,         // Address Length
                            )
                        Memory32Fixed (ReadWrite,
                            0xFED18000,         // Address Base
                            0x00001000,         // Address Length
                            )
                        Memory32Fixed (ReadWrite,
                            0xFED19000,         // Address Base
                            0x00001000,         // Address Length
                            )
                        Memory32Fixed (ReadWrite,
                            0xFED45000,         // Address Base
                            0x00007000,         // Address Length
                            )
                    })
                    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
                    {
                        If ((\_SB.PCI0.LPC.TPM._STA () == 0x0F))
                        {
                            Return (SCRS) /* \_SB_.PCI0.LPC_.SIO_.SCRS */
                        }
                        Else
                        {
                            Local0 = (SizeOf (SCRS) - 0x02)
                            Name (BUF0, Buffer (Local0) {})
                            Local0 += SizeOf (\_SB.PCI0.LPC.TPM._CRS)
                            Name (BUF1, Buffer (Local0) {})
                            BUF0 = SCRS /* \_SB_.PCI0.LPC_.SIO_.SCRS */
                            Concatenate (BUF0, \_SB.PCI0.LPC.TPM._CRS, BUF1) /* \_SB_.PCI0.LPC_.SIO_._CRS.BUF1 */
                            Return (BUF1) /* \_SB_.PCI0.LPC_.SIO_._CRS.BUF1 */
                        }
                    }
                }

                OperationRegion (LPCS, PCI_Config, 0x00, 0x0100)
                Field (LPCS, AnyAcc, NoLock, Preserve)
                {
                    Offset (0x60), 
                    PIRA,   8, 
                    PIRB,   8, 
                    PIRC,   8, 
                    PIRD,   8, 
                    SERQ,   8, 
                    Offset (0x68), 
                    PIRE,   8, 
                    PIRF,   8, 
                    PIRG,   8, 
                    PIRH,   8, 
                    Offset (0x80), 
                    XU1A,   3, 
                        ,   1, 
                    XU2A,   3, 
                    Offset (0x81), 
                    XPA,    2, 
                        ,   2, 
                    XFA,    1, 
                    Offset (0x82), 
                    XU1E,   1, 
                    XU2E,   1, 
                    XPE,    1, 
                    XFE,    1, 
                    Offset (0x83), 
                    XGML,   1, 
                    XGMH,   1, 
                    Offset (0x84), 
                    XG1E,   1, 
                        ,   6, 
                    XG1A,   9, 
                    Offset (0x88), 
                    XG2E,   1, 
                        ,   3, 
                    XG2A,   12, 
                    Offset (0xA0), 
                        ,   2, 
                    CLKR,   1, 
                    GYEN,   1, 
                        ,   3, 
                    C4C3,   1, 
                        ,   2, 
                    EXPE,   1, 
                    Offset (0xA2)
                }

                OperationRegion (LPIO, SystemIO, 0x1180, 0x40)
                Field (LPIO, DWordAcc, NoLock, Preserve)
                {
                    GU00,   8, 
                    GU01,   8, 
                    GU02,   8, 
                    GU03,   8, 
                    GI00,   8, 
                    GI01,   8, 
                    GI02,   8, 
                    GI03,   8, 
                    Offset (0x0C), 
                    GL00,   8, 
                    GL01,   8, 
                    GL02,   8, 
                    GL03,   8, 
                    Offset (0x18), 
                    GB00,   8, 
                    GB01,   8, 
                    GB02,   8, 
                    GB03,   8, 
                    Offset (0x2C), 
                    GV00,   8, 
                    GV01,   8, 
                    GV02,   8, 
                    GV03,   8, 
                    GU04,   8, 
                    GU05,   8, 
                    GU06,   8, 
                    GU07,   8, 
                    GI04,   8, 
                    GI05,   8, 
                    GI06,   8, 
                    GI07,   8, 
                    GL04,   8, 
                    GL05,   8, 
                    GL06,   8, 
                    GL07,   8
                }

                OperationRegion (PMIO, SystemIO, 0x1000, 0x80)
                Field (PMIO, AnyAcc, NoLock, Preserve)
                {
                    Offset (0x42), 
                        ,   1, 
                    SWGE,   1, 
                    Offset (0x64), 
                        ,   9, 
                    SCIS,   1, 
                    Offset (0x66)
                }

                Device (PIC)
                {
                    Name (_HID, EisaId ("PNP0000") /* 8259-compatible Programmable Interrupt Controller */)  // _HID: Hardware ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x0020,             // Range Minimum
                            0x0020,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x00A0,             // Range Minimum
                            0x00A0,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IO (Decode16,
                            0x04D0,             // Range Minimum
                            0x04D0,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IRQNoFlags ()
                            {2}
                    })
                }

                Device (TIMR)
                {
                    Name (_HID, EisaId ("PNP0100") /* PC-class System Timer */)  // _HID: Hardware ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x0040,             // Range Minimum
                            0x0040,             // Range Maximum
                            0x01,               // Alignment
                            0x04,               // Length
                            )
                        IRQNoFlags ()
                            {0}
                    })
                }

                Device (HPET)
                {
                    Name (_HID, EisaId ("PNP0103") /* HPET System Timer */)  // _HID: Hardware ID
                    Method (_STA, 0, NotSerialized)  // _STA: Status
                    {
                        If (W98F)
                        {
                            Return (0x00)
                        }
                        Else
                        {
                            If ((\WNTF && !\WXPF))
                            {
                                Return (0x00)
                            }
                            Else
                            {
                                Return (0x0F)
                            }
                        }

                        Return (0x00)
                    }

                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        Memory32Fixed (ReadOnly,
                            0xFED00000,         // Address Base
                            0x00000400,         // Address Length
                            )
                    })
                }

                Device (DMAC)
                {
                    Name (_HID, EisaId ("PNP0200") /* PC-class DMA Controller */)  // _HID: Hardware ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x0000,             // Range Minimum
                            0x0000,             // Range Maximum
                            0x01,               // Alignment
                            0x10,               // Length
                            )
                        IO (Decode16,
                            0x0080,             // Range Minimum
                            0x0080,             // Range Maximum
                            0x01,               // Alignment
                            0x10,               // Length
                            )
                        IO (Decode16,
                            0x00C0,             // Range Minimum
                            0x00C0,             // Range Maximum
                            0x01,               // Alignment
                            0x20,               // Length
                            )
                        DMA (Compatibility, BusMaster, Transfer8_16, )
                            {4}
                    })
                }

                Device (SPKR)
                {
                    Name (_HID, EisaId ("PNP0800") /* Microsoft Sound System Compatible Device */)  // _HID: Hardware ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x0061,             // Range Minimum
                            0x0061,             // Range Maximum
                            0x01,               // Alignment
                            0x01,               // Length
                            )
                    })
                }

                Device (FPU)
                {
                    Name (_HID, EisaId ("PNP0C04") /* x87-compatible Floating Point Processing Unit */)  // _HID: Hardware ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x00F0,             // Range Minimum
                            0x00F0,             // Range Maximum
                            0x01,               // Alignment
                            0x01,               // Length
                            )
                        IRQNoFlags ()
                            {13}
                    })
                }

                Device (RTC)
                {
                    Name (_HID, EisaId ("PNP0B00") /* AT Real-Time Clock */)  // _HID: Hardware ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x0070,             // Range Minimum
                            0x0070,             // Range Maximum
                            0x01,               // Alignment
                            0x02,               // Length
                            )
                        IRQNoFlags ()
                            {8}
                    })
                }

                Device (KBD)
                {
                    Name (_HID, EisaId ("LEN0003"))  // _HID: Hardware ID
                    Name (_CID, EisaId ("PNP0303") /* IBM Enhanced Keyboard (101/102-key, PS/2 Mouse) */)  // _CID: Compatible ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x0060,             // Range Minimum
                            0x0060,             // Range Maximum
                            0x01,               // Alignment
                            0x01,               // Length
                            )
                        IO (Decode16,
                            0x0064,             // Range Minimum
                            0x0064,             // Range Maximum
                            0x01,               // Alignment
                            0x01,               // Length
                            )
                        IRQNoFlags ()
                            {1}
                    })
                }

                Device (MOU)
                {
                    Name (_HID, EisaId ("IBM3780"))  // _HID: Hardware ID
                    Name (_CID, EisaId ("PNP0F13") /* PS/2 Mouse */)  // _CID: Compatible ID
                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IRQNoFlags ()
                            {12}
                    })
                }

                OperationRegion (IMGA, SystemIO, 0x15E0, 0x10)
                Field (IMGA, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x01), 
                    Offset (0x02), 
                    Offset (0x03), 
                    WAKR,   16, 
                    Offset (0x0C), 
                    GAIX,   8, 
                    Offset (0x0E), 
                    GADT,   8, 
                    Offset (0x10)
                }

                IndexField (GAIX, GADT, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x41), 
                    VAUX,   2, 
                        ,   1, 
                    WOLE,   1, 
                    Offset (0x42), 
                    Offset (0x50), 
                        ,   1, 
                    CBPW,   1, 
                    CBSL,   1, 
                    VDPW,   1, 
                    PDNE,   1, 
                    BLPL,   1, 
                        ,   1, 
                    LEDS,   1, 
                    TP4R,   1, 
                    PADR,   1, 
                    BPAD,   1, 
                        ,   1, 
                        ,   1, 
                    PADD,   1, 
                    Offset (0x53), 
                    DLAN,   1, 
                    Offset (0x60), 
                    BUSC,   1, 
                    BUSD,   1, 
                        ,   1, 
                    DSCI,   1, 
                    Offset (0x61), 
                    EPWG,   1, 
                        ,   2, 
                    DSCS,   1, 
                    Offset (0x62), 
                    CSON,   1, 
                    URST,   1, 
                    Offset (0x70), 
                    GDR0,   1, 
                    GDR1,   1, 
                    GDR2,   1, 
                    Offset (0x71), 
                    GDT0,   1, 
                    GDT1,   1, 
                    GDT2,   1, 
                    Offset (0xC2), 
                    GAID,   8
                }

                OperationRegion (NCFG, SystemIO, 0x2E, 0x02)
                Field (NCFG, ByteAcc, NoLock, Preserve)
                {
                    INDX,   8, 
                    DATA,   8
                }

                IndexField (INDX, DATA, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x07), 
                    LDN,    8, 
                    Offset (0x20), 
                    SIOD,   8, 
                    Offset (0x22), 
                    SCF2,   8, 
                    Offset (0x24), 
                    SCF4,   8, 
                        ,   2, 
                    PPSE,   1, 
                        ,   4, 
                    PNF,    1, 
                    FDCD,   1, 
                    PPD,    1, 
                    SP2D,   1, 
                    SP1D,   1, 
                        ,   1, 
                    GPSR,   2, 
                    Offset (0x27), 
                    SRID,   8, 
                    Offset (0x29), 
                    SCF9,   8, 
                    Offset (0x2B), 
                    Offset (0x30), 
                    LDA,    1, 
                    Offset (0x31), 
                    Offset (0x60), 
                    IOHI,   8, 
                    IOLW,   8, 
                    Offset (0x70), 
                    IRQN,   4, 
                    IRQW,   1, 
                    Offset (0x71), 
                    IRQT,   1, 
                    IRQL,   1, 
                    Offset (0x72), 
                    Offset (0x74), 
                    DMA0,   3, 
                    Offset (0x75), 
                    DMA1,   3, 
                    Offset (0x76)
                }

                IndexField (INDX, DATA, ByteAcc, NoLock, Preserve)
                {
                    Offset (0xF0), 
                    PTRS,   1, 
                    PPMC,   1, 
                        ,   2, 
                    PERA,   1, 
                    PMDS,   3
                }

                IndexField (INDX, DATA, ByteAcc, NoLock, Preserve)
                {
                    Offset (0xF0), 
                    STRS,   1, 
                    SPMC,   1, 
                    SBSY,   1, 
                        ,   4, 
                    SBSE,   1
                }

                IndexField (INDX, DATA, ByteAcc, NoLock, Preserve)
                {
                    Offset (0xF0), 
                    GPPS,   8, 
                    GPPC,   8, 
                    GPER,   8
                }

                OperationRegion (CFGS, SystemIO, 0x164E, 0x02)
                Field (CFGS, ByteAcc, NoLock, Preserve)
                {
                    NDXS,   8, 
                    ATAS,   8
                }

                IndexField (NDXS, ATAS, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x07), 
                    LDNS,   8, 
                    Offset (0x20), 
                    Offset (0x21), 
                    Offset (0x22), 
                    Offset (0x23), 
                    Offset (0x24), 
                    Offset (0x25), 
                        ,   2, 
                    PSES,   1, 
                        ,   4, 
                    PNFS,   1, 
                    DCDS,   1, 
                    PPDS,   1, 
                    SP2S,   1, 
                    SP1S,   1, 
                        ,   1, 
                    PSRS,   2, 
                    Offset (0x27), 
                    RIDS,   8, 
                    Offset (0x29), 
                    CCSS,   2, 
                    CCES,   1, 
                    MCSS,   1, 
                    MESS,   1, 
                    Offset (0x2A), 
                    Offset (0x2B), 
                    Offset (0x30), 
                    LDAS,   1, 
                    Offset (0x31), 
                    Offset (0x60), 
                    OHIS,   8, 
                    OLWS,   8, 
                    Offset (0x70), 
                    RQNS,   4, 
                    RQWS,   1, 
                    Offset (0x71), 
                    RQTS,   1, 
                    RQLS,   1, 
                    Offset (0x72), 
                    Offset (0x74), 
                    MA0S,   3, 
                    Offset (0x75), 
                    MA1S,   3, 
                    Offset (0x76), 
                    Offset (0xF0), 
                    DTSC,   1, 
                    DCF1,   1, 
                    DCF2,   1, 
                    DCF3,   1, 
                    DCF4,   1, 
                    DCF5,   1, 
                    DCF6,   1, 
                    DCF7,   1
                }

                IndexField (NDXS, ATAS, ByteAcc, NoLock, Preserve)
                {
                    Offset (0xF0), 
                    TRSS,   1, 
                    PMCS,   1, 
                    BSYS,   1, 
                        ,   4, 
                    SESS,   1
                }

                OperationRegion (NSDL, SystemIO, 0x164C, 0x01)
                Field (NSDL, ByteAcc, NoLock, Preserve)
                {
                    DLPC,   8
                }

                OperationRegion (NSIO, SystemIO, 0x1680, 0x0C)
                Field (NSIO, ByteAcc, NoLock, Preserve)
                {
                    DRST,   1, 
                    DLPD,   1, 
                    ULRT,   1, 
                    ULPD,   1, 
                    Offset (0x01), 
                        ,   4, 
                    DKI0,   1, 
                    Offset (0x02), 
                    Offset (0x09), 
                    DKI1,   1, 
                    DKI2,   1
                }

                OperationRegion (DSIO, SystemIO, 0x1620, 0x0C)
                Field (DSIO, ByteAcc, NoLock, Preserve)
                {
                        ,   1, 
                    DUSB,   1, 
                    Offset (0x01), 
                    BAHD,   1, 
                    BAAT,   1, 
                    Offset (0x02), 
                    GER0,   8, 
                    ES00,   1, 
                    ES01,   1, 
                        ,   5, 
                    ES07,   1, 
                        ,   6, 
                    GO16,   1, 
                    Offset (0x05), 
                    Offset (0x07), 
                    ES10,   1, 
                    Offset (0x08), 
                    UBPW,   1, 
                    UHPW,   1, 
                    Offset (0x09), 
                    BPRS,   1, 
                    UPRS,   1
                }

                Scope (\_SB.PCI0.LPC)
                {
                    Device (DURT)
                    {
                        Name (_UID, 0x01)  // _UID: Unique ID
                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If (HDSP)
                            {
                                Return (0x00)
                            }

                            If ((\_SB.GDCK._STA () == 0x00))
                            {
                                Return (0x00)
                            }
                            Else
                            {
                                If (XU1E)
                                {
                                    Return (0x0F)
                                }
                                Else
                                {
                                    Return (0x0D)
                                }
                            }
                        }

                        Name (_HID, EisaId ("PNP0501") /* 16550A-compatible COM Serial Port */)  // _HID: Hardware ID
                        Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                        {
                            0x18, 
                            0x03
                        })
                        Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
                        {
                            If (\H8DR)
                            {
                                If (Arg0)
                                {
                                    \_SB.PCI0.LPC.EC.HWRI = 0x01
                                }
                                Else
                                {
                                    \_SB.PCI0.LPC.EC.HWRI = 0x00
                                }
                            }
                            Else
                            {
                                If (Arg0)
                                {
                                    \MBEC (0x32, 0xFF, 0x40)
                                }
                                Else
                                {
                                    \MBEC (0x32, 0xBF, 0x00)
                                }
                            }
                        }

                        Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
                        {
                            XU1E = 0x00
                            LDN = 0x03
                            IRQN = 0x00
                            LDA = 0x00
                            SP1D = 0x01
                        }

                        Name (U1BF, ResourceTemplate ()
                        {
                            IO (Decode16,
                                0x0000,             // Range Minimum
                                0x0000,             // Range Maximum
                                0x01,               // Alignment
                                0x08,               // Length
                                _Y19)
                            IRQNoFlags (_Y1A)
                                {}
                        })
                        CreateWordField (U1BF, \_SB.PCI0.LPC.DURT._Y19._MIN, U1MN)  // _MIN: Minimum Base Address
                        CreateWordField (U1BF, \_SB.PCI0.LPC.DURT._Y19._MAX, U1MX)  // _MAX: Maximum Base Address
                        CreateWordField (U1BF, \_SB.PCI0.LPC.DURT._Y1A._INT, U1IQ)  // _INT: Interrupts
                        Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
                        {
                            LDN = 0x03
                            Local0 = ((IOHI << 0x08) | IOLW) /* \_SB_.PCI0.LPC_.IOLW */
                            U1MN = Local0
                            U1MX = Local0
                            Local0 = IRQN /* \_SB_.PCI0.LPC_.IRQN */
                            If (Local0)
                            {
                                U1IQ = (0x01 << IRQN) /* \_SB_.PCI0.LPC_.IRQN */
                            }
                            Else
                            {
                                U1IQ = 0x00
                            }

                            Return (U1BF) /* \_SB_.PCI0.LPC_.DURT.U1BF */
                        }

                        Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
                        {
                            StartDependentFn (0x00, 0x00)
                            {
                                IO (Decode16,
                                    0x03F8,             // Range Minimum
                                    0x03F8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {4}
                            }
                            StartDependentFn (0x01, 0x00)
                            {
                                IO (Decode16,
                                    0x02F8,             // Range Minimum
                                    0x02F8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {3}
                            }
                            StartDependentFn (0x01, 0x00)
                            {
                                IO (Decode16,
                                    0x03E8,             // Range Minimum
                                    0x03E8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {4}
                            }
                            StartDependentFn (0x01, 0x00)
                            {
                                IO (Decode16,
                                    0x02E8,             // Range Minimum
                                    0x02E8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {3}
                            }
                            StartDependentFn (0x02, 0x00)
                            {
                                IO (Decode16,
                                    0x03F8,             // Range Minimum
                                    0x03F8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {3,5,7}
                            }
                            StartDependentFn (0x02, 0x00)
                            {
                                IO (Decode16,
                                    0x02F8,             // Range Minimum
                                    0x02F8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {4,5,7}
                            }
                            StartDependentFn (0x02, 0x00)
                            {
                                IO (Decode16,
                                    0x03E8,             // Range Minimum
                                    0x03E8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {3,5,7}
                            }
                            StartDependentFn (0x02, 0x00)
                            {
                                IO (Decode16,
                                    0x02E8,             // Range Minimum
                                    0x02E8,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {4,5,7}
                            }
                            EndDependentFn ()
                        })
                        Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
                        {
                            CreateByteField (Arg0, 0x02, RUIL)
                            CreateByteField (Arg0, 0x03, RUIH)
                            CreateWordField (Arg0, 0x02, RUIO)
                            CreateWordField (Arg0, 0x09, RUIQ)
                            LDN = 0x03
                            LDA = 0x00
                            IOLW = RUIL /* \_SB_.PCI0.LPC_.DURT._SRS.RUIL */
                            IOHI = RUIH /* \_SB_.PCI0.LPC_.DURT._SRS.RUIH */
                            If (RUIQ)
                            {
                                FindSetRightBit (RUIQ, Local0)
                                IRQN = Local0--
                            }
                            Else
                            {
                                IRQN = 0x00
                            }

                            SP1D = 0x00
                            LDA = 0x01
                            If ((RUIO == 0x03F8))
                            {
                                XU1A = 0x00
                            }
                            Else
                            {
                                If ((RUIO == 0x02F8))
                                {
                                    XU1A = 0x01
                                }
                                Else
                                {
                                    If ((RUIO == 0x03E8))
                                    {
                                        XU1A = 0x07
                                    }
                                    Else
                                    {
                                        If ((RUIO == 0x02E8))
                                        {
                                            XU1A = 0x05
                                        }
                                        Else
                                        {
                                            Fatal (0x02, 0x90020000, 0x01B8)
                                        }
                                    }
                                }
                            }

                            XU1E = 0x01
                        }

                        Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current
                        {
                            LDN = 0x03
                            If (LDA)
                            {
                                Return (0x00)
                            }
                            Else
                            {
                                Return (0x03)
                            }
                        }

                        Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
                        {
                        }

                        Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
                        {
                        }
                    }

                    Device (DLPT)
                    {
                        Name (_UID, 0x01)  // _UID: Unique ID
                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If (HDPP)
                            {
                                Return (0x00)
                            }

                            If ((\_SB.GDCK._STA () == 0x00))
                            {
                                Return (0x00)
                            }
                            Else
                            {
                                If ((\PMOD != 0x03))
                                {
                                    If (XPE)
                                    {
                                        Return (0x0F)
                                    }
                                    Else
                                    {
                                        Return (0x0D)
                                    }
                                }
                                Else
                                {
                                    Return (0x00)
                                }
                            }
                        }

                        Name (_HID, EisaId ("PNP0400") /* Standard LPT Parallel Port */)  // _HID: Hardware ID
                        Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
                        {
                            XPE = 0x00
                            LDN = 0x01
                            IRQN = 0x00
                            LDA = 0x00
                            PPD = 0x01
                        }

                        Name (PPBF, ResourceTemplate ()
                        {
                            IO (Decode16,
                                0x0000,             // Range Minimum
                                0x0000,             // Range Maximum
                                0x01,               // Alignment
                                0x00,               // Length
                                _Y1B)
                            IRQNoFlags (_Y1C)
                                {}
                        })
                        CreateWordField (PPBF, \_SB.PCI0.LPC.DLPT._Y1B._MIN, LPN0)  // _MIN: Minimum Base Address
                        CreateWordField (PPBF, \_SB.PCI0.LPC.DLPT._Y1B._MAX, LPX0)  // _MAX: Maximum Base Address
                        CreateByteField (PPBF, \_SB.PCI0.LPC.DLPT._Y1B._LEN, LPL0)  // _LEN: Length
                        CreateWordField (PPBF, \_SB.PCI0.LPC.DLPT._Y1C._INT, LPIQ)  // _INT: Interrupts
                        Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
                        {
                            If ((\PMOD == 0x03))
                            {
                                Return (PPBF) /* \_SB_.PCI0.LPC_.DLPT.PPBF */
                            }

                            LDN = 0x01
                            Local0 = ((IOHI << 0x08) | IOLW) /* \_SB_.PCI0.LPC_.IOLW */
                            LPN0 = Local0
                            LPX0 = Local0
                            If ((Local0 == 0x03BC))
                            {
                                LPL0 = 0x03
                            }
                            Else
                            {
                                LPL0 = 0x08
                            }

                            Local0 = IRQN /* \_SB_.PCI0.LPC_.IRQN */
                            If (Local0)
                            {
                                LPIQ = (0x01 << IRQN) /* \_SB_.PCI0.LPC_.IRQN */
                            }
                            Else
                            {
                                LPIQ = 0x00
                            }

                            Return (PPBF) /* \_SB_.PCI0.LPC_.DLPT.PPBF */
                        }

                        Method (_PRS, 0, NotSerialized)  // _PRS: Possible Resource Settings
                        {
                            If (\PMOD)
                            {
                                Return (PEPP) /* \_SB_.PCI0.LPC_.DLPT.PEPP */
                            }
                            Else
                            {
                                Return (PLPT) /* \_SB_.PCI0.LPC_.DLPT.PLPT */
                            }
                        }

                        Name (PLPT, ResourceTemplate ()
                        {
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x03BC,             // Range Minimum
                                    0x03BC,             // Range Maximum
                                    0x01,               // Alignment
                                    0x03,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0378,             // Range Minimum
                                    0x0378,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0278,             // Range Minimum
                                    0x0278,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x03BC,             // Range Minimum
                                    0x03BC,             // Range Maximum
                                    0x01,               // Alignment
                                    0x03,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0378,             // Range Minimum
                                    0x0378,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0278,             // Range Minimum
                                    0x0278,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                            }
                            EndDependentFn ()
                        })
                        Name (PEPP, ResourceTemplate ()
                        {
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0378,             // Range Minimum
                                    0x0378,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0278,             // Range Minimum
                                    0x0278,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0378,             // Range Minimum
                                    0x0378,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0278,             // Range Minimum
                                    0x0278,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                            }
                            EndDependentFn ()
                        })
                        Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
                        {
                            CreateByteField (Arg0, 0x02, RLIL)
                            CreateByteField (Arg0, 0x03, RLIH)
                            CreateWordField (Arg0, 0x02, RLIO)
                            CreateWordField (Arg0, 0x09, RLIQ)
                            LDN = 0x01
                            LDA = 0x00
                            IOLW = RLIL /* \_SB_.PCI0.LPC_.DLPT._SRS.RLIL */
                            IOHI = RLIH /* \_SB_.PCI0.LPC_.DLPT._SRS.RLIH */
                            If (RLIQ)
                            {
                                FindSetRightBit (RLIQ, Local0)
                                IRQN = Local0--
                            }
                            Else
                            {
                                IRQN = 0x00
                            }

                            If ((\PMOD == 0x00))
                            {
                                If (\PDIR)
                                {
                                    PMDS = 0x01
                                }
                                Else
                                {
                                    PMDS = 0x00
                                }
                            }
                            Else
                            {
                                If ((\PMOD == 0x01))
                                {
                                    PMDS = 0x02
                                }
                                Else
                                {
                                    PMDS = 0x03
                                }
                            }

                            PPD = 0x00
                            LDA = 0x01
                            If ((RLIO == 0x0378))
                            {
                                XPA = 0x00
                            }
                            Else
                            {
                                If ((RLIO == 0x0278))
                                {
                                    XPA = 0x01
                                }
                                Else
                                {
                                    If ((RLIO == 0x03BC))
                                    {
                                        XPA = 0x02
                                    }
                                    Else
                                    {
                                        Fatal (0x02, 0x90020000, 0x01D1)
                                    }
                                }
                            }

                            XPE = 0x01
                        }

                        Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current
                        {
                            LDN = 0x01
                            If (LDA)
                            {
                                Return (0x00)
                            }
                            Else
                            {
                                Return (0x03)
                            }
                        }

                        Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
                        {
                            LDN = 0x01
                            LDA = 0x01
                        }

                        Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
                        {
                            LDN = 0x01
                            LDA = 0x00
                        }
                    }

                    Device (DECP)
                    {
                        Name (_UID, 0x01)  // _UID: Unique ID
                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If ((\_SB.GDCK._STA () == 0x00))
                            {
                                Return (0x00)
                            }
                            Else
                            {
                                If ((\PMOD == 0x03))
                                {
                                    If (XPE)
                                    {
                                        Return (0x0F)
                                    }
                                    Else
                                    {
                                        Return (0x0D)
                                    }
                                }
                                Else
                                {
                                    Return (0x00)
                                }
                            }
                        }

                        Name (_HID, EisaId ("PNP0401") /* ECP Parallel Port */)  // _HID: Hardware ID
                        Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
                        {
                            XPE = 0x00
                            LDN = 0x01
                            IRQN = 0x00
                            LDA = 0x00
                            PPD = 0x01
                        }

                        Name (EPBF, ResourceTemplate ()
                        {
                            IO (Decode16,
                                0x0000,             // Range Minimum
                                0x0000,             // Range Maximum
                                0x01,               // Alignment
                                0x00,               // Length
                                _Y1D)
                            IO (Decode16,
                                0x0000,             // Range Minimum
                                0x0000,             // Range Maximum
                                0x01,               // Alignment
                                0x00,               // Length
                                _Y1E)
                            IRQNoFlags (_Y1F)
                                {}
                            DMA (Compatibility, NotBusMaster, Transfer8, _Y20)
                                {}
                        })
                        CreateWordField (EPBF, \_SB.PCI0.LPC.DECP._Y1D._MIN, ECN0)  // _MIN: Minimum Base Address
                        CreateWordField (EPBF, \_SB.PCI0.LPC.DECP._Y1D._MAX, ECX0)  // _MAX: Maximum Base Address
                        CreateByteField (EPBF, \_SB.PCI0.LPC.DECP._Y1D._LEN, ECL0)  // _LEN: Length
                        CreateWordField (EPBF, \_SB.PCI0.LPC.DECP._Y1E._MIN, ECN1)  // _MIN: Minimum Base Address
                        CreateWordField (EPBF, \_SB.PCI0.LPC.DECP._Y1E._MAX, ECX1)  // _MAX: Maximum Base Address
                        CreateByteField (EPBF, \_SB.PCI0.LPC.DECP._Y1E._LEN, ECL1)  // _LEN: Length
                        CreateWordField (EPBF, \_SB.PCI0.LPC.DECP._Y1F._INT, ECIQ)  // _INT: Interrupts
                        CreateWordField (EPBF, \_SB.PCI0.LPC.DECP._Y20._DMA, ECDQ)  // _DMA: Direct Memory Access
                        Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
                        {
                            If ((\PMOD != 0x03))
                            {
                                Return (EPBF) /* \_SB_.PCI0.LPC_.DECP.EPBF */
                            }

                            LDN = 0x01
                            Local0 = ((IOHI << 0x08) | IOLW) /* \_SB_.PCI0.LPC_.IOLW */
                            ECN0 = Local0
                            ECX0 = Local0
                            ECN1 = (Local0 + 0x0400)
                            ECX1 = (Local0 + 0x0400)
                            If ((Local0 == 0x03BC))
                            {
                                ECL0 = 0x03
                                ECL1 = 0x03
                            }
                            Else
                            {
                                ECL0 = 0x08
                                ECL1 = 0x08
                            }

                            Local0 = IRQN /* \_SB_.PCI0.LPC_.IRQN */
                            If (Local0)
                            {
                                ECIQ = (0x01 << IRQN) /* \_SB_.PCI0.LPC_.IRQN */
                            }
                            Else
                            {
                                ECIQ = 0x00
                            }

                            Local0 = DMA0 /* \_SB_.PCI0.LPC_.DMA0 */
                            If ((Local0 < 0x04))
                            {
                                ECDQ = (0x01 << Local0)
                            }
                            Else
                            {
                                ECDQ = 0x00
                            }

                            Return (EPBF) /* \_SB_.PCI0.LPC_.DECP.EPBF */
                        }

                        Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
                        {
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0378,             // Range Minimum
                                    0x0378,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IO (Decode16,
                                    0x0778,             // Range Minimum
                                    0x0778,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                                DMA (Compatibility, NotBusMaster, Transfer8, )
                                    {0,1,3}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0278,             // Range Minimum
                                    0x0278,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IO (Decode16,
                                    0x0678,             // Range Minimum
                                    0x0678,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                                DMA (Compatibility, NotBusMaster, Transfer8, )
                                    {0,1,3}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x03BC,             // Range Minimum
                                    0x03BC,             // Range Maximum
                                    0x01,               // Alignment
                                    0x03,               // Length
                                    )
                                IO (Decode16,
                                    0x07BC,             // Range Minimum
                                    0x07BC,             // Range Maximum
                                    0x01,               // Alignment
                                    0x03,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                                DMA (Compatibility, NotBusMaster, Transfer8, )
                                    {0,1,3}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0378,             // Range Minimum
                                    0x0378,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IO (Decode16,
                                    0x0778,             // Range Minimum
                                    0x0778,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                                DMA (Compatibility, NotBusMaster, Transfer8, )
                                    {0,1,3}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x0278,             // Range Minimum
                                    0x0278,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IO (Decode16,
                                    0x0678,             // Range Minimum
                                    0x0678,             // Range Maximum
                                    0x01,               // Alignment
                                    0x08,               // Length
                                    )
                                IRQNoFlags ()
                                    {7}
                                DMA (Compatibility, NotBusMaster, Transfer8, )
                                    {0,1,3}
                            }
                            StartDependentFnNoPri ()
                            {
                                IO (Decode16,
                                    0x03BC,             // Range Minimum
                                    0x03BC,             // Range Maximum
                                    0x01,               // Alignment
                                    0x03,               // Length
                                    )
                                IO (Decode16,
                                    0x07BC,             // Range Minimum
                                    0x07BC,             // Range Maximum
                                    0x01,               // Alignment
                                    0x03,               // Length
                                    )
                                IRQNoFlags ()
                                    {5}
                                DMA (Compatibility, NotBusMaster, Transfer8, )
                                    {0,1,3}
                            }
                            EndDependentFn ()
                        })
                        Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
                        {
                            CreateByteField (Arg0, 0x02, RLIL)
                            CreateByteField (Arg0, 0x03, RLIH)
                            CreateWordField (Arg0, 0x02, RLIO)
                            CreateWordField (Arg0, 0x11, RLIQ)
                            CreateByteField (Arg0, 0x14, RLDQ)
                            LDN = 0x01
                            LDA = 0x00
                            PMDS = 0x07
                            PERA = 0x01
                            IOLW = RLIL /* \_SB_.PCI0.LPC_.DECP._SRS.RLIL */
                            IOHI = RLIH /* \_SB_.PCI0.LPC_.DECP._SRS.RLIH */
                            If (RLIQ)
                            {
                                FindSetRightBit (RLIQ, Local0)
                                IRQN = Local0--
                            }
                            Else
                            {
                                IRQN = 0x00
                            }

                            If ((RLDQ & 0x0F))
                            {
                                FindSetRightBit (RLDQ, Local0)
                                DMA0 = Local0--
                            }
                            Else
                            {
                                DMA0 = 0x04
                            }

                            PPD = 0x00
                            LDA = 0x01
                            If ((RLIO == 0x0378))
                            {
                                XPA = 0x00
                            }
                            Else
                            {
                                If ((RLIO == 0x0278))
                                {
                                    XPA = 0x01
                                }
                                Else
                                {
                                    If ((RLIO == 0x03BC))
                                    {
                                        XPA = 0x02
                                    }
                                    Else
                                    {
                                        Fatal (0x02, 0x90020000, 0x01A2)
                                    }
                                }
                            }

                            XPE = 0x01
                        }

                        Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current
                        {
                            LDN = 0x01
                            If (LDA)
                            {
                                Return (0x00)
                            }
                            Else
                            {
                                Return (0x03)
                            }
                        }

                        Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
                        {
                            LDN = 0x01
                            LDA = 0x01
                        }

                        Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
                        {
                            LDN = 0x01
                            LDA = 0x00
                        }
                    }
                }

                Scope (\_SB.PCI0.LPC.DURT)
                {
                    Name (_EJD, "_SB.GDCK")  // _EJD: Ejection Dependent Device
                }

                Scope (\_SB.PCI0.LPC.DLPT)
                {
                    Name (_EJD, "_SB.GDCK")  // _EJD: Ejection Dependent Device
                }

                Scope (\_SB.PCI0.LPC.DECP)
                {
                    Name (_EJD, "_SB.GDCK")  // _EJD: Ejection Dependent Device
                }

                Scope (\_SB.PCI0.LPC)
                {
                    Method (LCON, 1, NotSerialized)
                    {
                        If (Arg0)
                        {
                            If (EPWG)
                            {
                                DLPD = 0x01
                                DLPC = 0x07
                                While (!(0x08 & DLPC))
                                {
                                    Sleep (0x01)
                                }

                                DRST = 0x01
                                If ((SIOD != 0xFF))
                                {
                                    SCF9 |= 0xA0
                                    While (!(0x10 & SCF9))
                                    {
                                        Sleep (0x01)
                                    }

                                    SCF2 |= 0xEB
                                    LDN = 0x07
                                    Local0 = (0x1620 & 0xFF)
                                    IOLW = Local0
                                    Local0 = (0x1620 >> 0x08)
                                    IOHI = (Local0 & 0xFF)
                                    LDA = 0x01
                                    GPPS = 0x01
                                    GPPC = 0x03
                                    GPPS = 0x02
                                    GPPC = 0x03
                                    DUSB = 0x00
                                }
                            }
                        }
                        Else
                        {
                            DUSB = 0x01
                            DRST = 0x00
                            DLPD = 0x00
                            DLPC = 0x00
                        }
                    }

                    Method (LLCN, 1, NotSerialized)
                    {
                        If (Arg0)
                        {
                            ULRT = 0x00
                            ULPD = 0x01
                            DLPC = 0x07
                            While (!(0x08 & DLPC))
                            {
                                Sleep (0x01)
                            }

                            ULRT = 0x01
                            If ((SIOD != 0xFF))
                            {
                                SCF9 |= 0xA0
                                While (!(0x10 & SCF9))
                                {
                                    Sleep (0x01)
                                }

                                SCF2 |= 0xEB
                            }
                        }
                        Else
                        {
                            ULRT = 0x00
                            ULPD = 0x00
                            DLPC = 0x00
                        }
                    }
                }

                Device (DTR)
                {
                    Name (LCFG, 0x00)
                    Name (LBAR, 0x00)
                    Method (_INI, 0, NotSerialized)  // _INI: Initialize
                    {
                        LDNS = 0x03
                        LBAR = ((OHIS << 0x08) | OLWS) /* \_SB_.PCI0.LPC_.OLWS */
                    }

                    Method (_HID, 0, NotSerialized)  // _HID: Hardware ID
                    {
                        If (\DATD)
                        {
                            Return (0x08F0235C)
                        }
                        Else
                        {
                            Return (0x04F0235C)
                        }
                    }

                    Method (_STA, 0, NotSerialized)  // _STA: Status
                    {
                        LDNS = 0x03
                        If ((LDAS && LCFG))
                        {
                            Return (0x0F)
                        }
                        Else
                        {
                            Return (0x0D)
                        }
                    }

                    Method (_DIS, 0, NotSerialized)  // _DIS: Disable Device
                    {
                        LCFG = 0x00
                        LDNS = 0x03
                        RQNS = 0x00
                        LDAS = 0x00
                        If ((LBAR == 0x0200))
                        {
                            XGML = 0x00
                        }
                        Else
                        {
                            If ((LBAR == 0x0208))
                            {
                                XGMH = 0x00
                            }
                            Else
                            {
                                Fatal (0x02, 0x90020000, 0x50)
                            }
                        }
                    }

                    Name (DTBF, ResourceTemplate ()
                    {
                        IO (Decode16,
                            0x0000,             // Range Minimum
                            0x0000,             // Range Maximum
                            0x01,               // Alignment
                            0x08,               // Length
                            _Y21)
                        IRQNoFlags (_Y22)
                            {}
                    })
                    CreateWordField (DTBF, \_SB.PCI0.LPC.DTR._Y21._MIN, S1MN)  // _MIN: Minimum Base Address
                    CreateWordField (DTBF, \_SB.PCI0.LPC.DTR._Y21._MAX, S1MX)  // _MAX: Maximum Base Address
                    CreateWordField (DTBF, \_SB.PCI0.LPC.DTR._Y22._INT, S1IQ)  // _INT: Interrupts
                    Method (_CRS, 0, NotSerialized)  // _CRS: Current Resource Settings
                    {
                        LDNS = 0x03
                        S1MN = ((OHIS << 0x08) | OLWS) /* \_SB_.PCI0.LPC_.OLWS */
                        S1MX = S1MN /* \_SB_.PCI0.LPC_.DTR_.S1MN */
                        Local0 = RQNS /* \_SB_.PCI0.LPC_.RQNS */
                        If (Local0)
                        {
                            S1IQ = (0x01 << RQNS) /* \_SB_.PCI0.LPC_.RQNS */
                        }
                        Else
                        {
                            S1IQ = 0x00
                        }

                        Return (DTBF) /* \_SB_.PCI0.LPC_.DTR_.DTBF */
                    }

                    Name (_PRS, ResourceTemplate ()  // _PRS: Possible Resource Settings
                    {
                        StartDependentFn (0x00, 0x00)
                        {
                            IO (Decode16,
                                0x0200,             // Range Minimum
                                0x0200,             // Range Maximum
                                0x01,               // Alignment
                                0x08,               // Length
                                )
                            IRQNoFlags ()
                                {5}
                        }
                        StartDependentFn (0x01, 0x00)
                        {
                            IO (Decode16,
                                0x0208,             // Range Minimum
                                0x0208,             // Range Maximum
                                0x01,               // Alignment
                                0x08,               // Length
                                )
                            IRQNoFlags ()
                                {3}
                        }
                        StartDependentFn (0x02, 0x00)
                        {
                            IO (Decode16,
                                0x0200,             // Range Minimum
                                0x0200,             // Range Maximum
                                0x01,               // Alignment
                                0x08,               // Length
                                )
                            IRQNoFlags ()
                                {3,4,6,7}
                        }
                        StartDependentFn (0x02, 0x00)
                        {
                            IO (Decode16,
                                0x0208,             // Range Minimum
                                0x0208,             // Range Maximum
                                0x01,               // Alignment
                                0x08,               // Length
                                )
                            IRQNoFlags ()
                                {4,5,6,7}
                        }
                        EndDependentFn ()
                    })
                    Method (_SRS, 1, NotSerialized)  // _SRS: Set Resource Settings
                    {
                        CreateByteField (Arg0, 0x02, RDIL)
                        CreateByteField (Arg0, 0x03, RDIH)
                        CreateWordField (Arg0, 0x02, RDIO)
                        CreateWordField (Arg0, 0x09, RDIQ)
                        LDNS = 0x03
                        LDAS = 0x00
                        RQNS = 0x00
                        OLWS = RDIL /* \_SB_.PCI0.LPC_.DTR_._SRS.RDIL */
                        OHIS = RDIH /* \_SB_.PCI0.LPC_.DTR_._SRS.RDIH */
                        If (RDIQ)
                        {
                            FindSetRightBit (RDIQ, Local2)
                            RQNS = Local2--
                        }
                        Else
                        {
                            RQNS = 0x00
                        }

                        LDAS = 0x01
                        If ((RDIO == 0x0200))
                        {
                            XGML = 0x01
                            XGMH = 0x00
                        }
                        Else
                        {
                            If ((RDIO == 0x0208))
                            {
                                XGML = 0x00
                                XGMH = 0x01
                            }
                            Else
                            {
                                Fatal (0x02, 0x90020000, 0xD7)
                            }
                        }

                        LBAR = RDIO /* \_SB_.PCI0.LPC_.DTR_._SRS.RDIO */
                        LCFG = 0x01
                    }

                    Method (_PSC, 0, NotSerialized)  // _PSC: Power State Current
                    {
                        LDNS = 0x03
                        If (DCF1)
                        {
                            Return (0x00)
                        }
                        Else
                        {
                            Return (0x03)
                        }
                    }

                    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
                    {
                        LDNS = 0x03
                        DCF1 = 0x01
                    }

                    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
                    {
                        LDNS = 0x03
                        DCF1 = 0x00
                    }
                }

                Device (TPM)
                {
                    Name (_HID, EisaId ("ATM1200"))  // _HID: Hardware ID
                    Name (_CID, EisaId ("PNP0C31"))  // _CID: Compatible ID
                    Method (_STA, 0, NotSerialized)  // _STA: Status
                    {
                        If ((\TPMP & 0x01))
                        {
                            Local0 = 0x0F
                        }
                        Else
                        {
                            Local0 = 0x00
                        }

                        Return (Local0)
                    }

                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        Memory32Fixed (ReadWrite,
                            0xFED40000,         // Address Base
                            0x00005000,         // Address Length
                            )
                    })
                    Method (_DSM, 4, Serialized)  // _DSM: Device-Specific Method
                    {
                        Name (TMPB, Buffer (0x02)
                        {
                             0x00, 0x00                                       /* .. */
                        })
                        CreateByteField (TMPB, 0x00, LPCT)
                        CreateByteField (TMPB, 0x01, SSUM)
                        Name (LRSP, 0x00)
                        Name (PPRC, 0x00)
                        Name (RQS1, Package (0x02)
                        {
                            0x0C, 
                            0x0D
                        })
                        Name (PTOP, Package (0x02)
                        {
                            0x00, 
                            0x00
                        })
                        Name (RTOP, Package (0x03)
                        {
                            0x00, 
                            0x00, 
                            0x00
                        })
                        CreateDWordField (Arg0, 0x00, IID0)
                        CreateDWordField (Arg0, 0x04, IID1)
                        CreateDWordField (Arg0, 0x08, IID2)
                        CreateDWordField (Arg0, 0x0C, IID3)
                        Name (UID0, ToUUID ("3dddfaa6-361b-4eb4-a424-8d10089d1653") /* Physical Presence Interface */)
                        CreateDWordField (UID0, 0x00, EID0)
                        CreateDWordField (UID0, 0x04, EID1)
                        CreateDWordField (UID0, 0x08, EID2)
                        CreateDWordField (UID0, 0x0C, EID3)
                        If ((((IID0 == EID0) && (IID1 == EID1)) && ((IID2 == 
                            EID2) && (IID3 == EID3))))
                        {
                            If ((Arg2 == 0x00))
                            {
                                Return (Buffer (0x01)
                                {
                                     0x3F                                             /* ? */
                                })
                            }

                            If ((Arg2 == 0x01))
                            {
                                Return ("1.0")
                            }

                            If ((Arg2 == 0x02))
                            {
                                PPRC = 0x00
                                TPHY (0x00)
                                LPCT = \PH02
                                If (LPCT)
                                {
                                    SSUM = 0x00
                                    SSUM += \PH01
                                    SSUM += \PH02
                                    SSUM += \PH03
                                    SSUM += \PH04
                                    SSUM += \PH05
                                    SSUM += \PH06
                                    SSUM += \PH07
                                    SSUM += \PH08
                                    SSUM += \PH09
                                    SSUM += \PH0A
                                    SSUM += \PH0B
                                    If (SSUM)
                                    {
                                        PPRC = 0x02
                                    }
                                    Else
                                    {
                                        \PH04 = DerefOf (Index (Arg3, 0x00))
                                        Local0 = Match (RQS1, MEQ, \PH04, MTR, 0x00, 0x00)
                                        If ((Local0 != Ones))
                                        {
                                            PPRC = 0x01
                                        }
                                        Else
                                        {
                                            \PH03 = 0x00
                                            SSUM = 0x00
                                            SSUM += \PH01
                                            SSUM += \PH02
                                            SSUM += \PH03
                                            SSUM += \PH04
                                            SSUM += \PH05
                                            SSUM += \PH06
                                            SSUM += \PH07
                                            SSUM += \PH08
                                            SSUM += \PH09
                                            SSUM += \PH0A
                                            SSUM += \PH0B
                                            \PH03 = (0x00 - SSUM) /* \_SB_.PCI0.LPC_.TPM_._DSM.SSUM */
                                            TPHY (0x01)
                                        }
                                    }
                                }
                                Else
                                {
                                    PPRC = 0x02
                                }

                                Return (PPRC) /* \_SB_.PCI0.LPC_.TPM_._DSM.PPRC */
                            }

                            If ((Arg2 == 0x03))
                            {
                                TPHY (0x00)
                                Index (PTOP, 0x01) = \PH04
                                Return (PTOP) /* \_SB_.PCI0.LPC_.TPM_._DSM.PTOP */
                            }

                            If ((Arg2 == 0x04))
                            {
                                Return (0x01)
                            }

                            If ((Arg2 == 0x05))
                            {
                                TPHY (0x00)
                                Local0 = \PH07
                                LRSP = \PH06
                                LRSP = (Local0 <<= 0x08 | LRSP)
                                If (((\PH06 == 0xF0) && (\PH07 == 0xFF)))
                                {
                                    LRSP = 0xFFFFFFF0
                                }
                                Else
                                {
                                    If (((\PH06 == 0xF1) && (\PH07 == 0xFF)))
                                    {
                                        LRSP = 0xFFFFFFF1
                                    }
                                }

                                Index (RTOP, 0x02) = LRSP /* \_SB_.PCI0.LPC_.TPM_._DSM.LRSP */
                                Index (RTOP, 0x01) = \PH05
                                Return (RTOP) /* \_SB_.PCI0.LPC_.TPM_._DSM.RTOP */
                            }

                            If ((Arg2 == 0x06))
                            {
                                Return (0x02)
                            }
                        }

                        Name (UID1, ToUUID ("376054ed-cc13-4675-901c-4756d7f2d45d"))
                        CreateDWordField (UID1, 0x00, EID4)
                        CreateDWordField (UID1, 0x04, EID5)
                        CreateDWordField (UID1, 0x08, EID6)
                        CreateDWordField (UID1, 0x0C, EID7)
                        If ((((IID0 == EID4) && (IID1 == EID5)) && ((IID2 == 
                            EID6) && (IID3 == EID7))))
                        {
                            Debug = Arg2
                            Debug = Arg3
                            If ((Arg2 == 0x00))
                            {
                                Return (Buffer (0x01)
                                {
                                     0x01                                             /* . */
                                })
                            }

                            If ((Arg2 == 0x01))
                            {
                                If ((DerefOf (Index (Arg3, 0x00)) == 0x00))
                                {
                                    \TCG0 = 0x00
                                    \TCG1 = 0x01
                                }

                                If ((DerefOf (Index (Arg3, 0x00)) == 0x01))
                                {
                                    \TCG0 = 0x01
                                    \TCG1 = 0x01
                                }

                                Return (0x00)
                            }

                            Return (0x01)
                        }

                        Return (Buffer (0x01)
                        {
                             0x00                                             /* . */
                        })
                    }
                }

                OperationRegion (TSES, SystemMemory, 0xFFE80000, 0x0200)
                Field (TSES, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x0C), 
                    TSCM,   8, 
                    Offset (0x5D), 
                    TCT0,   8, 
                    TCT1,   8, 
                    TCT2,   8, 
                    Offset (0x6A), 
                    TMT0,   8, 
                    Offset (0x74), 
                    TMT1,   8, 
                    Offset (0x7E), 
                    TMT2,   8, 
                    Offset (0x174), 
                    TLD0,   8, 
                    TLD1,   8, 
                    TLD2,   8, 
                    TLDL,   24, 
                    TLDB,   24, 
                    TLDS,   16, 
                    TSB0,   8, 
                    TSB1,   8, 
                    TSB2,   8, 
                    TSBL,   8, 
                    TSBB,   72, 
                    TSBF,   16, 
                    TSBC,   16, 
                    Offset (0x1C4), 
                    TSIM,   8
                }

                Field (TSES, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x5D), 
                    TCTA,   280
                }

                Field (TSES, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x174), 
                    TCTL,   88
                }

                Field (TSES, ByteAcc, NoLock, Preserve)
                {
                    Offset (0x17F), 
                    TCTB,   136
                }

                Method (TCSZ, 2, NotSerialized)
                {
                    If ((TSCM != 0x12))
                    {
                        If ((0x01 == Arg0))
                        {
                            TCZ1 = Arg1
                        }
                        Else
                        {
                            If ((0x02 == Arg0))
                            {
                                TCZ2 = Arg1
                            }
                            Else
                            {
                                If ((0x03 == Arg0))
                                {
                                    TCZ3 = Arg1
                                }
                            }
                        }
                    }
                }

                Method (TCST, 2, NotSerialized)
                {
                    If ((TSCM != 0x12))
                    {
                        Local0 = 0x00
                        If ((0x01 == Arg0))
                        {
                            If ((Arg1 > TMT0))
                            {
                                TSIM = 0x04
                                TMT0 = Arg1
                                Local0 = 0x01
                            }
                        }
                        Else
                        {
                            If ((0x02 == Arg0))
                            {
                                If ((Arg1 > TMT1))
                                {
                                    TSIM = 0x04
                                    TMT1 = Arg1
                                    Local0 = 0x01
                                }
                            }
                            Else
                            {
                                If ((0x03 == Arg0))
                                {
                                    If ((Arg1 > TMT2))
                                    {
                                        TSIM = 0x04
                                        TMT2 = Arg1
                                        Local0 = 0x01
                                    }
                                }
                            }
                        }

                        If (Local0)
                        {
                            TCT2 = 0x00
                            Name (TCTC, Buffer (0x23) {})
                            TCTC = TCTA /* \_SB_.PCI0.LPC_.TCTA */
                            Local3 = 0x22
                            Local1 = 0x00
                            While (Local3)
                            {
                                Local2 = DerefOf (Index (TCTC, Local3))
                                Local1 += Local2
                                Local3--
                            }

                            Local2 = ~Local1
                            Local2++
                            Local1 = (Local2 & 0xFF)
                            TCT2 = Local1
                            TSIM = 0xFE
                        }
                    }
                }

                Method (TCBS, 4, NotSerialized)
                {
                    If ((TSCM != 0x12))
                    {
                        If (((Arg0 & 0x07) == 0x00))
                        {
                            TSIM = 0x12
                            TSBL = Arg0
                            TSBB = Arg1
                            TSBF = Arg2
                            TSBC = Arg3
                            TSB2 = 0x00
                            Name (TCTD, Buffer (0x23) {})
                            TCTD = TCTB /* \_SB_.PCI0.LPC_.TCTB */
                            Local0 = 0x10
                            Local1 = 0x00
                            While (Local0)
                            {
                                Local2 = DerefOf (Index (TCTD, Local0))
                                Local1 += Local2
                                Local0--
                            }

                            Local2 = ~Local1
                            Local2++
                            Local1 = (Local2 & 0xFF)
                            TSB2 = Local1
                            TSIM = 0xFE
                        }
                    }
                }

                Method (TSCL, 2, NotSerialized)
                {
                    If ((TSCM != 0x12))
                    {
                        TSIM = 0x15
                        TLDS += Arg1
                        TLD2 = 0x00
                        Name (TLDD, Buffer (0x0B) {})
                        TLDD = TCTL /* \_SB_.PCI0.LPC_.TCTL */
                        Local0 = 0x0A
                        Local1 = 0x00
                        While (Local0)
                        {
                            Local2 = DerefOf (Index (TLDD, Local0))
                            Local1 += Local2
                            Local0--
                        }

                        Local2 = ~Local1
                        Local2++
                        Local1 = (Local2 & 0xFF)
                        TLD2 = Local1
                        TSIM = 0xFE
                    }
                }

                Device (EC)
                {
                    Name (_HID, EisaId ("PNP0C09") /* Embedded Controller Device */)  // _HID: Hardware ID
                    Name (_UID, 0x00)  // _UID: Unique ID
                    Name (_GPE, 0x12)  // _GPE: General Purpose Events
                    Method (_REG, 2, NotSerialized)  // _REG: Region Availability
                    {
                        If ((Arg0 == 0x03))
                        {
                            \H8DR = Arg1
                        }
                    }

                    OperationRegion (ECOR, EmbeddedControl, 0x00, 0x0100)
                    Field (ECOR, ByteAcc, NoLock, Preserve)
                    {
                        HDBM,   1, 
                            ,   1, 
                            ,   1, 
                        HFNE,   1, 
                            ,   1, 
                            ,   1, 
                        HLDM,   1, 
                        Offset (0x01), 
                        HDIM,   1, 
                        BTCM,   1, 
                            ,   1, 
                            ,   1, 
                            ,   1, 
                        HBPR,   1, 
                        BTPC,   1, 
                        Offset (0x02), 
                        SLIS,   1, 
                        HPWC,   2, 
                        Offset (0x03), 
                            ,   1, 
                        HETE,   1, 
                            ,   3, 
                        HAUM,   2, 
                        Offset (0x05), 
                        HSPA,   1, 
                        Offset (0x06), 
                        HSUN,   8, 
                        HSRP,   8, 
                        Offset (0x0C), 
                        HLCL,   8, 
                        Offset (0x0E), 
                        HFNS,   2, 
                        Offset (0x0F), 
                            ,   4, 
                        HAAA,   3, 
                        HTAB,   1, 
                        HAM0,   8, 
                        HAM1,   8, 
                        HAM2,   8, 
                        HAM3,   8, 
                        HAM4,   8, 
                        HAM5,   8, 
                        HAM6,   8, 
                        HAM7,   8, 
                        HAM8,   8, 
                        HAM9,   8, 
                        HAMA,   8, 
                        HAMB,   8, 
                        HAMC,   8, 
                        HAMD,   8, 
                        HAME,   8, 
                        HAMF,   8, 
                        HT00,   1, 
                        HT01,   1, 
                        HT02,   1, 
                        HT03,   1, 
                        HT10,   1, 
                        HT11,   1, 
                        HT12,   1, 
                        HT13,   1, 
                        Offset (0x23), 
                        HANT,   8, 
                        Offset (0x26), 
                            ,   1, 
                            ,   1, 
                        HANA,   2, 
                            ,   1, 
                            ,   1, 
                        Offset (0x2A), 
                        HATR,   8, 
                        HT0H,   8, 
                        HT0L,   8, 
                        HT1H,   8, 
                        HT1L,   8, 
                        HFSP,   8, 
                            ,   6, 
                        HMUT,   1, 
                        Offset (0x31), 
                        HBRV,   8, 
                        HWPM,   1, 
                        HWLB,   1, 
                        HWLO,   1, 
                        HWDK,   1, 
                        HWFN,   1, 
                        HWBT,   1, 
                        HWRI,   1, 
                        HWBU,   1, 
                        HWPN,   2, 
                        Offset (0x34), 
                            ,   7, 
                        HPLO,   1, 
                        Offset (0x36), 
                        Offset (0x38), 
                        HB0S,   7, 
                        HB0A,   1, 
                        HB1S,   7, 
                        HB1A,   1, 
                        HCMU,   1, 
                            ,   2, 
                        OVRQ,   1, 
                        DCBD,   1, 
                        DCWL,   1, 
                        DCWW,   1, 
                        HB1I,   1, 
                            ,   1, 
                        KBLT,   1, 
                        BTPW,   1, 
                        BTDT,   1, 
                        HUBS,   1, 
                        BDPW,   1, 
                        BDDT,   1, 
                        HUBB,   1, 
                        Offset (0x46), 
                            ,   1, 
                        BTWK,   1, 
                        HPLD,   1, 
                            ,   1, 
                        HPAC,   1, 
                        BTST,   1, 
                        Offset (0x47), 
                        HPBU,   1, 
                            ,   1, 
                        HBID,   4, 
                            ,   1, 
                        HPNF,   1, 
                            ,   1, 
                        GSTS,   1, 
                            ,   2, 
                        HLBU,   1, 
                        BDST,   1, 
                        HCBL,   1, 
                        Offset (0x49), 
                            ,   1, 
                        PSTA,   1, 
                        Offset (0x4E), 
                        HWAK,   16, 
                        HMPR,   8, 
                        HMST,   5, 
                            ,   2, 
                        HMDN,   1, 
                        HMAD,   8, 
                        HMCM,   8, 
                        Offset (0x74), 
                        HMBC,   8, 
                        Offset (0x78), 
                        TMP0,   8, 
                        TMP1,   8, 
                        TMP2,   8, 
                        TMP3,   8, 
                        TMP4,   8, 
                        TMP5,   8, 
                        TMP6,   8, 
                        TMP7,   8, 
                        Offset (0x81), 
                        HIID,   8, 
                        Offset (0x83), 
                        HFNI,   8, 
                        Offset (0x88), 
                        HDEC,   8, 
                        HDEO,   8, 
                        Offset (0x8D), 
                        HDAA,   3, 
                        HDAB,   3, 
                        HDAC,   2, 
                        Offset (0xB0), 
                        HDEN,   32, 
                        HDEP,   32, 
                        HDEM,   8, 
                        HDES,   8, 
                        Offset (0xC8), 
                        ATMX,   8, 
                        HWAT,   8, 
                        Offset (0xCE), 
                        HBCS,   2, 
                            ,   2, 
                        Offset (0xED), 
                            ,   4, 
                        HDDD,   1
                    }

                    Method (_INI, 0, NotSerialized)  // _INI: Initialize
                    {
                        If (\H8DR)
                        {
                            HSPA = 0x00
                        }
                        Else
                        {
                            \MBEC (0x05, 0xFE, 0x00)
                        }

                        BINI ()
                        \_SB.PCI0.LPC.EC.HKEY.WGIN ()
                    }

                    Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
                    {
                        IO (Decode16,
                            0x0062,             // Range Minimum
                            0x0062,             // Range Maximum
                            0x01,               // Alignment
                            0x01,               // Length
                            )
                        IO (Decode16,
                            0x0066,             // Range Minimum
                            0x0066,             // Range Maximum
                            0x01,               // Alignment
                            0x01,               // Length
                            )
                    })
                    Method (LED, 2, NotSerialized)
                    {
                        Local0 = (Arg0 | Arg1)
                        If (\H8DR)
                        {
                            HLCL = Local0
                        }
                        Else
                        {
                            \WBEC (0x0C, Local0)
                        }
                    }

                    Name (BAON, 0x00)
                    Name (WBON, 0x00)
                    Method (BEEP, 1, NotSerialized)
                    {
                        If ((Arg0 == 0x05))
                        {
                            WBON = 0x00
                        }

                        Local2 = WBON /* \_SB_.PCI0.LPC_.EC__.WBON */
                        If (BAON)
                        {
                            If ((Arg0 == 0x00))
                            {
                                BAON = 0x00
                                If (WBON)
                                {
                                    Local0 = 0x03
                                    Local1 = 0x08
                                }
                                Else
                                {
                                    Local0 = 0x00
                                    Local1 = 0x00
                                }
                            }
                            Else
                            {
                                Local0 = 0xFF
                                Local1 = 0xFF
                                If ((Arg0 == 0x11))
                                {
                                    WBON = 0x00
                                }

                                If ((Arg0 == 0x10))
                                {
                                    WBON = 0x01
                                }
                            }
                        }
                        Else
                        {
                            Local0 = Arg0
                            Local1 = 0xFF
                            If ((Arg0 == 0x0F))
                            {
                                Local0 = Arg0
                                Local1 = 0x08
                                BAON = 0x01
                            }

                            If ((Arg0 == 0x11))
                            {
                                Local0 = 0x00
                                Local1 = 0x00
                                WBON = 0x00
                            }

                            If ((Arg0 == 0x10))
                            {
                                Local0 = 0x03
                                Local1 = 0x08
                                WBON = 0x01
                            }
                        }

                        If ((Arg0 == 0x03))
                        {
                            WBON = 0x00
                            If (Local2)
                            {
                                Local0 = 0x07
                                If (((\SPS == 0x03) || (\SPS == 0x04)))
                                {
                                    Local2 = 0x00
                                    Local0 = 0xFF
                                    Local1 = 0xFF
                                }
                            }
                        }

                        If ((Arg0 == 0x07))
                        {
                            If (Local2)
                            {
                                Local2 = 0x00
                                Local0 = 0xFF
                                Local1 = 0xFF
                            }
                        }

                        If ((\H8DR && !\W98F))
                        {
                            If ((Local2 && !WBON))
                            {
                                HSRP = 0x00
                                HSUN = 0x00
                                Sleep (0x64)
                            }

                            If ((Local1 != 0xFF))
                            {
                                HSRP = Local1
                            }

                            If ((Local0 != 0xFF))
                            {
                                HSUN = Local0
                            }
                        }
                        Else
                        {
                            If ((Local2 && !WBON))
                            {
                                \WBEC (0x07, 0x00)
                                \WBEC (0x06, 0x00)
                                Sleep (0x64)
                            }

                            If ((Local1 != 0xFF))
                            {
                                \WBEC (0x07, Local1)
                            }

                            If ((Local0 != 0xFF))
                            {
                                \WBEC (0x06, Local0)
                            }
                        }

                        If ((Arg0 == 0x03)) {}
                        If ((Arg0 == 0x07))
                        {
                            Sleep (0x01F4)
                        }
                    }

                    Method (EVNT, 1, NotSerialized)
                    {
                        If (\H8DR)
                        {
                            If (Arg0)
                            {
                                HAM7 |= 0x01
                                HAM5 |= 0x04
                            }
                            Else
                            {
                                HAM7 &= 0xFE
                                HAM5 &= 0xFB
                            }
                        }
                        Else
                        {
                            If (Arg0)
                            {
                                \MBEC (0x17, 0xFF, 0x01)
                                \MBEC (0x15, 0xFF, 0x04)
                                If (\W98F)
                                {
                                    \WBEC (0x18, 0xFF)
                                }
                            }
                            Else
                            {
                                \MBEC (0x17, 0xFE, 0x00)
                                \MBEC (0x15, 0xFB, 0x00)
                                If (\W98F)
                                {
                                    \WBEC (0x18, 0x00)
                                }
                            }
                        }
                    }

                    Method (PNST, 1, NotSerialized)
                    {
                        If ((Arg0 && BSTA (0x02)))
                        {
                            If ((\H8DR && !\W98F))
                            {
                                HBPR = 0x01
                                HUBB = 0x01
                            }
                            Else
                            {
                                \MBEC (0x01, 0xFF, 0x20)
                                \MBEC (0x3B, 0xFF, 0x80)
                            }
                        }
                        Else
                        {
                            If ((\H8DR && !\W98F))
                            {
                                HBPR = 0x00
                                HUBB = 0x00
                            }
                            Else
                            {
                                \MBEC (0x01, 0xDF, 0x00)
                                \MBEC (0x3B, 0x7F, 0x00)
                            }
                        }
                    }

                    PowerResource (PUBS, 0x03, 0x0000)
                    {
                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If (\H8DR)
                            {
                                Local0 = HUBS /* \_SB_.PCI0.LPC_.EC__.HUBS */
                            }
                            Else
                            {
                                Local0 = (\RBEC (0x3B) & 0x10)
                            }

                            If (Local0)
                            {
                                Return (0x01)
                            }
                            Else
                            {
                                Return (0x00)
                            }
                        }

                        Method (_ON, 0, NotSerialized)  // _ON_: Power On
                        {
                            If (\H8DR)
                            {
                                HUBS = 0x01
                            }
                            Else
                            {
                                \MBEC (0x3B, 0xFF, 0x10)
                            }
                        }

                        Method (_OFF, 0, NotSerialized)  // _OFF: Power Off
                        {
                            If (\H8DR)
                            {
                                HUBS = 0x00
                            }
                            Else
                            {
                                \MBEC (0x3B, 0xEF, 0x00)
                            }
                        }
                    }

                    Method (LPMD, 0, NotSerialized)
                    {
                        Local0 = 0x00
                        Local1 = 0x00
                        Local2 = 0x00
                        If (\H8DR)
                        {
                            If (HPAC)
                            {
                                If (HPLO)
                                {
                                    Local0 = \LPST
                                }
                                Else
                                {
                                    If ((HWAT < 0x5A))
                                    {
                                        If (HB0A)
                                        {
                                            If (((HB0S & 0x10) || ((HB0S & 0x0F) < 0x02)))
                                            {
                                                Local1 = 0x01
                                            }
                                        }
                                        Else
                                        {
                                            Local1 = 0x01
                                        }

                                        If (HB1A)
                                        {
                                            If (((HB1S & 0x10) || ((HB1S & 0x0F) < 0x02)))
                                            {
                                                Local2 = 0x01
                                            }
                                        }
                                        Else
                                        {
                                            Local2 = 0x01
                                        }

                                        If ((Local1 && Local2))
                                        {
                                            Local0 = \LPST
                                        }
                                    }
                                }
                            }
                        }
                        Else
                        {
                            If ((\RBEC (0x46) & 0x10))
                            {
                                If ((\RBEC (0x34) & 0x80))
                                {
                                    Local0 = \LPST
                                }
                                Else
                                {
                                    If ((\RBEC (0xC9) < 0x5A))
                                    {
                                        Local3 = \RBEC (0x38)
                                        If ((Local3 & 0x80))
                                        {
                                            If (((Local3 & 0x10) || ((Local3 & 0x0F) < 0x02)))
                                            {
                                                Local1 = 0x01
                                            }
                                        }
                                        Else
                                        {
                                            Local2 = 0x01
                                        }

                                        Local3 = \RBEC (0x39)
                                        If ((Local3 & 0x80))
                                        {
                                            If (((Local3 & 0x10) || ((Local3 & 0x0F) < 0x02)))
                                            {
                                                Local1 = 0x01
                                            }
                                        }
                                        Else
                                        {
                                            Local2 = 0x01
                                        }

                                        If ((Local1 && Local2))
                                        {
                                            Local0 = \LPST
                                        }
                                    }
                                }
                            }
                        }

                        Return (Local0)
                    }

                    Method (CLPM, 0, NotSerialized)
                    {
                        If (\SPEN)
                        {
                            If (\OSPX)
                            {
                                Notify (\_PR.CPU0, 0x80) // Performance Capability Change
                                If (\MPEN)
                                {
                                    Notify (\_PR.CPU1, 0x80) // Performance Capability Change
                                }
                            }
                            Else
                            {
                                Local0 = LPMD ()
                                If (Local0)
                                {
                                    \STEP (0x04)
                                }
                                Else
                                {
                                    \STEP (0x05)
                                }
                            }
                        }
                    }

                    Mutex (MCPU, 0x07)
                    Method (_Q10, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x01))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1001)
                        }
                    }

                    Method (_Q11, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x02))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1002)
                        }
                        Else
                        {
                            Noop
                        }
                    }

                    Method (_Q12, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1003)
                    }

                    Method (_Q13, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.DHKC)
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1004)
                        }
                        Else
                        {
                            Notify (\_SB.SLPB, 0x80) // Status Change
                        }
                    }

                    Method (_Q64, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x10))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1005)
                        }
                    }

                    Method (_Q65, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x20))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1006)
                        }
                    }

                    Method (_Q16, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\VPDF)
                        {
                            \VPDF = 0x00
                            If (VIGD)
                            {
                                \_SB.PCI0.VID.VSPD ()
                            }
                        }
                        Else
                        {
                            If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x40))
                            {
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1007)
                            }
                            Else
                            {
                                If (VIGD)
                                {
                                    \_SB.PCI0.VID.VSWT ()
                                }
                                Else
                                {
                                    \_SB.PCI0.AGP.VID.VSWT ()
                                }
                            }
                        }
                    }

                    Method (_Q17, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x80))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1008)
                        }
                        Else
                        {
                            If (!\WNTF)
                            {
                                VEXP ()
                            }
                        }
                    }

                    Method (_Q18, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x0100))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1009)
                        }

                        Noop
                    }

                    Method (_Q66, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x0200))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x100A)
                        }
                    }

                    Method (_Q1A, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x0400))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x100B)
                        }
                    }

                    Method (_Q1B, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x100C)
                    }

                    Method (_Q62, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x1000))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x100D)
                        }
                    }

                    Method (_Q60, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x2000))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x100E)
                        }
                    }

                    Method (_Q61, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x4000))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x100F)
                        }
                    }

                    Method (_Q1F, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x00020000))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1012)
                        }

                        \UCMS (0x0E)
                    }

                    Method (_Q67, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x00040000))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1013)
                        }
                    }

                    Method (_Q26, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (VIGD)
                        {
                            If (\WVIS)
                            {
                                \VBTD ()
                            }

                            \_SB.PCI0.LPC.EC.BRNS ()
                        }
                        Else
                        {
                            \UCMS (0x12)
                        }

                        Sleep (0x01F4)
                        Notify (AC, 0x80) // Status Change
                        Notify (\_TZ.THM0, 0x80) // Thermal Status Change
                        Notify (\_TZ.THM1, 0x80) // Thermal Status Change
                        If (\WXPF)
                        {
                            Acquire (MCPU, 0xFFFF)
                        }

                        If (!\_SB.PCI0.LPC.EC.HKEY.DHC4)
                        {
                            \C4AC = 0x00
                        }

                        If (\SPEN)
                        {
                            If (\OSPX)
                            {
                                Notify (\_PR.CPU0, 0x80) // Performance Capability Change
                                If (\MPEN)
                                {
                                    Notify (\_PR.CPU1, 0x80) // Performance Capability Change
                                }
                            }
                            Else
                            {
                                \STEP (0x00)
                            }
                        }

                        If (\WXPF)
                        {
                            Sleep (0x64)
                        }

                        If (\OSC4)
                        {
                            Notify (\_PR.CPU0, 0x81) // C-State Change
                            If (\MPEN)
                            {
                                Notify (\_PR.CPU1, 0x81) // C-State Change
                            }
                        }

                        If (\WXPF)
                        {
                            Release (MCPU)
                        }

                        If ((!\WXPF && \WNTF))
                        {
                            If (!\C4AC)
                            {
                                \_SB.PCI0.LPC.C4C3 = 0x00
                            }
                        }

                        ATMC ()
                    }

                    Method (_Q27, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (VIGD)
                        {
                            If (\WVIS)
                            {
                                \VBTD ()
                            }

                            \_SB.PCI0.LPC.EC.BRNS ()
                            \_SB.PCI0.VID.VDSP ()
                        }
                        Else
                        {
                            \UCMS (0x12)
                        }

                        Sleep (0x01F4)
                        Notify (AC, 0x80) // Status Change
                        Notify (\_TZ.THM0, 0x80) // Thermal Status Change
                        Notify (\_TZ.THM1, 0x80) // Thermal Status Change
                        If (\WXPF)
                        {
                            Acquire (MCPU, 0xFFFF)
                        }

                        If (!\_SB.PCI0.LPC.EC.HKEY.DHC4)
                        {
                            \C4AC = 0x01
                        }

                        If (\SPEN)
                        {
                            If (\OSPX)
                            {
                                Notify (\_PR.CPU0, 0x80) // Performance Capability Change
                                If (\MPEN)
                                {
                                    Notify (\_PR.CPU1, 0x80) // Performance Capability Change
                                }
                            }
                            Else
                            {
                                \STEP (0x01)
                            }
                        }

                        If (\WXPF)
                        {
                            Sleep (0x64)
                        }

                        If (\OSC4)
                        {
                            Notify (\_PR.CPU0, 0x81) // C-State Change
                            If (\MPEN)
                            {
                                Notify (\_PR.CPU1, 0x81) // C-State Change
                            }
                        }

                        If (\WXPF)
                        {
                            Release (MCPU)
                        }

                        If ((!\WXPF && \WNTF))
                        {
                            If (!\_SB.PCI0.LPC.EC.HKEY.CKC4 (0x00))
                            {
                                \_SB.PCI0.LPC.C4C3 = 0x01
                            }
                        }

                        ATMC ()
                        If (((\_SB.GDCK.GDID () == 0x4C004D24) || (\_SB.GDCK.GDID () == 0x44004D24)))
                        {
                            Notify (\_SB.GDCK, 0x01) // Device Check
                        }
                    }

                    Method (_Q2A, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (VIGD)
                        {
                            \_SB.PCI0.VID.GLIS (0x01)
                        }

                        If (VIGD)
                        {
                            \_SB.PCI0.VID.VLOC (0x01)
                        }
                        Else
                        {
                            \_SB.PCI0.AGP.VID.VLOC (0x01)
                        }

                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x5002)
                        Notify (\_SB.LID, 0x80) // Status Change
                    }

                    Method (_Q2B, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (VIGD)
                        {
                            \_SB.PCI0.VID.GLIS (0x00)
                        }

                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x5001)
                        \UCMS (0x0D)
                        Notify (\_SB.LID, 0x80) // Status Change
                    }

                    Method (_Q5E, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\H8DR)
                        {
                            If (HPLD)
                            {
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x5009)
                                HAM5 &= 0xF3
                                HDIM = 0x00
                            }
                        }
                    }

                    Method (_Q5F, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\H8DR)
                        {
                            If (HPLD)
                            {
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x500A)
                                HAM5 |= 0x0C
                                HDIM = 0x01
                            }
                        }
                    }

                    Method (_Q3D, 0, NotSerialized)  // _Qxx: EC Query
                    {
                    }

                    Method (_Q48, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\SPEN)
                        {
                            If (\OSPX)
                            {
                                Notify (\_PR.CPU0, 0x80) // Performance Capability Change
                                If (\MPEN)
                                {
                                    Notify (\_PR.CPU1, 0x80) // Performance Capability Change
                                }
                            }
                            Else
                            {
                                \STEP (0x04)
                            }
                        }
                    }

                    Method (_Q49, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\SPEN)
                        {
                            If (\OSPX)
                            {
                                Notify (\_PR.CPU0, 0x80) // Performance Capability Change
                                If (\MPEN)
                                {
                                    Notify (\_PR.CPU1, 0x80) // Performance Capability Change
                                }
                            }
                            Else
                            {
                                \STEP (0x05)
                            }
                        }
                    }

                    Method (_Q7F, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        Fatal (0x01, 0x80010000, 0x03CE)
                    }

                    Method (_Q4E, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x6011)
                    }

                    Method (_Q4F, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x6012)
                    }

                    Method (_Q75, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        \_SB.PCI0.LPC.EC.TATR ()
                    }

                    Method (_Q46, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x6012)
                    }

                    Method (_Q22, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        CLPM ()
                        If (HB0A)
                        {
                            Notify (BAT0, 0x80) // Status Change
                        }

                        If ((^BAT1.B1ST && ^BAT1.XB1S))
                        {
                            Notify (BAT1, 0x80) // Status Change
                        }

                        If ((^BAT2.B2ST && ^BAT2.XB2S))
                        {
                            Notify (BAT2, 0x80) // Status Change
                        }
                    }

                    Method (_Q4A, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        CLPM ()
                        Notify (BAT0, 0x81) // Information Change
                    }

                    Method (_Q4B, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        Notify (BAT0, 0x80) // Status Change
                    }

                    Method (_Q4C, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        CLPM ()
                        If (((BDEV == 0x10) || (HBCS == 0x02)))
                        {
                            _Q38 ()
                            HB1I = 0x00
                        }
                        Else
                        {
                            If (^BAT2.XB2S)
                            {
                                Notify (BAT2, 0x81) // Information Change
                            }
                            Else
                            {
                                If (HB1A)
                                {
                                    ^BAT2.XB2S = 0x01
                                    Notify (BAT2, 0x01) // Device Check
                                }
                            }
                        }
                    }

                    Method (_Q4D, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If ((^BAT1.B1ST && ^BAT1.XB1S))
                        {
                            Notify (BAT1, 0x80) // Status Change
                        }

                        If ((^BAT2.B2ST && ^BAT2.XB2S))
                        {
                            Notify (BAT2, 0x80) // Status Change
                        }
                    }

                    Method (_Q24, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        CLPM ()
                        Notify (BAT0, 0x80) // Status Change
                    }

                    Method (_Q25, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If ((^BAT1.B1ST && ^BAT1.XB1S))
                        {
                            CLPM ()
                            Notify (BAT1, 0x80) // Status Change
                        }

                        If ((^BAT2.B2ST && ^BAT2.XB2S))
                        {
                            Notify (BAT2, 0x80) // Status Change
                        }
                    }

                    Field (ECOR, ByteAcc, NoLock, Preserve)
                    {
                        Offset (0xA0), 
                        SBRC,   16, 
                        SBFC,   16, 
                        SBAE,   16, 
                        SBRS,   16, 
                        SBAC,   16, 
                        SBVO,   16, 
                        SBAF,   16, 
                        SBBS,   16
                    }

                    Field (ECOR, ByteAcc, NoLock, Preserve)
                    {
                        Offset (0xA0), 
                            ,   15, 
                        SBCM,   1, 
                        SBMD,   16, 
                        SBCC,   16
                    }

                    Field (ECOR, ByteAcc, NoLock, Preserve)
                    {
                        Offset (0xA0), 
                        SBDC,   16, 
                        SBDV,   16, 
                        SBOM,   16, 
                        SBSI,   16, 
                        SBDT,   16, 
                        SBSN,   16
                    }

                    Field (ECOR, ByteAcc, NoLock, Preserve)
                    {
                        Offset (0xA0), 
                        SBCH,   32
                    }

                    Field (ECOR, ByteAcc, NoLock, Preserve)
                    {
                        Offset (0xA0), 
                        SBMN,   128
                    }

                    Field (ECOR, ByteAcc, NoLock, Preserve)
                    {
                        Offset (0xA0), 
                        SBDN,   128
                    }

                    Mutex (BATM, 0x07)
                    Method (GBIF, 3, NotSerialized)
                    {
                        Acquire (BATM, 0xFFFF)
                        If (Arg2)
                        {
                            HIID = (Arg0 | 0x01)
                            Local7 = SBCM /* \_SB_.PCI0.LPC_.EC__.SBCM */
                            Index (Arg1, 0x00) = (Local7 ^ 0x01)
                            HIID = Arg0
                            If (Local7)
                            {
                                Local1 = (SBFC * 0x0A)
                            }
                            Else
                            {
                                Local1 = SBFC /* \_SB_.PCI0.LPC_.EC__.SBFC */
                            }

                            Index (Arg1, 0x02) = Local1
                            HIID = (Arg0 | 0x02)
                            If (Local7)
                            {
                                Local0 = (SBDC * 0x0A)
                            }
                            Else
                            {
                                Local0 = SBDC /* \_SB_.PCI0.LPC_.EC__.SBDC */
                            }

                            Index (Arg1, 0x01) = Local0
                            Divide (Local1, 0x14, Local2, Index (Arg1, 0x05))
                            If (Local7)
                            {
                                Index (Arg1, 0x06) = 0xC8
                            }
                            Else
                            {
                                If (SBDV)
                                {
                                    Divide (0x00030D40, SBDV, Local2, Index (Arg1, 0x06))
                                }
                                Else
                                {
                                    Index (Arg1, 0x06) = 0x00
                                }
                            }

                            Index (Arg1, 0x04) = SBDV /* \_SB_.PCI0.LPC_.EC__.SBDV */
                            Local0 = SBSN /* \_SB_.PCI0.LPC_.EC__.SBSN */
                            Name (SERN, Buffer (0x06)
                            {
                                "     "
                            })
                            Local2 = 0x04
                            While (Local0)
                            {
                                Divide (Local0, 0x0A, Local1, Local0)
                                Index (SERN, Local2) = (Local1 + 0x30)
                                Local2--
                            }

                            Index (Arg1, 0x0A) = SERN /* \_SB_.PCI0.LPC_.EC__.GBIF.SERN */
                            HIID = (Arg0 | 0x06)
                            Index (Arg1, 0x09) = SBDN /* \_SB_.PCI0.LPC_.EC__.SBDN */
                            HIID = (Arg0 | 0x04)
                            Name (BTYP, Buffer (0x05)
                            {
                                 0x00, 0x00, 0x00, 0x00, 0x00                     /* ..... */
                            })
                            BTYP = SBCH /* \_SB_.PCI0.LPC_.EC__.SBCH */
                            Index (Arg1, 0x0B) = BTYP /* \_SB_.PCI0.LPC_.EC__.GBIF.BTYP */
                            HIID = (Arg0 | 0x05)
                            Index (Arg1, 0x0C) = SBMN /* \_SB_.PCI0.LPC_.EC__.SBMN */
                        }
                        Else
                        {
                            Index (Arg1, 0x01) = 0xFFFFFFFF
                            Index (Arg1, 0x05) = 0x00
                            Index (Arg1, 0x06) = 0x00
                            Index (Arg1, 0x02) = 0xFFFFFFFF
                        }

                        Release (BATM)
                        Return (Arg1)
                    }

                    Method (GBST, 4, NotSerialized)
                    {
                        Acquire (BATM, 0xFFFF)
                        If ((Arg1 & 0x20))
                        {
                            Local0 = 0x02
                        }
                        Else
                        {
                            If ((Arg1 & 0x40))
                            {
                                Local0 = 0x01
                            }
                            Else
                            {
                                Local0 = 0x00
                            }
                        }

                        If ((Arg1 & 0x0F)) {}
                        Else
                        {
                            Local0 |= 0x04
                        }

                        If (((Arg1 & 0x0F) == 0x0F))
                        {
                            Local0 = 0x04
                            Local1 = 0x00
                            Local2 = 0x00
                            Local3 = 0x00
                        }
                        Else
                        {
                            HIID = Arg0
                            Local3 = SBVO /* \_SB_.PCI0.LPC_.EC__.SBVO */
                            If (Arg2)
                            {
                                Local2 = (SBRC * 0x0A)
                            }
                            Else
                            {
                                Local2 = SBRC /* \_SB_.PCI0.LPC_.EC__.SBRC */
                            }

                            Local1 = SBAC /* \_SB_.PCI0.LPC_.EC__.SBAC */
                            If ((Local1 >= 0x8000))
                            {
                                If ((Local0 & 0x01))
                                {
                                    Local1 -= 0x00010000
                                }
                                Else
                                {
                                    Local1 = 0x00
                                }
                            }
                            Else
                            {
                                If (!(Local0 & 0x02))
                                {
                                    Local1 = 0x00
                                }
                            }

                            If (Arg2)
                            {
                                Local1 *= Local3
                                Divide (Local1, 0x03E8, Local7, Local1)
                            }
                        }

                        Index (Arg3, 0x00) = Local0
                        Index (Arg3, 0x01) = Local1
                        Index (Arg3, 0x02) = Local2
                        Index (Arg3, 0x03) = Local3
                        Release (BATM)
                        Return (Arg3)
                    }

                    Device (BAT0)
                    {
                        Name (_HID, EisaId ("PNP0C0A") /* Control Method Battery */)  // _HID: Hardware ID
                        Name (_UID, 0x00)  // _UID: Unique ID
                        Name (_PCL, Package (0x01)  // _PCL: Power Consumer List
                        {
                            \_SB
                        })
                        Name (B0ST, 0x00)
                        Name (BT0I, Package (0x0D)
                        {
                            0x00, 
                            0xFFFFFFFF, 
                            0xFFFFFFFF, 
                            0x01, 
                            0x2A30, 
                            0x00, 
                            0x00, 
                            0x01, 
                            0x01, 
                            "", 
                            "", 
                            "", 
                            ""
                        })
                        Name (BT0P, Package (0x04) {})
                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If (\H8DR)
                            {
                                B0ST = HB0A /* \_SB_.PCI0.LPC_.EC__.HB0A */
                            }
                            Else
                            {
                                If ((\RBEC (0x38) & 0x80))
                                {
                                    B0ST = 0x01
                                }
                                Else
                                {
                                    B0ST = 0x00
                                }
                            }

                            If (B0ST)
                            {
                                Return (0x1F)
                            }
                            Else
                            {
                                Return (0x0F)
                            }
                        }

                        Method (_BIF, 0, NotSerialized)  // _BIF: Battery Information
                        {
                            Local7 = 0x00
                            Local6 = 0x0A
                            While ((!Local7 && Local6))
                            {
                                If (HB0A)
                                {
                                    If (((HB0S & 0x0F) == 0x0F))
                                    {
                                        Sleep (0x03E8)
                                        Local6--
                                    }
                                    Else
                                    {
                                        Local7 = 0x01
                                    }
                                }
                                Else
                                {
                                    Local6 = 0x00
                                }
                            }

                            Return (GBIF (0x00, BT0I, Local7))
                        }

                        Method (_BST, 0, NotSerialized)  // _BST: Battery Status
                        {
                            Local0 = (DerefOf (Index (BT0I, 0x00)) ^ 0x01)
                            Return (GBST (0x00, HB0S, Local0, BT0P))
                        }

                        Method (_BTP, 1, NotSerialized)  // _BTP: Battery Trip Point
                        {
                            HAM4 &= 0xEF
                            If (Arg0)
                            {
                                Local1 = Arg0
                                If (!DerefOf (Index (BT0I, 0x00)))
                                {
                                    Divide (Local1, 0x0A, Local0, Local1)
                                }

                                HT0L = (Local1 & 0xFF)
                                HT0H = ((Local1 >> 0x08) & 0xFF)
                                HAM4 |= 0x10
                            }
                        }
                    }

                    Device (BAT1)
                    {
                        Name (_HID, EisaId ("PNP0C0A") /* Control Method Battery */)  // _HID: Hardware ID
                        Name (_UID, 0x02)  // _UID: Unique ID
                        Name (_PCL, Package (0x01)  // _PCL: Power Consumer List
                        {
                            \_SB
                        })
                        Name (B1ST, 0x00)
                        Name (XB1S, 0x01)
                        Name (BT1I, Package (0x0D)
                        {
                            0x00, 
                            0xFFFFFFFF, 
                            0xFFFFFFFF, 
                            0x01, 
                            0x2A30, 
                            0x00, 
                            0x00, 
                            0x01, 
                            0x01, 
                            "", 
                            "", 
                            "", 
                            ""
                        })
                        Name (BT1P, Package (0x04)
                        {
                            0x00, 
                            0x00, 
                            0x00, 
                            0x00
                        })
                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If (\H8DR)
                            {
                                If ((\WNTF && (HBCS & 0x02)))
                                {
                                    B1ST = HB1A /* \_SB_.PCI0.LPC_.EC__.HB1A */
                                }
                            }
                            Else
                            {
                                If ((\WNTF && (\RBEC (0xCE) & 0x02)))
                                {
                                    If ((\RBEC (0x39) & 0x80))
                                    {
                                        B1ST = 0x01
                                    }
                                    Else
                                    {
                                        B1ST = 0x00
                                    }
                                }
                            }

                            If (B1ST)
                            {
                                If (XB1S)
                                {
                                    Return (0x1F)
                                }
                                Else
                                {
                                    If (\WNTF)
                                    {
                                        Return (0x00)
                                    }
                                    Else
                                    {
                                        Return (0x1F)
                                    }
                                }
                            }
                            Else
                            {
                                If (\WNTF)
                                {
                                    Return (0x00)
                                }
                                Else
                                {
                                    Return (0x0F)
                                }
                            }
                        }

                        Method (_BIF, 0, NotSerialized)  // _BIF: Battery Information
                        {
                            If (!B1ST)
                            {
                                Return (BT1I) /* \_SB_.PCI0.LPC_.EC__.BAT1.BT1I */
                            }

                            Local7 = 0x00
                            Local6 = 0x0A
                            While ((!Local7 && Local6))
                            {
                                If (HB1A)
                                {
                                    If (((HB1S & 0x0F) == 0x0F))
                                    {
                                        Sleep (0x03E8)
                                        Local6--
                                    }
                                    Else
                                    {
                                        Local7 = 0x01
                                    }
                                }
                                Else
                                {
                                    Local6 = 0x00
                                }
                            }

                            Return (GBIF (0x10, BT1I, Local7))
                        }

                        Method (_BST, 0, NotSerialized)  // _BST: Battery Status
                        {
                            If (!B1ST)
                            {
                                Return (BT1P) /* \_SB_.PCI0.LPC_.EC__.BAT1.BT1P */
                            }

                            Local0 = (DerefOf (Index (BT1I, 0x00)) ^ 0x01)
                            Return (GBST (0x10, HB1S, Local0, BT1P))
                        }

                        Method (_BTP, 1, NotSerialized)  // _BTP: Battery Trip Point
                        {
                            If (B1ST)
                            {
                                HAM4 &= 0xDF
                                If (Arg0)
                                {
                                    Local1 = Arg0
                                    If (!DerefOf (Index (BT1I, 0x00)))
                                    {
                                        Divide (Local1, 0x0A, Local0, Local1)
                                    }

                                    HT1L = (Local1 & 0xFF)
                                    HT1H = ((Local1 >> 0x08) & 0xFF)
                                    HAM4 |= 0x20
                                }
                            }
                        }
                    }

                    Device (BAT2)
                    {
                        Name (_HID, EisaId ("PNP0C0A") /* Control Method Battery */)  // _HID: Hardware ID
                        Name (_UID, 0x01)  // _UID: Unique ID
                        Name (_PCL, Package (0x01)  // _PCL: Power Consumer List
                        {
                            \_SB
                        })
                        Name (B2ST, 0x00)
                        Name (XB2S, 0x01)
                        Name (IFLG, 0x00)
                        Name (BT2I, Package (0x0D)
                        {
                            0x00, 
                            0xFFFFFFFF, 
                            0xFFFFFFFF, 
                            0x01, 
                            0x2A30, 
                            0x00, 
                            0x00, 
                            0x01, 
                            0x01, 
                            "", 
                            "", 
                            "", 
                            ""
                        })
                        Name (BT2P, Package (0x04)
                        {
                            0x00, 
                            0x00, 
                            0x00, 
                            0x00
                        })
                        Method (_INI, 0, NotSerialized)  // _INI: Initialize
                        {
                            If ((\_SB.PCI0.LPC.EC.GSID () == 0x03))
                            {
                                XB2S = 0x00
                            }
                            Else
                            {
                                If (\WNTF)
                                {
                                    If (\H8DR)
                                    {
                                        Local0 = HB1A /* \_SB_.PCI0.LPC_.EC__.HB1A */
                                    }
                                    Else
                                    {
                                        Local0 = (\RBEC (0x39) & 0x80)
                                    }

                                    If (!Local0)
                                    {
                                        XB2S = 0x00
                                    }
                                }
                            }

                            IFLG = 0x01
                        }

                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If (!IFLG)
                            {
                                _INI ()
                            }

                            If (\H8DR)
                            {
                                If ((\WNTF && (HBCS & 0x02)))
                                {
                                    B2ST = 0x00
                                }
                                Else
                                {
                                    B2ST = HB1A /* \_SB_.PCI0.LPC_.EC__.HB1A */
                                }
                            }
                            Else
                            {
                                If ((\WNTF && (\RBEC (0xCE) & 0x02)))
                                {
                                    B2ST = 0x00
                                }
                                Else
                                {
                                    If ((\RBEC (0xCE) & 0x01))
                                    {
                                        B2ST = 0x01
                                    }
                                    Else
                                    {
                                        B2ST = 0x00
                                    }
                                }
                            }

                            If (B2ST)
                            {
                                If (XB2S)
                                {
                                    Return (0x1F)
                                }
                                Else
                                {
                                    Return (0x00)
                                }
                            }
                            Else
                            {
                                If (XB2S)
                                {
                                    Return (0x0F)
                                }
                                Else
                                {
                                    Return (0x00)
                                }
                            }
                        }

                        Method (_BIF, 0, NotSerialized)  // _BIF: Battery Information
                        {
                            If (!B2ST)
                            {
                                Return (BT2I) /* \_SB_.PCI0.LPC_.EC__.BAT2.BT2I */
                            }

                            Local7 = 0x00
                            Local6 = 0x0A
                            While ((!Local7 && Local6))
                            {
                                If (HB1A)
                                {
                                    If (((HB1S & 0x0F) == 0x0F))
                                    {
                                        Sleep (0x03E8)
                                        Local6--
                                    }
                                    Else
                                    {
                                        Local7 = 0x01
                                    }
                                }
                                Else
                                {
                                    Local6 = 0x00
                                }
                            }

                            Return (GBIF (0x10, BT2I, Local7))
                        }

                        Method (_BST, 0, NotSerialized)  // _BST: Battery Status
                        {
                            If (!B2ST)
                            {
                                Return (BT2P) /* \_SB_.PCI0.LPC_.EC__.BAT2.BT2P */
                            }

                            Local0 = (DerefOf (Index (BT2I, 0x00)) ^ 0x01)
                            Return (GBST (0x10, HB1S, Local0, BT2P))
                        }

                        Method (_BTP, 1, NotSerialized)  // _BTP: Battery Trip Point
                        {
                            If (B2ST)
                            {
                                HAM4 &= 0xDF
                                If (Arg0)
                                {
                                    Local1 = Arg0
                                    If (!DerefOf (Index (BT2I, 0x00)))
                                    {
                                        Divide (Local1, 0x0A, Local0, Local1)
                                    }

                                    HT1L = (Local1 & 0xFF)
                                    HT1H = ((Local1 >> 0x08) & 0xFF)
                                    HAM4 |= 0x20
                                }
                            }
                        }
                    }

                    Device (AC)
                    {
                        Name (_HID, "ACPI0003" /* Power Source Device */)  // _HID: Hardware ID
                        Name (_UID, 0x00)  // _UID: Unique ID
                        Name (_PCL, Package (0x01)  // _PCL: Power Consumer List
                        {
                            \_SB
                        })
                        Method (_PSR, 0, NotSerialized)  // _PSR: Power Source
                        {
                            Return (HPAC) /* \_SB_.PCI0.LPC_.EC__.HPAC */
                        }

                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            Return (0x0F)
                        }
                    }

                    Device (HKEY)
                    {
                        Name (_HID, EisaId ("IBM0068"))  // _HID: Hardware ID
                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            Return (0x0F)
                        }

                        Method (MHKV, 0, NotSerialized)
                        {
                            Return (0x0100)
                        }

                        Name (DHKC, 0x00)
                        Name (DHKB, 0x01)
                        Mutex (XDHK, 0x07)
                        Name (DHKH, 0x00)
                        Name (DHKW, 0x00)
                        Name (DHKS, 0x00)
                        Name (DHKD, 0x00)
                        Name (DHKN, 0x080C)
                        Name (DHKT, 0x00)
                        Name (DHWW, 0x00)
                        Name (DHC4, 0x00)
                        Method (MHKA, 0, NotSerialized)
                        {
                            Return (0x00FFFFFF)
                        }

                        Method (MHKN, 0, NotSerialized)
                        {
                            Return (DHKN) /* \_SB_.PCI0.LPC_.EC__.HKEY.DHKN */
                        }

                        Method (MHKK, 1, NotSerialized)
                        {
                            If (DHKC)
                            {
                                Return ((DHKN & Arg0))
                            }
                            Else
                            {
                                Return (Zero)
                            }
                        }

                        Method (MHKM, 2, NotSerialized)
                        {
                            Acquire (XDHK, 0xFFFF)
                            If ((Arg0 > 0x20))
                            {
                                Noop
                            }
                            Else
                            {
                                Local0 = (One << Arg0--)
                                If ((Local0 & 0x00FFFFFF))
                                {
                                    If (Arg1)
                                    {
                                        DHKN |= Local0 /* \_SB_.PCI0.LPC_.EC__.HKEY.DHKN */
                                    }
                                    Else
                                    {
                                        DHKN &= (Local0 ^ 0xFFFFFFFF)
                                    }
                                }
                                Else
                                {
                                    Noop
                                }
                            }

                            Release (XDHK)
                        }

                        Method (MHKS, 0, NotSerialized)
                        {
                            Notify (\_SB.SLPB, 0x80) // Status Change
                        }

                        Method (MHKC, 1, NotSerialized)
                        {
                            DHKC = Arg0
                        }

                        Method (MHKP, 0, NotSerialized)
                        {
                            Acquire (XDHK, 0xFFFF)
                            If (DHWW)
                            {
                                Local1 = DHWW /* \_SB_.PCI0.LPC_.EC__.HKEY.DHWW */
                                DHWW = Zero
                            }
                            Else
                            {
                                If (DHKW)
                                {
                                    Local1 = DHKW /* \_SB_.PCI0.LPC_.EC__.HKEY.DHKW */
                                    DHKW = Zero
                                }
                                Else
                                {
                                    If (DHKD)
                                    {
                                        Local1 = DHKD /* \_SB_.PCI0.LPC_.EC__.HKEY.DHKD */
                                        DHKD = Zero
                                    }
                                    Else
                                    {
                                        If (DHKS)
                                        {
                                            Local1 = DHKS /* \_SB_.PCI0.LPC_.EC__.HKEY.DHKS */
                                            DHKS = Zero
                                        }
                                        Else
                                        {
                                            If (DHKT)
                                            {
                                                Local1 = DHKT /* \_SB_.PCI0.LPC_.EC__.HKEY.DHKT */
                                                DHKT = Zero
                                            }
                                            Else
                                            {
                                                Local1 = DHKH /* \_SB_.PCI0.LPC_.EC__.HKEY.DHKH */
                                                DHKH = Zero
                                            }
                                        }
                                    }
                                }
                            }

                            Release (XDHK)
                            Return (Local1)
                        }

                        Method (MHKE, 1, NotSerialized)
                        {
                            DHKB = Arg0
                            Acquire (XDHK, 0xFFFF)
                            DHKH = Zero
                            DHKW = Zero
                            DHKS = Zero
                            DHKD = Zero
                            DHKT = Zero
                            DHWW = Zero
                            Release (XDHK)
                        }

                        Method (MHKQ, 1, NotSerialized)
                        {
                            If (DHKB)
                            {
                                If (DHKC)
                                {
                                    Acquire (XDHK, 0xFFFF)
                                    If ((Arg0 < 0x1000)) {}
                                    Else
                                    {
                                        If ((Arg0 < 0x2000))
                                        {
                                            DHKH = Arg0
                                        }
                                        Else
                                        {
                                            If ((Arg0 < 0x3000))
                                            {
                                                DHKW = Arg0
                                            }
                                            Else
                                            {
                                                If ((Arg0 < 0x4000))
                                                {
                                                    DHKS = Arg0
                                                }
                                                Else
                                                {
                                                    If ((Arg0 < 0x5000))
                                                    {
                                                        DHKD = Arg0
                                                    }
                                                    Else
                                                    {
                                                        If ((Arg0 < 0x6000))
                                                        {
                                                            DHKH = Arg0
                                                        }
                                                        Else
                                                        {
                                                            If ((Arg0 < 0x7000))
                                                            {
                                                                DHKT = Arg0
                                                            }
                                                            Else
                                                            {
                                                                If ((Arg0 < 0x8000))
                                                                {
                                                                    DHWW = Arg0
                                                                }
                                                                Else
                                                                {
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    Release (XDHK)
                                    Notify (HKEY, 0x80) // Status Change
                                }
                                Else
                                {
                                    If ((Arg0 == 0x1004))
                                    {
                                        Notify (\_SB.SLPB, 0x80) // Status Change
                                    }
                                }
                            }
                        }

                        Method (MHKG, 0, NotSerialized)
                        {
                            Local0 = Zero
                            Local0 = (\_SB.PCI0.LPC.EC.HTAB << 0x03)
                            Return (Local0)
                        }

                        Method (MHKB, 1, NotSerialized)
                        {
                            If ((Arg0 == 0x00))
                            {
                                \_SB.PCI0.LPC.EC.BEEP (0x11)
                                \LIDB = 0x00
                            }
                            Else
                            {
                                If ((Arg0 == 0x01))
                                {
                                    \_SB.PCI0.LPC.EC.BEEP (0x10)
                                    \LIDB = 0x01
                                }
                                Else
                                {
                                }
                            }
                        }

                        Method (MHKD, 0, NotSerialized)
                        {
                            If (VIGD)
                            {
                                \_SB.PCI0.VID.VLOC (0x00)
                            }
                            Else
                            {
                                \_SB.PCI0.AGP.VID.VLOC (0x00)
                            }
                        }

                        Method (MHQC, 1, NotSerialized)
                        {
                            If (\WNTF)
                            {
                                If ((Arg0 == 0x00))
                                {
                                    Return (\CWAC)
                                }
                                Else
                                {
                                    If ((Arg0 == 0x01))
                                    {
                                        Return (\CWAP)
                                    }
                                    Else
                                    {
                                        If ((Arg0 == 0x02))
                                        {
                                            Return (\CWAT)
                                        }
                                        Else
                                        {
                                            Noop
                                        }
                                    }
                                }
                            }
                            Else
                            {
                                Noop
                            }

                            Return (0x00)
                        }

                        Method (MHGC, 0, NotSerialized)
                        {
                            If (\WNTF)
                            {
                                Acquire (XDHK, 0xFFFF)
                                If (CKC4 (0x00))
                                {
                                    Local0 = 0x03
                                }
                                Else
                                {
                                    Local0 = 0x04
                                }

                                Release (XDHK)
                                Return (Local0)
                            }
                            Else
                            {
                                Noop
                            }

                            Return (0x00)
                        }

                        Method (MHSC, 1, NotSerialized)
                        {
                            If ((\CWAC && \WNTF))
                            {
                                Acquire (XDHK, 0xFFFF)
                                If (\OSC4)
                                {
                                    If ((Arg0 == 0x03))
                                    {
                                        If (!\CWAS)
                                        {
                                            Notify (\_PR.CPU0, 0x81) // C-State Change
                                            If (\MPEN)
                                            {
                                                Notify (\_PR.CPU1, 0x81) // C-State Change
                                            }

                                            \CWAS = 0x01
                                        }
                                    }
                                    Else
                                    {
                                        If ((Arg0 == 0x04))
                                        {
                                            If (\CWAS)
                                            {
                                                Notify (\_PR.CPU0, 0x81) // C-State Change
                                                If (\MPEN)
                                                {
                                                    Notify (\_PR.CPU1, 0x81) // C-State Change
                                                }

                                                \CWAS = 0x00
                                            }
                                        }
                                        Else
                                        {
                                            Noop
                                        }
                                    }
                                }
                                Else
                                {
                                    If ((Arg0 == 0x03))
                                    {
                                        If (!\CWAS)
                                        {
                                            \_SB.PCI0.LPC.C4C3 = 0x00
                                            \CWAS = 0x01
                                        }
                                    }
                                    Else
                                    {
                                        If ((Arg0 == 0x04))
                                        {
                                            If (\CWAS)
                                            {
                                                \CWAS = 0x00
                                                If (!CKC4 (0x00))
                                                {
                                                    \_SB.PCI0.LPC.C4C3 = 0x01
                                                }
                                            }
                                        }
                                        Else
                                        {
                                            Noop
                                        }
                                    }
                                }

                                Release (XDHK)
                            }
                            Else
                            {
                                Noop
                            }
                        }

                        Method (CKC4, 1, NotSerialized)
                        {
                            Local0 = 0x00
                            If (DHC4)
                            {
                                If (\C4WR)
                                {
                                    If (!\C4AC)
                                    {
                                        Local0 |= 0x01
                                    }
                                }
                            }
                            Else
                            {
                                If (\_SB.PCI0.LPC.EC.AC._PSR ())
                                {
                                    Local0 |= 0x01
                                }
                            }

                            If (\C4NA)
                            {
                                Local0 |= 0x02
                            }

                            If ((\CWAC && \CWAS))
                            {
                                Local0 |= 0x04
                            }

                            If ((\CWUE && \CWUS))
                            {
                                Local0 |= 0x08
                            }

                            Local0 &= ~Arg0
                            Return (Local0)
                        }

                        Method (MHQE, 0, NotSerialized)
                        {
                            Return (\C4WR)
                        }

                        Method (MHGE, 0, NotSerialized)
                        {
                            DHC4 = 0x01
                            If ((\C4WR && \C4AC))
                            {
                                Return (0x04)
                            }

                            Return (0x03)
                        }

                        Method (MHSE, 1, NotSerialized)
                        {
                            If (\C4WR)
                            {
                                DHC4 = 0x01
                                Local0 = \C4AC
                                If ((Arg0 == 0x03))
                                {
                                    \C4AC = 0x00
                                    If ((Local0 ^ \C4AC))
                                    {
                                        If (\OSC4)
                                        {
                                            Notify (\_PR.CPU0, 0x81) // C-State Change
                                            If (\MPEN)
                                            {
                                                Notify (\_PR.CPU1, 0x81) // C-State Change
                                            }
                                        }
                                        Else
                                        {
                                            \_SB.PCI0.LPC.C4C3 = 0x00
                                        }
                                    }
                                }
                                Else
                                {
                                    If ((Arg0 == 0x04))
                                    {
                                        \C4AC = 0x01
                                        If ((Local0 ^ \C4AC))
                                        {
                                            If (\OSC4)
                                            {
                                                Notify (\_PR.CPU0, 0x81) // C-State Change
                                                If (\MPEN)
                                                {
                                                    Notify (\_PR.CPU1, 0x81) // C-State Change
                                                }
                                            }
                                            Else
                                            {
                                                If (!CKC4 (0x00))
                                                {
                                                    \_SB.PCI0.LPC.C4C3 = 0x01
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    Scope (\_SB.PCI0.LPC.EC.HKEY)
                    {
                        Method (TDSC, 1, NotSerialized)
                        {
                            Local0 = 0x01
                            While (Local0)
                            {
                                Local0 = \_SB.PCI0.LPC.EC.HANT
                            }

                            \_SB.PCI0.LPC.EC.HANT = Arg0
                            If ((Arg0 == 0x21))
                            {
                                \ATCC (0x00)
                            }
                        }

                        Method (TDSS, 1, NotSerialized)
                        {
                            \ATCC (Arg0)
                        }

                        Method (TDSG, 1, NotSerialized)
                        {
                            Local0 = (Arg0 & 0xFF)
                            \_SB.PCI0.LPC.EC.HDAA = Local0
                            Local0 = (Arg0 >> 0x08)
                            Local1 = (Local0 & 0xFF)
                            \_SB.PCI0.LPC.EC.HDAB = Local1
                            Local0 = (Arg0 >> 0x10)
                            Local1 = (Local0 & 0xFF)
                            \_SB.PCI0.LPC.EC.HDAC = Local1
                            Local0 = (Arg0 >> 0x18)
                            Local1 = (Local0 & 0xFF)
                            \_SB.PCI0.LPC.EC.HANA = Local1
                        }

                        Method (TDGC, 0, NotSerialized)
                        {
                            Local0 = \_SB.PCI0.LPC.EC.HDDD
                            Return (Local0)
                        }

                        Method (TDGS, 0, NotSerialized)
                        {
                            Local0 = \_SB.PCI0.LPC.EC.HAAA
                            Return (Local0)
                        }
                    }

                    Field (ECOR, ByteAcc, Lock, Preserve)
                    {
                        Offset (0x54), 
                        HSD0,   8, 
                        HSD1,   8, 
                        HSD2,   8
                    }

                    Field (ECOR, ByteAcc, Lock, Preserve)
                    {
                        Offset (0x56), 
                        HSDL,   16
                    }

                    Field (ECOR, ByteAcc, Lock, Preserve)
                    {
                        Offset (0x56), 
                        HSDB,   72, 
                        HSDF,   16, 
                        HSDC,   16
                    }

                    Mutex (I2CM, 0x07)
                    Method (CHKS, 0, NotSerialized)
                    {
                        Local0 = 0x03E8
                        While (HMPR)
                        {
                            Sleep (0x01)
                            Local0--
                            If (!Local0)
                            {
                                Return (0x8080)
                            }
                        }

                        If (HMDN)
                        {
                            If (HMST)
                            {
                                Return ((0x8000 | HMST))
                            }
                            Else
                            {
                                Return (Zero)
                            }
                        }
                        Else
                        {
                            Return (0x8081)
                        }
                    }

                    Method (I2RT, 0, NotSerialized)
                    {
                        HMAD = 0x02
                        HMCM = 0x21
                        HMPR = 0x0B
                        Return (CHKS ())
                    }

                    Method (I2NT, 1, NotSerialized)
                    {
                        HMAD = 0x02
                        HMCM = 0x22
                        HSD0 = Arg0
                        HMPR = 0x06
                        Return (CHKS ())
                    }

                    Method (TATR, 0, NotSerialized)
                    {
                        If (\H8DR)
                        {
                            Acquire (I2CM, 0xFFFF)
                            I2RT ()
                            Local0 = HSD0 /* \_SB_.PCI0.LPC_.EC__.HSD0 */
                            If ((Local0 == 0x20))
                            {
                                \_SB.PCI0.LPC.TCSZ (HSD1, HSD2)
                                I2NT (Local0)
                            }
                            Else
                            {
                                If ((Local0 == 0x21))
                                {
                                    \_SB.PCI0.LPC.TCST (HSD1, HSD2)
                                    I2NT (Local0)
                                }
                                Else
                                {
                                    If ((Local0 == 0x22))
                                    {
                                        Name (TSDC, Buffer (0x09)
                                        {
                                            "        "
                                        })
                                        TSDC = HSDB /* \_SB_.PCI0.LPC_.EC__.HSDB */
                                        \_SB.PCI0.LPC.TCBS (HSD1, TSDC, HSDF, HSDC)
                                        I2NT (Local0)
                                    }
                                    Else
                                    {
                                        If ((Local0 == 0x23))
                                        {
                                            \_SB.PCI0.LPC.TSCL (HSD1, HSDL)
                                            I2NT (Local0)
                                        }
                                    }
                                }
                            }

                            Release (I2CM)
                        }
                    }

                    Method (TATE, 0, NotSerialized)
                    {
                        HETE = 0x01
                    }

                    Scope (\_SB.PCI0.LPC.EC.HKEY)
                    {
                        Name (WGBF, Buffer (0x01)
                        {
                             0x00                                             /* . */
                        })
                        CreateField (WGBF, 0x00, 0x02, HPWC)
                        CreateField (WGBF, 0x02, 0x02, HWPN)
                        Method (MHQP, 0, NotSerialized)
                        {
                            Return ((0x01 ^ \_SB.PCI0.LPC.EC.PSTA))
                        }

                        Method (MHGP, 0, NotSerialized)
                        {
                            Return ((\_SB.PCI0.LPC.EC.HWPN & 0x03))
                        }

                        Method (MHSP, 1, NotSerialized)
                        {
                            \_SB.PCI0.LPC.EC.HWPN = (Arg0 & 0x03)
                        }

                        Method (MHGW, 0, NotSerialized)
                        {
                            Return (\_SB.PCI0.LPC.EC.HPWC)
                        }

                        Method (MHSW, 1, NotSerialized)
                        {
                            \_SB.PCI0.LPC.EC.HPWC = (Arg0 & 0x03)
                        }

                        Method (SVWG, 0, NotSerialized)
                        {
                            HPWC = \_SB.PCI0.LPC.EC.HPWC
                            HWPN = \_SB.PCI0.LPC.EC.HWPN
                        }

                        Method (RTWG, 0, NotSerialized)
                        {
                            \_SB.PCI0.LPC.EC.HPWC = HPWC /* \_SB_.PCI0.LPC_.EC__.HKEY.HPWC */
                            \_SB.PCI0.LPC.EC.HWPN = HWPN /* \_SB_.PCI0.LPC_.EC__.HKEY.HWPN */
                        }
                    }

                    Method (_Q5C, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\H8DR)
                        {
                            If (HPLD)
                            {
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x500B)
                            }
                        }
                    }

                    Method (_Q5D, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\H8DR)
                        {
                            If (HPLD)
                            {
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x500C)
                            }
                        }
                    }

                    Scope (\_SB.PCI0.LPC.EC.HKEY)
                    {
                        Name (INDV, 0x00)
                        Method (MHQI, 0, NotSerialized)
                        {
                            If ((\IPMS & 0x01))
                            {
                                INDV |= 0x01
                            }

                            If ((\IPMS & 0x02))
                            {
                                INDV |= 0x02
                            }

                            If ((\IPMS & 0x04))
                            {
                                INDV |= 0x0100
                            }

                            If ((\IPMS & 0x08))
                            {
                                INDV |= 0x0200
                            }

                            Return (INDV) /* \_SB_.PCI0.LPC_.EC__.HKEY.INDV */
                        }

                        Method (MHGI, 1, NotSerialized)
                        {
                            Name (RETB, Buffer (0x10) {})
                            CreateByteField (RETB, 0x00, MHGS)
                            Local0 = (0x01 << Arg0)
                            If ((INDV & Local0))
                            {
                                If ((Arg0 == 0x00))
                                {
                                    CreateField (RETB, 0x08, 0x78, BRBU)
                                    BRBU = \IPMB
                                    MHGS = 0x10
                                }
                                Else
                                {
                                    If ((Arg0 == 0x01))
                                    {
                                        CreateField (RETB, 0x08, 0x18, RRBU)
                                        RRBU = \IPMR
                                        MHGS = 0x04
                                    }
                                    Else
                                    {
                                        If ((Arg0 == 0x08))
                                        {
                                            CreateField (RETB, 0x10, 0x18, ODBU)
                                            CreateByteField (RETB, 0x01, MHGZ)
                                            ODBU = \IPMO
                                            If (((^^BSTS == 0x00) && (^^BDEV == 0x0B)))
                                            {
                                                MHGZ |= 0x01 /* \_SB_.PCI0.LPC_.EC__.HKEY.MHGI.MHGZ */
                                                MHGZ |= 0x02 /* \_SB_.PCI0.LPC_.EC__.HKEY.MHGI.MHGZ */
                                            }

                                            MHGS = 0x05
                                        }
                                        Else
                                        {
                                            If ((Arg0 == 0x09))
                                            {
                                                CreateField (RETB, 0x10, 0x08, AUBU)
                                                AUBU = \IPMA
                                                Index (RETB, 0x01) = 0x01
                                                MHGS = 0x03
                                            }
                                        }
                                    }
                                }
                            }

                            Return (RETB) /* \_SB_.PCI0.LPC_.EC__.HKEY.MHGI.RETB */
                        }

                        Method (MHSI, 2, NotSerialized)
                        {
                            Local0 = (0x01 << Arg0)
                            If ((INDV & Local0))
                            {
                                If ((Arg0 == 0x08))
                                {
                                    If (Arg1)
                                    {
                                        If ((\_SB.PCI0.LPC.EC.SFLG & 0x0400))
                                        {
                                            If (\H8DR)
                                            {
                                                Local1 = ^^HPBU /* \_SB_.PCI0.LPC_.EC__.HPBU */
                                            }
                                            Else
                                            {
                                                Local1 = (\RBEC (0x47) & 0x01)
                                            }

                                            If (!Local1)
                                            {
                                                ^^BDEV = ^^BGID (0x00)
                                                ^^NBIN (Local1)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Name (_ADR, 0x00)  // _ADR: Address
            Name (_S3D, 0x02)  // _S3D: S3 Device State
            Name (RID, 0x00)
            Name (LRRT, Package (0x16)
            {
                Package (0x04)
                {
                    0x0001FFFF, 
                    0x00, 
                    \_SB.LNKA, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x0002FFFF, 
                    0x00, 
                    \_SB.LNKA, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x00, 
                    \_SB.LNKA, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x01, 
                    \_SB.LNKB, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x02, 
                    \_SB.LNKC, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x03, 
                    \_SB.LNKD, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x0019FFFF, 
                    0x00, 
                    \_SB.LNKE, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001AFFFF, 
                    0x00, 
                    \_SB.LNKE, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001AFFFF, 
                    0x01, 
                    \_SB.LNKF, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001AFFFF, 
                    0x02, 
                    \_SB.LNKG, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001BFFFF, 
                    0x01, 
                    \_SB.LNKB, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x00, 
                    \_SB.LNKE, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x01, 
                    \_SB.LNKF, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x02, 
                    \_SB.LNKG, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x03, 
                    \_SB.LNKH, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x00, 
                    \_SB.LNKA, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x01, 
                    \_SB.LNKB, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x02, 
                    \_SB.LNKC, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x03, 
                    \_SB.LNKD, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001FFFFF, 
                    0x00, 
                    \_SB.LNKH, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001FFFFF, 
                    0x02, 
                    \_SB.LNKA, 
                    0x00
                }, 

                Package (0x04)
                {
                    0x001FFFFF, 
                    0x01, 
                    \_SB.LNKA, 
                    0x00
                }
            })
            Name (ARRT, Package (0x16)
            {
                Package (0x04)
                {
                    0x0001FFFF, 
                    0x00, 
                    0x00, 
                    0x10
                }, 

                Package (0x04)
                {
                    0x0002FFFF, 
                    0x00, 
                    0x00, 
                    0x10
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x00, 
                    0x00, 
                    0x10
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x01, 
                    0x00, 
                    0x11
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x02, 
                    0x00, 
                    0x12
                }, 

                Package (0x04)
                {
                    0x0003FFFF, 
                    0x03, 
                    0x00, 
                    0x13
                }, 

                Package (0x04)
                {
                    0x0019FFFF, 
                    0x00, 
                    0x00, 
                    0x14
                }, 

                Package (0x04)
                {
                    0x001AFFFF, 
                    0x00, 
                    0x00, 
                    0x14
                }, 

                Package (0x04)
                {
                    0x001AFFFF, 
                    0x01, 
                    0x00, 
                    0x15
                }, 

                Package (0x04)
                {
                    0x001AFFFF, 
                    0x02, 
                    0x00, 
                    0x16
                }, 

                Package (0x04)
                {
                    0x001BFFFF, 
                    0x01, 
                    0x00, 
                    0x11
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x00, 
                    0x00, 
                    0x14
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x01, 
                    0x00, 
                    0x15
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x02, 
                    0x00, 
                    0x16
                }, 

                Package (0x04)
                {
                    0x001CFFFF, 
                    0x03, 
                    0x00, 
                    0x17
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x00, 
                    0x00, 
                    0x10
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x01, 
                    0x00, 
                    0x11
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x02, 
                    0x00, 
                    0x12
                }, 

                Package (0x04)
                {
                    0x001DFFFF, 
                    0x03, 
                    0x00, 
                    0x13
                }, 

                Package (0x04)
                {
                    0x001FFFFF, 
                    0x00, 
                    0x00, 
                    0x17
                }, 

                Package (0x04)
                {
                    0x001FFFFF, 
                    0x02, 
                    0x00, 
                    0x10
                }, 

                Package (0x04)
                {
                    0x001FFFFF, 
                    0x01, 
                    0x00, 
                    0x10
                }
            })
            Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
            {
                If (\GPIC)
                {
                    Return (ARRT) /* \_SB_.PCI0.ARRT */
                }
                Else
                {
                    Return (LRRT) /* \_SB_.PCI0.LRRT */
                }
            }

            Name (_HID, EisaId ("PNP0A08") /* PCI Express Bus */)  // _HID: Hardware ID
            Name (_CID, EisaId ("PNP0A03") /* PCI Bus */)  // _CID: Compatible ID
            Name (_BBN, 0x00)  // _BBN: BIOS Bus Number
            OperationRegion (MHCS, PCI_Config, 0x00, 0x0100)
            Field (MHCS, DWordAcc, NoLock, Preserve)
            {
                Offset (0x90), 
                PAM0,   8, 
                PAM1,   8, 
                PAM2,   8, 
                PAM3,   8, 
                PAM4,   8, 
                PAM5,   8, 
                PAM6,   8, 
                Offset (0xB0), 
                    ,   4, 
                TOUD,   12
            }

            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
            {
                WordBusNumber (ResourceProducer, MinFixed, MaxFixed, PosDecode,
                    0x0000,             // Granularity
                    0x0000,             // Range Minimum
                    0x00FF,             // Range Maximum
                    0x0000,             // Translation Offset
                    0x0100,             // Length
                    ,, )
                IO (Decode16,
                    0x0CF8,             // Range Minimum
                    0x0CF8,             // Range Maximum
                    0x01,               // Alignment
                    0x08,               // Length
                    )
                WordIO (ResourceProducer, MinFixed, MaxFixed, PosDecode, EntireRange,
                    0x0000,             // Granularity
                    0x0000,             // Range Minimum
                    0x0CF7,             // Range Maximum
                    0x0000,             // Translation Offset
                    0x0CF8,             // Length
                    ,, , TypeStatic)
                WordIO (ResourceProducer, MinFixed, MaxFixed, PosDecode, EntireRange,
                    0x0000,             // Granularity
                    0x0D00,             // Range Minimum
                    0xFFFF,             // Range Maximum
                    0x0000,             // Translation Offset
                    0xF300,             // Length
                    ,, , TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000A0000,         // Range Minimum
                    0x000BFFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00020000,         // Length
                    ,, , AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000C0000,         // Range Minimum
                    0x000C3FFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y23, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000C4000,         // Range Minimum
                    0x000C7FFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y24, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000C8000,         // Range Minimum
                    0x000CBFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y25, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000CC000,         // Range Minimum
                    0x000CFFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y26, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000D0000,         // Range Minimum
                    0x000D3FFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y27, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000D4000,         // Range Minimum
                    0x000D7FFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y28, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000D8000,         // Range Minimum
                    0x000DBFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y29, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000DC000,         // Range Minimum
                    0x000DFFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y2A, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000E0000,         // Range Minimum
                    0x000E3FFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y2B, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000E4000,         // Range Minimum
                    0x000E7FFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y2C, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000E8000,         // Range Minimum
                    0x000EBFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y2D, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x000EC000,         // Range Minimum
                    0x000EFFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x00004000,         // Length
                    ,, _Y2E, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0x00100000,         // Range Minimum
                    0xFEBFFFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0xFEB00000,         // Length
                    ,, _Y2F, AddressRangeMemory, TypeStatic)
                DWordMemory (ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
                    0x00000000,         // Granularity
                    0xFED40000,         // Range Minimum
                    0xFED4BFFF,         // Range Maximum
                    0x00000000,         // Translation Offset
                    0x0000C000,         // Length
                    ,, _Y30, AddressRangeMemory, TypeStatic)
            })
            CreateDWordField (_CRS, \_SB.PCI0._Y23._LEN, C0LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y24._LEN, C4LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y25._LEN, C8LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y26._LEN, CCLN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y27._LEN, D0LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y28._LEN, D4LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y29._LEN, D8LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y2A._LEN, DCLN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y2B._LEN, E0LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y2C._LEN, E4LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y2D._LEN, E8LN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y2E._LEN, ECLN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y2F._MIN, XXMN)  // _MIN: Minimum Base Address
            CreateDWordField (_CRS, \_SB.PCI0._Y2F._MAX, XXMX)  // _MAX: Maximum Base Address
            CreateDWordField (_CRS, \_SB.PCI0._Y2F._LEN, XXLN)  // _LEN: Length
            CreateDWordField (_CRS, \_SB.PCI0._Y30._MIN, F4MN)  // _MIN: Minimum Base Address
            CreateDWordField (_CRS, \_SB.PCI0._Y30._MAX, F4MX)  // _MAX: Maximum Base Address
            CreateDWordField (_CRS, \_SB.PCI0._Y30._LEN, F4LN)  // _LEN: Length
            Method (_INI, 0, Serialized)  // _INI: Initialize
            {
                If (!\OSIF)
                {
                    \_SB._INI ()
                }

                Local0 = (TOUD << 0x14)
                \MEMX = Local0
                XXMN = Local0
                XXLN = ((XXMX - XXMN) + 0x01)
                If (((\TPMP & 0x01) != 0x01))
                {
                    F4LN = 0x00
                }

                If ((PAM1 & 0x03))
                {
                    C0LN = 0x00
                }

                If ((PAM1 & 0x30))
                {
                    C4LN = 0x00
                }

                If ((PAM2 & 0x03))
                {
                    C8LN = 0x00
                }

                If ((PAM2 & 0x30))
                {
                    CCLN = 0x00
                }

                If ((PAM3 & 0x03))
                {
                    D0LN = 0x00
                }

                If ((PAM3 & 0x30))
                {
                    D4LN = 0x00
                }

                If ((PAM4 & 0x03))
                {
                    D8LN = 0x00
                }

                If ((PAM4 & 0x30))
                {
                    DCLN = 0x00
                }

                If ((PAM5 & 0x03))
                {
                    E0LN = 0x00
                }

                If ((PAM5 & 0x30))
                {
                    E4LN = 0x00
                }

                If ((PAM6 & 0x03))
                {
                    E8LN = 0x00
                }

                If ((PAM6 & 0x30))
                {
                    ECLN = 0x00
                }
            }

            Name (SUPP, 0x00)
            Name (CTRL, 0x00)
            Method (_OSC, 4, NotSerialized)  // _OSC: Operating System Capabilities
            {
                CreateDWordField (Arg3, 0x00, CDW1)
                CreateDWordField (Arg3, 0x04, CDW2)
                CreateDWordField (Arg3, 0x08, CDW3)
                CreateDWordField (Arg0, 0x00, IID0)
                CreateDWordField (Arg0, 0x04, IID1)
                CreateDWordField (Arg0, 0x08, IID2)
                CreateDWordField (Arg0, 0x0C, IID3)
                Name (UID0, ToUUID ("33db4d5b-1ff7-401c-9657-7441c03dd766") /* PCI Host Bridge Device */)
                CreateDWordField (UID0, 0x00, EID0)
                CreateDWordField (UID0, 0x04, EID1)
                CreateDWordField (UID0, 0x08, EID2)
                CreateDWordField (UID0, 0x0C, EID3)
                If ((((IID0 == EID0) && (IID1 == EID1)) && ((IID2 == 
                    EID2) && (IID3 == EID3))))
                {
                    SUPP = CDW2 /* \_SB_.PCI0._OSC.CDW2 */
                    CTRL = CDW3 /* \_SB_.PCI0._OSC.CDW3 */
                    CTRL &= 0x1D
                    If (~(CDW1 & 0x01))
                    {
                        If ((CTRL & 0x01))
                        {
                            If (!\VIGD)
                            {
                                \_SB.PCI0.AGP.HPGP = 0x00
                                \_SB.PCI0.AGP.GMGP = 0x00
                            }

                            \_SB.PCI0.EXP3.HPCE = 0x00
                            \_SB.PCI0.EXP3.HPCS = 0x01
                            \_SB.PCI0.EXP3.ABP = 0x01
                            \_SB.PCI0.EXP3.PDS = 0x01
                            \NHPS = 0x01
                        }

                        If ((CTRL & 0x04))
                        {
                            If (!\VIGD)
                            {
                                \_SB.PCI0.AGP.PMGP = 0x00
                                \_SB.PCI0.AGP.GMGP = 0x00
                            }

                            \_SB.PCI0.EXP3.PMCE = 0x00
                            \_SB.PCI0.EXP3.PMCS = 0x01
                            \_SB.PCI0.LPC.EXPE = 0x00
                            \NPME = 0x01
                        }
                    }

                    If ((Arg1 != 0x01))
                    {
                        CDW1 |= 0x0A
                    }

                    If ((CDW3 != CTRL))
                    {
                        CDW1 |= 0x10
                    }

                    CDW3 = CTRL /* \_SB_.PCI0.CTRL */
                }
                Else
                {
                    CDW1 |= 0x06
                }

                Return (Arg3)
            }

            Mutex (MDGS, 0x07)
            Name (VDEE, 0x01)
            Name (VDDA, Buffer (0x02) {})
            CreateBitField (VDDA, 0x00, VUPC)
            CreateBitField (VDDA, 0x01, VQDL)
            CreateBitField (VDDA, 0x02, VQDC)
            CreateBitField (VDDA, 0x03, VQDT)
            CreateBitField (VDDA, 0x04, VQDD)
            CreateBitField (VDDA, 0x05, VSDL)
            CreateBitField (VDDA, 0x06, VSDC)
            CreateBitField (VDDA, 0x07, VSDT)
            CreateBitField (VDDA, 0x08, VSDD)
            CreateBitField (VDDA, 0x0A, MSWT)
            CreateBitField (VDDA, 0x0B, VWST)
            Name (VDPU, 0x00)
            Device (VID)
            {
                Name (_ADR, 0x00020000)  // _ADR: Address
                Name (RID, 0x00)
                OperationRegion (VPCG, PCI_Config, 0x00, 0x0100)
                Field (VPCG, DWordAcc, NoLock, Preserve)
                {
                    Offset (0xD4), 
                    VPWR,   8
                }

                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Method (_INI, 0, NotSerialized)  // _INI: Initialize
                {
                    \VUPS (0x02)
                    VQDL = \VCDL
                    VQDC = \VCDC
                    VQDT = \VCDT
                    VQDD = \VCDD
                }

                Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
                {
                    Noop
                }

                Method (_PS1, 0, NotSerialized)  // _PS1: Power State 1
                {
                    Noop
                }

                Method (_PS2, 0, NotSerialized)  // _PS2: Power State 2
                {
                    Noop
                }

                Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
                {
                    Noop
                }

                Method (VSWT, 0, NotSerialized)
                {
                    If (\WVIS)
                    {
                        Local0 = \VEVT (0x07)
                    }
                    Else
                    {
                        Local0 = \VEVT (0x05)
                    }

                    Local1 = (0x0F & Local0)
                    If (DSFS)
                    {
                        If ((Local1 == 0x03))
                        {
                            Local1 = 0x01
                        }
                    }

                    If (Local1)
                    {
                        ASWT (Local1, 0x01)
                        GHDS (0x00)
                    }
                }

                Method (VLOC, 1, NotSerialized)
                {
                    If ((Arg0 == \_SB.LID._LID ()))
                    {
                        \VSLD (Arg0)
                        If ((VPWR == 0x00))
                        {
                            If (Arg0)
                            {
                                Local0 = \VEVT (0x01)
                            }
                            Else
                            {
                                Local0 = \VEVT (0x02)
                                If (EXTD)
                                {
                                    Local0 = 0x00
                                }
                            }

                            Local1 = (0x0F & Local0)
                            If (Local1)
                            {
                                ASWT (Local1, 0x00)
                                CLID = Arg0
                                GNOT (0x02, 0x00)
                            }
                        }
                    }
                }

                Method (_DOS, 1, NotSerialized)  // _DOS: Disable Output Switching
                {
                    Arg0 &= 0x03
                    If ((Arg0 == 0x02))
                    {
                        Local0 = 0x14
                        While (Local0)
                        {
                            Local0--
                            Acquire (MDGS, 0xFFFF)
                            If ((0x00 == MSWT))
                            {
                                MSWT = 0x01
                                Local0 = 0x00
                                VDEE = Arg0
                            }

                            Release (MDGS)
                            Sleep (0xC8)
                        }
                    }
                    Else
                    {
                        Acquire (MDGS, 0xFFFF)
                        If ((VDEE == 0x02))
                        {
                            MSWT = 0x00
                        }

                        If ((Arg0 > 0x02))
                        {
                            VDEE = 0x01
                        }
                        Else
                        {
                            VDEE = Arg0
                        }

                        Release (MDGS)
                    }
                }

                Method (_DOD, 0, NotSerialized)  // _DOD: Display Output Devices
                {
                    Return (Package (0x03)
                    {
                        0x0100, 
                        0x0300, 
                        0x0400
                    })
                }

                Method (ASWT, 2, NotSerialized)
                {
                    If ((0x01 == VDEE))
                    {
                        Local1 = (0x01 & Arg1)
                        \VSDS (Arg0, Local1)
                    }
                    Else
                    {
                        Local0 = 0x14
                        While (Local0)
                        {
                            Local0--
                            Acquire (MDGS, 0xFFFF)
                            If ((0x00 == MSWT))
                            {
                                Local0 = 0x00
                                If ((0x01 & Arg1))
                                {
                                    VUPC = 0x01
                                }
                                Else
                                {
                                    VUPC = 0x00
                                }

                                If ((0x01 & Arg0))
                                {
                                    VQDL = 0x01
                                }
                                Else
                                {
                                    VQDL = 0x00
                                }

                                If ((0x02 & Arg0))
                                {
                                    VQDC = 0x01
                                }
                                Else
                                {
                                    VQDC = 0x00
                                }

                                If ((0x08 & Arg0))
                                {
                                    VQDD = 0x01
                                }
                                Else
                                {
                                    VQDD = 0x00
                                }
                            }

                            Release (MDGS)
                            Sleep (0xC8)
                        }
                    }
                }

                Method (VDSW, 1, NotSerialized)
                {
                    If ((VPWR == 0x00))
                    {
                        If (Arg0)
                        {
                            VDPU = 0x00
                            Local0 = \VEVT (0x03)
                            Local1 = (0x0F & Local0)
                            If (Local1)
                            {
                                ASWT (Local1, 0x00)
                                GDCK (Arg0)
                            }
                        }
                        Else
                        {
                            VDPU = 0x01
                            Local0 = \VEVT (0x04)
                            ASWT (0x01, 0x00)
                            GDCK (Arg0)
                        }
                    }
                }

                Method (VDSP, 0, NotSerialized)
                {
                    If ((VPWR == 0x00))
                    {
                        If ((VDPU == 0x01))
                        {
                            VDPU = 0x00
                            If (\_SB.LID._LID ())
                            {
                                ASWT (0x01, 0x00)
                                GLID (0x01)
                            }
                        }
                    }
                }

                Method (VSPD, 0, NotSerialized)
                {
                    Local0 = \VEVT (0x06)
                    Local1 = (0x0F & Local0)
                    If (Local1)
                    {
                        ASWT (Local1, 0x01)
                        GHDS (0x00)
                    }
                }

                Device (LCD0)
                {
                    Name (_ADR, 0x0400)  // _ADR: Address
                    Method (_DCS, 0, NotSerialized)  // _DCS: Display Current Status
                    {
                        \VUPS (0x00)
                        If (\VCDL)
                        {
                            Return (0x1F)
                        }
                        Else
                        {
                            Return (0x1D)
                        }
                    }

                    Method (_DGS, 0, NotSerialized)  // _DGS: Display Graphics State
                    {
                        Return (VQDL) /* \_SB_.PCI0.VQDL */
                    }

                    Method (_DSS, 1, NotSerialized)  // _DSS: Device Set State
                    {
                        VSDL = (Arg0 & 0x01)
                        If ((Arg0 & 0x80000000))
                        {
                            If ((Arg0 & 0x40000000))
                            {
                                DSWT (0x02)
                            }
                            Else
                            {
                                DSWT (0x01)
                            }
                        }
                    }
                }

                Device (CRT0)
                {
                    Name (_ADR, 0x0100)  // _ADR: Address
                    Method (_DCS, 0, NotSerialized)  // _DCS: Display Current Status
                    {
                        \VUPS (0x01)
                        If (\VCSS)
                        {
                            If (\VCDC)
                            {
                                Return (0x1F)
                            }
                            Else
                            {
                                Return (0x1D)
                            }
                        }
                        Else
                        {
                            If (\VCDC)
                            {
                                Return (0x0F)
                            }
                            Else
                            {
                                Return (0x0D)
                            }
                        }
                    }

                    Method (_DGS, 0, NotSerialized)  // _DGS: Display Graphics State
                    {
                        Return (VQDC) /* \_SB_.PCI0.VQDC */
                    }

                    Method (_DSS, 1, NotSerialized)  // _DSS: Device Set State
                    {
                        VSDC = (Arg0 & 0x01)
                        If ((Arg0 & 0x80000000))
                        {
                            If ((Arg0 & 0x40000000))
                            {
                                DSWT (0x02)
                            }
                            Else
                            {
                                DSWT (0x01)
                            }
                        }
                    }
                }

                Device (DVI0)
                {
                    Name (_ADR, 0x0300)  // _ADR: Address
                    Method (_DCS, 0, NotSerialized)  // _DCS: Display Current Status
                    {
                        \VUPS (0x00)
                        If (\VCDD)
                        {
                            Return (0x1F)
                        }
                        Else
                        {
                            Return (0x1D)
                        }
                    }

                    Method (_DGS, 0, NotSerialized)  // _DGS: Display Graphics State
                    {
                        Return (VQDD) /* \_SB_.PCI0.VQDD */
                    }

                    Method (_DSS, 1, NotSerialized)  // _DSS: Device Set State
                    {
                        VSDD = (Arg0 & 0x01)
                        If ((Arg0 & 0x80000000))
                        {
                            If ((Arg0 & 0x40000000))
                            {
                                DSWT (0x02)
                            }
                            Else
                            {
                                DSWT (0x01)
                            }
                        }
                    }
                }

                Method (DSWT, 1, NotSerialized)
                {
                    If (VSDL)
                    {
                        Local0 = 0x01
                    }
                    Else
                    {
                        Local0 = 0x00
                    }

                    If (VSDC)
                    {
                        Local0 |= 0x02
                    }

                    If (VSDD)
                    {
                        Local0 |= 0x08
                    }

                    If (Local0)
                    {
                        If (VUPC)
                        {
                            \VSDS (Local0, Arg0)
                        }
                    }
                    Else
                    {
                        Noop
                    }
                }

                OperationRegion (IGDP, PCI_Config, 0x40, 0xC0)
                Field (IGDP, AnyAcc, NoLock, Preserve)
                {
                    Offset (0x12), 
                        ,   1, 
                    GIVD,   1, 
                        ,   2, 
                    GUMA,   3, 
                    Offset (0x14), 
                        ,   4, 
                    GMFN,   1, 
                    Offset (0x18), 
                    Offset (0xA4), 
                    ASLE,   8, 
                    Offset (0xA8), 
                    GSSE,   1, 
                    GSSB,   14, 
                    GSES,   1, 
                    Offset (0xB0), 
                    Offset (0xB1), 
                    CDVL,   5, 
                    Offset (0xB2), 
                    Offset (0xB5), 
                    LBPC,   8, 
                    Offset (0xBC), 
                    ASLS,   32
                }

                OperationRegion (IGDM, SystemMemory, \ASLB, 0x2000)
                Field (IGDM, AnyAcc, NoLock, Preserve)
                {
                    SIGN,   128, 
                    SIZE,   32, 
                    OVER,   32, 
                    SVER,   256, 
                    VVER,   128, 
                    GVER,   128, 
                    MBOX,   32, 
                    Offset (0x100), 
                    DRDY,   32, 
                    CSTS,   32, 
                    CEVT,   32, 
                    Offset (0x120), 
                    DIDL,   32, 
                    DDL2,   32, 
                    DDL3,   32, 
                    DDL4,   32, 
                    DDL5,   32, 
                    DDL6,   32, 
                    DDL7,   32, 
                    DDL8,   32, 
                    CPDL,   32, 
                    CPL2,   32, 
                    CPL3,   32, 
                    CPL4,   32, 
                    CPL5,   32, 
                    CPL6,   32, 
                    CPL7,   32, 
                    CPL8,   32, 
                    CADL,   32, 
                    CAL2,   32, 
                    CAL3,   32, 
                    CAL4,   32, 
                    CAL5,   32, 
                    CAL6,   32, 
                    CAL7,   32, 
                    CAL8,   32, 
                    NADL,   32, 
                    NDL2,   32, 
                    NDL3,   32, 
                    NDL4,   32, 
                    NDL5,   32, 
                    NDL6,   32, 
                    NDL7,   32, 
                    NDL8,   32, 
                    ASLP,   32, 
                    TIDX,   32, 
                    CHPD,   32, 
                    CLID,   32, 
                    CDCK,   32, 
                    SXSW,   32, 
                    EVTS,   32, 
                    CNOT,   32, 
                    NRDY,   32, 
                    Offset (0x200), 
                    SCIE,   1, 
                    GEFC,   4, 
                    GXFC,   3, 
                    GESF,   8, 
                    Offset (0x204), 
                    PARM,   32, 
                    DSLP,   32, 
                    Offset (0x300), 
                    ARDY,   32, 
                    ASLC,   32, 
                    TCHE,   32, 
                    ALSI,   32, 
                    BCLP,   32, 
                    PFIT,   32, 
                    CBLV,   32, 
                    BCLM,   320, 
                    CPFM,   32, 
                    EPFM,   32, 
                    Offset (0x400), 
                    GVD1,   57344
                }

                Name (DBTB, Package (0x15)
                {
                    0x00, 
                    0x07, 
                    0x38, 
                    0x01C0, 
                    0x0E00, 
                    0x3F, 
                    0x01C7, 
                    0x0E07, 
                    0x01F8, 
                    0x0E38, 
                    0x0FC0, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x7000, 
                    0x7007, 
                    0x7038, 
                    0x71C0, 
                    0x7E00
                })
                Name (DBTC, Package (0x15)
                {
                    0x00, 
                    0x02, 
                    0x01, 
                    0x08, 
                    0x00, 
                    0x03, 
                    0x0A, 
                    0x00, 
                    0x09, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x00, 
                    0x04, 
                    0x06, 
                    0x05, 
                    0x0C, 
                    0x00
                })
                Name (CDCT, Package (0x03)
                {
                    Package (0x03)
                    {
                        0xC8, 
                        0x0140, 
                        0x0190
                    }, 

                    Package (0x03)
                    {
                        0xC8, 
                        0x014D, 
                        0x0190
                    }, 

                    Package (0x03)
                    {
                        0xDE, 
                        0x014D, 
                        0x017D
                    }
                })
                Name (SUCC, 0x01)
                Name (NVLD, 0x02)
                Name (CRIT, 0x04)
                Name (NCRT, 0x06)
                Method (OPRN, 0, Serialized)
                {
                    If ((GEFC == 0x04))
                    {
                        GXFC = GBDA ()
                    }

                    If ((GEFC == 0x06))
                    {
                        GXFC = SBCB ()
                    }

                    GEFC = 0x00
                    \_SB.PCI0.LPC.SCIS = 0x01
                    GSSE = 0x00
                    SCIE = 0x00
                    Return (Zero)
                }

                Method (GBDA, 0, Serialized)
                {
                    If ((GESF == 0x00))
                    {
                        PARM = 0x0279
                        GESF = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x01))
                    {
                        PARM = 0x00010672
                        GESF = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x04))
                    {
                        PARM &= 0xEFFF0000
                        PARM &= (DerefOf (Index (DBTB, IBTT)) << 0x10)
                        PARM |= IBTT /* \_SB_.PCI0.VID_.PARM */
                        GESF = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x05))
                    {
                        If (\_SB.LID._LID ())
                        {
                            LIDS = 0x01
                        }
                        Else
                        {
                            LIDS = 0x00
                        }

                        PARM = IPSC /* \IPSC */
                        PARM += 0x01
                        PARM += 0x0300
                        PARM += 0x00010000
                        PARM |= (LIDS << 0x10)
                        PARM |= (IBIA << 0x14)
                        GESF = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x06))
                    {
                        PARM = ITVF /* \ITVF */
                        PARM |= (ITVM << 0x04)
                        GESF = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x07))
                    {
                        PARM = GIVD /* \_SB_.PCI0.VID_.GIVD */
                        PARM ^= 0x01
                        PARM |= (GMFN << 0x01)
                        PARM |= (0x02 << 0x0B)
                        If (IDMM)
                        {
                            PARM |= (IDMS << 0x11)
                        }
                        Else
                        {
                            PARM |= (IDMS << 0x0D)
                        }

                        PARM |= (DerefOf (Index (DerefOf (Index (CDCT, HVCO)), (CDVL - 
                            0x01))) << 0x15) /* \_SB_.PCI0.VID_.PARM */
                        GESF = 0x01
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x0A))
                    {
                        PARM = 0x00
                        If (ISSC)
                        {
                            PARM |= ISSC /* \ISSC */
                            PARM |= 0x00640000
                        }

                        GESF = 0x00
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    GESF = Zero
                    Return (CRIT) /* \_SB_.PCI0.VID_.CRIT */
                }

                Name (DSFS, 0x00)
                Name (EXTD, 0x00)
                Method (SBCB, 0, Serialized)
                {
                    If ((GESF == 0x00))
                    {
                        PARM = 0x8339
                        GESF = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x01))
                    {
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x03))
                    {
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x04))
                    {
                        PARM &= 0xFFFF
                        If ((PARM > 0x13))
                        {
                            DSFS = 0x00
                        }
                        Else
                        {
                            DSFS = 0x01
                        }

                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x05))
                    {
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x06))
                    {
                        ITVF = (PARM & 0x0F)
                        ITVM = ((PARM & 0xF0) >> 0x04)
                        \UCMS (0x19)
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x07))
                    {
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x08))
                    {
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x09))
                    {
                        EXTD = (PARM & 0x80000000)
                        Local0 = (PARM & 0xFF)
                        If ((Local0 <= 0x14))
                        {
                            IBTT = DerefOf (Index (DBTC, Local0))
                        }
                        Else
                        {
                            IBTT = 0x00
                        }

                        If (IBTT)
                        {
                            \UCMS (0x17)
                        }

                        IBTT = (PARM & 0xFF)
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x0A))
                    {
                        IPSC = ((PARM & 0x03) - 0x01)
                        \UCMS (0x1A)
                        If (((PARM >> 0x08) & 0xFF))
                        {
                            IPAT = ((PARM >> 0x08) & 0xFF)
                            IPAT--
                        }

                        IBIA = ((PARM >> 0x14) & 0x07)
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x0B))
                    {
                        IF1E = ((PARM >> 0x01) & 0x01)
                        If ((PARM & (0x0F << 0x0D)))
                        {
                            IDMS = ((PARM >> 0x0D) & 0x0F)
                            IDMM = 0x00
                        }
                        Else
                        {
                            IDMS = ((PARM >> 0x11) & 0x0F)
                            IDMM = 0x01
                        }

                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x10))
                    {
                        PARM &= 0x01
                        PARM ^= 0x01
                        DSFS = PARM /* \_SB_.PCI0.VID_.PARM */
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x11))
                    {
                        PARM = (LIDS << 0x08)
                        PARM += 0x0100
                        GESF = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x12))
                    {
                        If ((PARM & 0x01))
                        {
                            If (((PARM >> 0x01) == 0x01))
                            {
                                ISSC = 0x01
                            }
                            Else
                            {
                                GESF = Zero
                                Return (CRIT) /* \_SB_.PCI0.VID_.CRIT */
                            }
                        }
                        Else
                        {
                            ISSC = 0x00
                        }

                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    If ((GESF == 0x13))
                    {
                        GESF = Zero
                        PARM = Zero
                        Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                    }

                    GESF = Zero
                    Return (SUCC) /* \_SB_.PCI0.VID_.SUCC */
                }

                Method (PDRD, 0, NotSerialized)
                {
                    If (!DRDY)
                    {
                        Sleep (ASLP)
                    }

                    Return (!DRDY)
                }

                Method (PSTS, 0, NotSerialized)
                {
                    If ((CSTS > 0x02))
                    {
                        Sleep (ASLP)
                    }

                    Return ((CSTS == 0x03))
                }

                Method (GNOT, 2, NotSerialized)
                {
                    If (PDRD ())
                    {
                        Return (0x01)
                    }

                    If (PSTS ())
                    {
                        Return (0x01)
                    }

                    CEVT = Arg0
                    CSTS = 0x03
                    If (((CHPD == 0x00) && (Arg1 == 0x00)))
                    {
                        If ((Arg0 != 0x01))
                        {
                            If ((\WXPF && !\WVIS))
                            {
                                Notify (\_SB.PCI0, Arg1)
                            }
                            Else
                            {
                                Notify (\_SB.PCI0.VID, Arg1)
                            }
                        }
                    }

                    Notify (\_SB.PCI0.VID, 0x80) // Status Change
                    If (!PSTS ())
                    {
                        CEVT = 0x00
                    }

                    Return (0x00)
                }

                Method (GHDS, 1, NotSerialized)
                {
                    TIDX = Arg0
                    Return (GNOT (0x01, 0x00))
                }

                Method (GLID, 1, NotSerialized)
                {
                    CLID = Arg0
                    Return (GNOT (0x02, 0x00))
                }

                Method (GLIS, 1, NotSerialized)
                {
                    CLID = Arg0
                    Return (0x00)
                }

                Method (GDCK, 1, NotSerialized)
                {
                    CDCK = Arg0
                    Return (GNOT (0x04, 0x80))
                }

                Method (GDCS, 1, NotSerialized)
                {
                    CDCK = Arg0
                }

                Method (PARD, 0, NotSerialized)
                {
                    If (!ARDY)
                    {
                        Sleep (ASLP)
                    }

                    Return (!ARDY)
                }

                Method (AINT, 2, NotSerialized)
                {
                    If (!(TCHE & (0x01 << Arg0)))
                    {
                        Return (0x01)
                    }

                    If (PARD ())
                    {
                        Return (0x01)
                    }

                    If ((Arg0 == 0x02))
                    {
                        PFIT ^= 0x07
                        PFIT |= 0x80000000
                        ASLC = 0x04
                    }
                    Else
                    {
                        If ((Arg0 == 0x01))
                        {
                            BCLP = Arg1
                            BCLP |= 0x80000000
                            ASLC = 0x02
                        }
                        Else
                        {
                            If ((Arg0 == 0x00))
                            {
                                ALSI = Arg1
                                ASLC = 0x01
                            }
                            Else
                            {
                                Return (0x01)
                            }
                        }
                    }

                    LBPC = 0x00
                    Return (0x00)
                }
            }

            Device (AGP)
            {
                Name (_ADR, 0x00010000)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                Name (LART, Package (0x02)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        \_SB.LNKA, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        \_SB.LNKB, 
                        0x00
                    }
                })
                Name (AART, Package (0x02)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        0x00, 
                        0x10
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        0x00, 
                        0x11
                    }
                })
                Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
                {
                    If (\GPIC)
                    {
                        Return (AART) /* \_SB_.PCI0.AGP_.AART */
                    }
                    Else
                    {
                        Return (LART) /* \_SB_.PCI0.AGP_.LART */
                    }
                }

                Mutex (MDGS, 0x07)
                Name (VDEE, 0x01)
                Name (VDDA, Buffer (0x02) {})
                CreateBitField (VDDA, 0x00, VUPC)
                CreateBitField (VDDA, 0x01, VQDL)
                CreateBitField (VDDA, 0x02, VQDC)
                CreateBitField (VDDA, 0x03, VQDT)
                CreateBitField (VDDA, 0x04, VQDD)
                CreateBitField (VDDA, 0x05, VSDL)
                CreateBitField (VDDA, 0x06, VSDC)
                CreateBitField (VDDA, 0x07, VSDT)
                CreateBitField (VDDA, 0x08, VSDD)
                CreateBitField (VDDA, 0x0A, MSWT)
                CreateBitField (VDDA, 0x0B, VWST)
                Device (VID)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    OperationRegion (VPCG, PCI_Config, 0x00, 0x0100)
                    Field (VPCG, DWordAcc, NoLock, Preserve)
                    {
                        Offset (0x54), 
                        VPWR,   8
                    }

                    Name (_S3D, 0x03)  // _S3D: S3 Device State
                    Method (_INI, 0, NotSerialized)  // _INI: Initialize
                    {
                        \VUPS (0x02)
                        VQDL = \VCDL
                        VQDC = \VCDC
                        VQDT = \VCDT
                        VQDD = \VCDD
                    }

                    Method (_PS0, 0, NotSerialized)  // _PS0: Power State 0
                    {
                        Noop
                    }

                    Method (_PS1, 0, NotSerialized)  // _PS1: Power State 1
                    {
                        Noop
                    }

                    Method (_PS2, 0, NotSerialized)  // _PS2: Power State 2
                    {
                        Noop
                    }

                    Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
                    {
                        Noop
                    }

                    Method (VSWT, 0, NotSerialized)
                    {
                        If (\WVIS)
                        {
                            Local0 = \VEVT (0x07)
                        }
                        Else
                        {
                            Local0 = \VEVT (0x05)
                        }

                        Local1 = (0x0F & Local0)
                        If (Local1)
                        {
                            ASWT (Local1, 0x01)
                        }
                    }

                    Method (VLOC, 1, NotSerialized)
                    {
                        If ((Arg0 == \_SB.LID._LID ()))
                        {
                            \VSLD (Arg0)
                            If ((VPWR == 0x00))
                            {
                                If (Arg0)
                                {
                                    Local0 = \VEVT (0x01)
                                }
                                Else
                                {
                                    Local0 = \VEVT (0x02)
                                }

                                Local1 = (0x0F & Local0)
                                If (Local1)
                                {
                                    ASWT (Local1, 0x00)
                                }
                            }
                        }
                    }

                    Method (_DOS, 1, NotSerialized)  // _DOS: Disable Output Switching
                    {
                        If ((Arg0 == 0x02))
                        {
                            Local0 = 0x14
                            While (Local0)
                            {
                                Local0--
                                Acquire (MDGS, 0xFFFF)
                                If ((0x00 == MSWT))
                                {
                                    MSWT = 0x01
                                    Local0 = 0x00
                                    VDEE = Arg0
                                }

                                Release (MDGS)
                                Sleep (0xC8)
                            }
                        }
                        Else
                        {
                            Acquire (MDGS, 0xFFFF)
                            If ((VDEE == 0x02))
                            {
                                MSWT = 0x00
                            }

                            If ((Arg0 > 0x02))
                            {
                                VDEE = 0x01
                            }
                            Else
                            {
                                VDEE = Arg0
                            }

                            Release (MDGS)
                        }
                    }

                    Method (_DOD, 0, NotSerialized)  // _DOD: Display Output Devices
                    {
                        Return (Package (0x03)
                        {
                            0x0100, 
                            0x0210, 
                            0x0110
                        })
                    }

                    Method (ASWT, 2, NotSerialized)
                    {
                        If ((0x01 == VDEE))
                        {
                            Local1 = (0x01 & Arg1)
                            \VSDS (Arg0, Local1)
                        }
                        Else
                        {
                            Local0 = 0x14
                            While (Local0)
                            {
                                Local0--
                                Acquire (MDGS, 0xFFFF)
                                If ((0x00 == MSWT))
                                {
                                    Local0 = 0x00
                                    If ((0x01 & Arg1))
                                    {
                                        VUPC = 0x01
                                    }
                                    Else
                                    {
                                        VUPC = 0x00
                                    }

                                    If ((0x01 & Arg0))
                                    {
                                        VQDL = 0x01
                                    }
                                    Else
                                    {
                                        VQDL = 0x00
                                    }

                                    If ((0x02 & Arg0))
                                    {
                                        VQDC = 0x01
                                    }
                                    Else
                                    {
                                        VQDC = 0x00
                                    }

                                    If ((0x08 & Arg0))
                                    {
                                        VQDD = 0x01
                                    }
                                    Else
                                    {
                                        VQDD = 0x00
                                    }
                                }

                                Release (MDGS)
                                Sleep (0xC8)
                            }

                            If ((0x02 & Arg1))
                            {
                                Notify (VID, 0x81) // Information Change
                            }
                            Else
                            {
                                Notify (VID, 0x80) // Status Change
                            }
                        }
                    }

                    Method (VDSW, 1, NotSerialized)
                    {
                        If ((VPWR == 0x00))
                        {
                            If (Arg0)
                            {
                                Local0 = \VEVT (0x03)
                            }
                            Else
                            {
                                Local0 = \VEVT (0x04)
                            }

                            Local1 = (0x0F & Local0)
                            If (Local1)
                            {
                                ASWT (Local1, 0x00)
                            }
                        }
                    }

                    Device (LCD0)
                    {
                        Name (_ADR, 0x0110)  // _ADR: Address
                        Method (_DCS, 0, NotSerialized)  // _DCS: Display Current Status
                        {
                            \VUPS (0x00)
                            If (\VCDL)
                            {
                                Return (0x1F)
                            }
                            Else
                            {
                                Return (0x1D)
                            }
                        }

                        Method (_DDC, 1, NotSerialized)  // _DDC: Display Data Current
                        {
                            \VDDC ()
                            If ((Arg0 == 0x01))
                            {
                                Return (\DDC1)
                            }
                            Else
                            {
                                If ((Arg0 == 0x02))
                                {
                                    Return (\DDC2)
                                }
                                Else
                                {
                                    Return (0x00)
                                }
                            }
                        }

                        Method (_DGS, 0, NotSerialized)  // _DGS: Display Graphics State
                        {
                            Return (VQDL) /* \_SB_.PCI0.AGP_.VQDL */
                        }

                        Method (_DSS, 1, NotSerialized)  // _DSS: Device Set State
                        {
                            VSDL = (Arg0 & 0x01)
                            If ((Arg0 & 0x80000000))
                            {
                                If ((Arg0 & 0x40000000))
                                {
                                    DSWT (0x02)
                                }
                                Else
                                {
                                    DSWT (0x01)
                                }
                            }
                        }
                    }

                    Device (CRT0)
                    {
                        Name (_ADR, 0x0100)  // _ADR: Address
                        Method (_DCS, 0, NotSerialized)  // _DCS: Display Current Status
                        {
                            \VUPS (0x01)
                            If (\VCSS)
                            {
                                If (\VCDC)
                                {
                                    Return (0x1F)
                                }
                                Else
                                {
                                    Return (0x1D)
                                }
                            }
                            Else
                            {
                                If (\VCDC)
                                {
                                    Return (0x0F)
                                }
                                Else
                                {
                                    Return (0x0D)
                                }
                            }
                        }

                        Method (_DGS, 0, NotSerialized)  // _DGS: Display Graphics State
                        {
                            Return (VQDC) /* \_SB_.PCI0.AGP_.VQDC */
                        }

                        Method (_DSS, 1, NotSerialized)  // _DSS: Device Set State
                        {
                            VSDC = (Arg0 & 0x01)
                            If ((Arg0 & 0x80000000))
                            {
                                If ((Arg0 & 0x40000000))
                                {
                                    DSWT (0x02)
                                }
                                Else
                                {
                                    DSWT (0x01)
                                }
                            }
                        }
                    }

                    Device (DVI0)
                    {
                        Name (_ADR, 0x0210)  // _ADR: Address
                        Method (_DCS, 0, NotSerialized)  // _DCS: Display Current Status
                        {
                            \VUPS (0x00)
                            If (\VCDD)
                            {
                                Return (0x1F)
                            }
                            Else
                            {
                                Return (0x1D)
                            }
                        }

                        Method (_DGS, 0, NotSerialized)  // _DGS: Display Graphics State
                        {
                            Return (VQDD) /* \_SB_.PCI0.AGP_.VQDD */
                        }

                        Method (_DSS, 1, NotSerialized)  // _DSS: Device Set State
                        {
                            VSDD = (Arg0 & 0x01)
                            If ((Arg0 & 0x80000000))
                            {
                                If ((Arg0 & 0x40000000))
                                {
                                    DSWT (0x02)
                                }
                                Else
                                {
                                    DSWT (0x01)
                                }
                            }
                        }
                    }

                    Method (DSWT, 1, NotSerialized)
                    {
                        If (VSDL)
                        {
                            Local0 = 0x01
                        }
                        Else
                        {
                            Local0 = 0x00
                        }

                        If (VSDC)
                        {
                            Local0 |= 0x02
                        }

                        If (VSDD)
                        {
                            Local0 |= 0x08
                        }

                        If (Local0)
                        {
                            If (VUPC)
                            {
                                \VSDS (Local0, Arg0)
                            }
                        }
                        Else
                        {
                            Noop
                        }
                    }
                }

                OperationRegion (PEGC, PCI_Config, 0x00, 0x0100)
                Field (PEGC, DWordAcc, NoLock, Preserve)
                {
                    Offset (0xEC), 
                    GMGP,   1, 
                    HPGP,   1, 
                    PMGP,   1
                }
            }

            Device (IGBE)
            {
                Name (_ADR, 0x00190000)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x0D, 
                    0x04
                })
                Method (_INI, 0, NotSerialized)  // _INI: Initialize
                {
                    ABWA (0x00)
                }

                Method (ABWA, 1, NotSerialized)
                {
                    Local0 = \ACBS (Arg0)
                }
            }

            Device (EXP0)
            {
                Name (_ADR, 0x001C0000)  // _ADR: Address
                Name (RID, 0x00)
                OperationRegion (P0CS, PCI_Config, 0x00, 0x0100)
                Field (P0CS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x60), 
                    RID0,   16, 
                    PSP0,   1, 
                    PPP0,   1
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x09, 
                    0x04
                })
                Name (LPRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        \_SB.LNKA, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        \_SB.LNKB, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        \_SB.LNKC, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        \_SB.LNKD, 
                        0x00
                    }
                })
                Name (APRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        0x00, 
                        0x10
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        0x00, 
                        0x11
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        0x00, 
                        0x12
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        0x00, 
                        0x13
                    }
                })
                Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
                {
                    If (\GPIC)
                    {
                        Return (APRT) /* \_SB_.PCI0.EXP0.APRT */
                    }
                    Else
                    {
                        Return (LPRT) /* \_SB_.PCI0.EXP0.LPRT */
                    }
                }
            }

            Device (EXP1)
            {
                Name (_ADR, 0x001C0001)  // _ADR: Address
                Name (RID, 0x00)
                OperationRegion (P1CS, PCI_Config, 0x00, 0x0100)
                Field (P1CS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x60), 
                    RID1,   16, 
                    PSP1,   1, 
                    PPP1,   1
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x09, 
                    0x04
                })
                Name (LPRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        \_SB.LNKB, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        \_SB.LNKC, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        \_SB.LNKD, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        \_SB.LNKA, 
                        0x00
                    }
                })
                Name (APRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        0x00, 
                        0x11
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        0x00, 
                        0x12
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        0x00, 
                        0x13
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        0x00, 
                        0x10
                    }
                })
                Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
                {
                    If (\GPIC)
                    {
                        Return (APRT) /* \_SB_.PCI0.EXP1.APRT */
                    }
                    Else
                    {
                        Return (LPRT) /* \_SB_.PCI0.EXP1.LPRT */
                    }
                }
            }

            Device (EXP2)
            {
                Name (_ADR, 0x001C0002)  // _ADR: Address
                Name (RID, 0x00)
                OperationRegion (P2CS, PCI_Config, 0x00, 0x0100)
                Field (P2CS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x60), 
                    RID2,   16, 
                    PSP2,   1, 
                    PPP2,   1
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x09, 
                    0x04
                })
                Name (LPRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        \_SB.LNKC, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        \_SB.LNKD, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        \_SB.LNKA, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        \_SB.LNKB, 
                        0x00
                    }
                })
                Name (APRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        0x00, 
                        0x12
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        0x00, 
                        0x13
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        0x00, 
                        0x10
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        0x00, 
                        0x11
                    }
                })
                Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
                {
                    If (\GPIC)
                    {
                        Return (APRT) /* \_SB_.PCI0.EXP2.APRT */
                    }
                    Else
                    {
                        Return (LPRT) /* \_SB_.PCI0.EXP2.LPRT */
                    }
                }
            }

            Device (EXP3)
            {
                Name (_ADR, 0x001C0003)  // _ADR: Address
                Name (RID, 0x00)
                Name (XCPF, 0x00)
                OperationRegion (P3CS, PCI_Config, 0x00, 0x0100)
                Field (P3CS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x5A), 
                    ABP,    1, 
                        ,   2, 
                    PDC,    1, 
                        ,   2, 
                    PDS,    1, 
                    Offset (0x5B), 
                    Offset (0x60), 
                    RID3,   16, 
                    PSP3,   1, 
                    PPP3,   1, 
                    Offset (0xDB), 
                        ,   6, 
                    HPCE,   1, 
                    PMCE,   1, 
                    Offset (0xDF), 
                        ,   6, 
                    HPCS,   1, 
                    PMCS,   1
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x09, 
                    0x04
                })
                Name (LPRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        \_SB.LNKD, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        \_SB.LNKA, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        \_SB.LNKB, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        \_SB.LNKC, 
                        0x00
                    }
                })
                Name (APRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        0x00, 
                        0x13
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        0x00, 
                        0x10
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        0x00, 
                        0x11
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        0x00, 
                        0x12
                    }
                })
                Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
                {
                    If (\GPIC)
                    {
                        Return (APRT) /* \_SB_.PCI0.EXP3.APRT */
                    }
                    Else
                    {
                        Return (LPRT) /* \_SB_.PCI0.EXP3.LPRT */
                    }
                }

                Device (EXUP)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    Method (_RMV, 0, NotSerialized)  // _RMV: Removal Status
                    {
                        Return (0x01)
                    }
                }
            }

            Device (EXP4)
            {
                Name (_ADR, 0x001C0004)  // _ADR: Address
                Name (RID, 0x00)
                OperationRegion (P4CS, PCI_Config, 0x00, 0x0100)
                Field (P4CS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x60), 
                    RID4,   16, 
                    PSP4,   1, 
                    PPP4,   1, 
                    Offset (0xDF), 
                        ,   6, 
                    HPS4,   1, 
                    PMS4,   1
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x09, 
                    0x04
                })
                Name (LPRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        \_SB.LNKA, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        \_SB.LNKB, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        \_SB.LNKC, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        \_SB.LNKD, 
                        0x00
                    }
                })
                Name (APRT, Package (0x04)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        0x00, 
                        0x10
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        0x00, 
                        0x11
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        0x00, 
                        0x12
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        0x00, 
                        0x13
                    }
                })
                Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
                {
                    If (\GPIC)
                    {
                        Return (APRT) /* \_SB_.PCI0.EXP4.APRT */
                    }
                    Else
                    {
                        Return (LPRT) /* \_SB_.PCI0.EXP4.LPRT */
                    }
                }

                Device (EXPD)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                }
            }

            Device (PCI1)
            {
                Name (_ADR, 0x001E0000)  // _ADR: Address
                Name (_S3D, 0x02)  // _S3D: S3 Device State
                Name (RID, 0x00)
                Name (LPRT, Package (0x08)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        \_SB.LNKA, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        \_SB.LNKB, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        \_SB.LNKC, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        \_SB.LNKD, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0x0001FFFF, 
                        0x00, 
                        \_SB.LNKA, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0x0002FFFF, 
                        0x00, 
                        \_SB.LNKF, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0x0002FFFF, 
                        0x01, 
                        \_SB.LNKG, 
                        0x00
                    }, 

                    Package (0x04)
                    {
                        0x0008FFFF, 
                        0x00, 
                        \_SB.LNKE, 
                        0x00
                    }
                })
                Name (APRT, Package (0x08)
                {
                    Package (0x04)
                    {
                        0xFFFF, 
                        0x00, 
                        0x00, 
                        0x10
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x01, 
                        0x00, 
                        0x11
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x02, 
                        0x00, 
                        0x12
                    }, 

                    Package (0x04)
                    {
                        0xFFFF, 
                        0x03, 
                        0x00, 
                        0x13
                    }, 

                    Package (0x04)
                    {
                        0x0001FFFF, 
                        0x00, 
                        0x00, 
                        0x10
                    }, 

                    Package (0x04)
                    {
                        0x0002FFFF, 
                        0x00, 
                        0x00, 
                        0x15
                    }, 

                    Package (0x04)
                    {
                        0x0002FFFF, 
                        0x01, 
                        0x00, 
                        0x16
                    }, 

                    Package (0x04)
                    {
                        0x0008FFFF, 
                        0x00, 
                        0x00, 
                        0x14
                    }
                })
                Method (_PRT, 0, NotSerialized)  // _PRT: PCI Routing Table
                {
                    If (\GPIC)
                    {
                        Return (APRT) /* \_SB_.PCI0.PCI1.APRT */
                    }
                    Else
                    {
                        Return (LPRT) /* \_SB_.PCI0.PCI1.LPRT */
                    }
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x0B, 
                    0x04
                })
                Device (CDBS)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    Method (_S3D, 0, NotSerialized)  // _S3D: S3 Device State
                    {
                        If (\WMEF)
                        {
                            Return (0x02)
                        }

                        Return (0x03)
                    }

                    Name (_SUN, 0x01)  // _SUN: Slot User Number
                }
            }

            Device (IDE0)
            {
                Name (_ADR, 0x001F0001)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (IDCS, PCI_Config, 0x00, 0x0100)
                Field (IDCS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x40), 
                    PFT0,   1, 
                    PIE0,   1, 
                    PPE0,   1, 
                    PDT0,   1, 
                    PFT1,   1, 
                    PIE1,   1, 
                    PPE1,   1, 
                    PDT1,   1, 
                    PRC0,   2, 
                        ,   2, 
                    PIS0,   2, 
                    PSIE,   1, 
                    PIDE,   1, 
                    SFT0,   1, 
                    SIE0,   1, 
                    SPE0,   1, 
                    SDT0,   1, 
                    SFT1,   1, 
                    SIE1,   1, 
                    SPE1,   1, 
                    SDT1,   1, 
                    SRC0,   2, 
                        ,   2, 
                    SIS0,   2, 
                    SSIE,   1, 
                    SIDE,   1, 
                    PRC1,   2, 
                    PIS1,   2, 
                    SRC1,   2, 
                    SIS1,   2, 
                    Offset (0x48), 
                    PSD0,   1, 
                    PSD1,   1, 
                    SSD0,   1, 
                    SSD1,   1, 
                    Offset (0x4A), 
                    PCT0,   2, 
                        ,   2, 
                    PCT1,   2, 
                    Offset (0x4B), 
                    SCT0,   2, 
                        ,   2, 
                    SCT1,   2, 
                    Offset (0x4C), 
                    Offset (0x54), 
                    PCB0,   1, 
                    PCB1,   1, 
                    SCB0,   1, 
                    SCB1,   1, 
                    PCR0,   1, 
                    PCR1,   1, 
                    SCR0,   1, 
                    SCR1,   1, 
                        ,   2, 
                    WRPP,   1, 
                        ,   1, 
                    FPB0,   1, 
                    FPB1,   1, 
                    FSB0,   1, 
                    FSB1,   1, 
                    PSIG,   2, 
                    SSIG,   2
                }

                Field (IDCS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x40), 
                    PTI0,   4, 
                    PTI1,   4, 
                    Offset (0x42), 
                    STI0,   4, 
                    STI1,   4
                }

                Method (GPCT, 4, NotSerialized)
                {
                    If (!(Arg0 | Arg1))
                    {
                        Return (0x00)
                    }

                    If ((!Arg0 && Arg1))
                    {
                        Return (0x0384)
                    }

                    Return (((0x09 - (Arg2 + Arg3)) * 0x1E))
                }

                Method (GDCT, 4, NotSerialized)
                {
                    If (!Arg0)
                    {
                        Return (0x00)
                    }

                    If (Arg1)
                    {
                        Return (0x14)
                    }

                    If (Arg2)
                    {
                        Return (((0x04 - Arg3) * 0x0F))
                    }

                    Return (((0x04 - Arg3) * 0x1E))
                }

                Method (MTIM, 2, NotSerialized)
                {
                    Local0 = 0x00
                    If (Arg0)
                    {
                        Local0 |= 0x01
                    }

                    If ((Arg0 >= 0x02))
                    {
                        Local0 |= 0x02
                    }

                    If (!Arg1)
                    {
                        Local0 |= 0x04
                    }

                    If (!Arg0)
                    {
                        Local0 |= 0x08
                    }

                    Return (Local0)
                }

                Method (MISP, 1, NotSerialized)
                {
                    If (!Arg0)
                    {
                        Return (0x00)
                    }

                    If ((Arg0 <= 0x02))
                    {
                        Return (0x01)
                    }

                    Return (0x02)
                }

                Method (MRCT, 1, NotSerialized)
                {
                    If ((Arg0 <= 0x02))
                    {
                        Return (0x00)
                    }

                    If ((Arg0 == 0x03))
                    {
                        Return (0x01)
                    }

                    Return (0x03)
                }

                Device (PRIM)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    Name (BGTM, Buffer (0x14) {})
                    CreateDWordField (BGTM, 0x00, GTP0)
                    CreateDWordField (BGTM, 0x04, GTD0)
                    CreateDWordField (BGTM, 0x08, GTP1)
                    CreateDWordField (BGTM, 0x0C, GTD1)
                    CreateDWordField (BGTM, 0x10, GTMF)
                    Name (BPI0, 0x00)
                    Name (BDM0, 0x00)
                    Name (BPI1, 0x00)
                    Name (BDM1, 0x00)
                    Name (DRE0, 0x00)
                    Name (DRE1, 0x00)
                    Name (DIP0, 0x00)
                    Name (DIP1, 0x00)
                    Method (_GTM, 0, NotSerialized)  // _GTM: Get Timing Mode
                    {
                        GTP0 = GPCT (PFT0, PDT0, PIS0, PRC0)
                        GTD0 = GDCT (PSD0, FPB0, PCB0, PCT0)
                        If (!GTD0)
                        {
                            GTD0 = GTP0 /* \_SB_.PCI0.IDE0.PRIM.GTP0 */
                        }

                        If (PSIE)
                        {
                            GTP1 = GPCT (PFT1, PDT1, PIS1, PRC1)
                            GTD1 = GDCT (PSD1, FPB1, PCB1, PCT1)
                            If (!GTD1)
                            {
                                GTD1 = GTP1 /* \_SB_.PCI0.IDE0.PRIM.GTP1 */
                            }
                        }
                        Else
                        {
                            GTP1 = 0x00
                            GTD1 = 0x00
                        }

                        GTMF = 0x00
                        If (PSD0)
                        {
                            GTMF |= 0x01
                        }

                        If (!GTP0)
                        {
                            GTMF |= 0x01
                            GTP0 = 0x78
                            GTD0 = 0x14
                        }

                        If (PIE0)
                        {
                            GTMF |= 0x02
                        }

                        If (PSD1)
                        {
                            GTMF |= 0x04
                        }

                        If (PIE1)
                        {
                            GTMF |= 0x08
                        }

                        GTMF |= 0x10
                        Return (BGTM) /* \_SB_.PCI0.IDE0.PRIM.BGTM */
                    }

                    Method (_STM, 3, NotSerialized)  // _STM: Set Timing Mode
                    {
                        CreateDWordField (Arg0, 0x00, STP0)
                        CreateDWordField (Arg0, 0x04, STD0)
                        CreateDWordField (Arg0, 0x08, STP1)
                        CreateDWordField (Arg0, 0x0C, STD1)
                        CreateDWordField (Arg0, 0x10, STMF)
                        DRE0 = 0x00
                        DIP0 = 0x00
                        If ((SizeOf (Arg1) == 0x0200))
                        {
                            CreateWordField (Arg1, 0x00, M000)
                            CreateWordField (Arg1, 0x62, M049)
                            CreateWordField (Arg1, 0x66, M051)
                            CreateWordField (Arg1, 0x6A, M053)
                            CreateWordField (Arg1, 0x7C, M062)
                            CreateWordField (Arg1, 0x7E, M063)
                            CreateWordField (Arg1, 0x80, M064)
                            CreateWordField (Arg1, 0x82, M065)
                            CreateWordField (Arg1, 0x88, M068)
                            CreateWordField (Arg1, 0x9C, M078)
                            CreateWordField (Arg1, 0xAC, M086)
                            CreateWordField (Arg1, 0xB0, M088)
                            CreateWordField (Arg1, 0xEE, M119)
                            CreateWordField (Arg1, 0x0128, M148)
                            If (((M148 & 0xC000) == 0x4000))
                            {
                                If ((M148 & 0x04))
                                {
                                    DRE0 = 0x01
                                }
                            }

                            If ((M086 & 0x8000))
                            {
                                If ((M119 & 0x01))
                                {
                                    DRE0 = 0x01
                                }
                            }

                            If (\W98F)
                            {
                                STD0 = \UUDM (M053, M088)
                                If (STD0)
                                {
                                    STMF |= 0x01
                                }
                                Else
                                {
                                    STMF &= 0xFE
                                }

                                STP0 = \UMDM (M053, M063, M062, M065)
                                If (!STP0)
                                {
                                    STP0 = \UPIO (M053, M064, M051, M068)
                                }

                                If ((M049 & 0x0800))
                                {
                                    STMF |= 0x02
                                }
                                Else
                                {
                                    STMF &= 0xFD
                                }
                            }

                            Local0 = \DPIO (STP0, (STMF & 0x02))
                            Local1 = \DUDM (STD0, (STMF & 0x01))
                            If ((\_SB.PCI0.LPC.EC.BGID (0x00) >= 0x0C))
                            {
                                Local0 = 0x00
                                Local1 = 0xFF
                            }

                            PTI0 = MTIM (Local0, (M000 & 0x8000))
                            PIS0 = MISP (Local0)
                            PRC0 = MRCT (Local0)
                            If ((Local1 == 0xFF))
                            {
                                PSD0 = 0x00
                            }
                            Else
                            {
                                PSD0 = 0x01
                                If ((Local1 <= 0x02))
                                {
                                    PCT0 = Local1
                                }
                                Else
                                {
                                    If ((Local1 & 0x01))
                                    {
                                        PCT0 = 0x01
                                    }
                                    Else
                                    {
                                        PCT0 = 0x02
                                    }
                                }

                                If ((Local1 >= 0x03))
                                {
                                    PCB0 = 0x01
                                }
                                Else
                                {
                                    PCB0 = 0x00
                                }

                                If ((Local1 == 0x05))
                                {
                                    FPB0 = 0x01
                                }
                                Else
                                {
                                    FPB0 = 0x00
                                }

                                PCR0 = 0x01
                            }

                            BDM0 = \FDMA (Local0, Local1)
                            BPI0 = \FPIO (Local0)
                        }

                        If ((SizeOf (Arg2) == 0x0200))
                        {
                            CreateWordField (Arg2, 0x00, S000)
                            CreateWordField (Arg2, 0x62, S049)
                            CreateWordField (Arg2, 0x66, S051)
                            CreateWordField (Arg2, 0x6A, S053)
                            CreateWordField (Arg2, 0x7C, S062)
                            CreateWordField (Arg2, 0x7E, S063)
                            CreateWordField (Arg2, 0x80, S064)
                            CreateWordField (Arg2, 0x82, S065)
                            CreateWordField (Arg2, 0x88, S068)
                            CreateWordField (Arg2, 0xB0, S088)
                            If (\W98F)
                            {
                                STD1 = \UUDM (S053, S088)
                                If (STD1)
                                {
                                    STMF |= 0x04
                                }
                                Else
                                {
                                    STMF &= 0xFB
                                }

                                STP1 = \UMDM (S053, S063, S062, S065)
                                If (!STP1)
                                {
                                    STP1 = \UPIO (S053, S064, S051, S068)
                                }

                                If ((S049 & 0x0800))
                                {
                                    STMF |= 0x08
                                }
                                Else
                                {
                                    STMF &= 0xF7
                                }
                            }

                            Local0 = \DPIO (STP1, (STMF & 0x08))
                            Local1 = \DUDM (STD1, (STMF & 0x04))
                            If (STP1)
                            {
                                PTI1 = MTIM (Local0, (S000 & 0x8000))
                                If ((STMF & 0x10))
                                {
                                    PIS1 = MISP (Local0)
                                    PRC1 = MRCT (Local0)
                                    PSIE = 0x01
                                }
                            }
                            Else
                            {
                                PTI1 = 0x00
                                PSIE = 0x00
                            }

                            If ((Local1 == 0xFF))
                            {
                                PSD1 = 0x00
                            }
                            Else
                            {
                                PSD1 = 0x01
                                If ((Local1 <= 0x02))
                                {
                                    PCT1 = Local1
                                }
                                Else
                                {
                                    If ((Local1 & 0x01))
                                    {
                                        PCT1 = 0x01
                                    }
                                    Else
                                    {
                                        PCT1 = 0x02
                                    }
                                }

                                If ((Local1 >= 0x03))
                                {
                                    PCB1 = 0x01
                                }
                                Else
                                {
                                    PCB1 = 0x00
                                }

                                If ((Local1 == 0x05))
                                {
                                    FPB1 = 0x01
                                }
                                Else
                                {
                                    FPB1 = 0x00
                                }

                                PCR1 = 0x01
                            }

                            BDM1 = \FDMA (Local0, Local1)
                            BPI1 = \FPIO (Local0)
                        }
                    }

                    Device (MSTR)
                    {
                        Name (_ADR, 0x00)  // _ADR: Address
                        Name (HDTF, Buffer (0x1C)
                        {
                            /* 0000 */  0x02, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF, 0x00,  /* ........ */
                            /* 0008 */  0x00, 0x00, 0x00, 0x00, 0xA0, 0xF5, 0x03, 0x00,  /* ........ */
                            /* 0010 */  0x00, 0x00, 0x00, 0xA0, 0xEF, 0x03, 0x00, 0x00,  /* ........ */
                            /* 0018 */  0x00, 0x00, 0xA0, 0xEF                           /* .... */
                        })
                        CreateByteField (HDTF, 0x0F, HDMA)
                        CreateByteField (HDTF, 0x16, HPIO)
                        CreateByteField (HDTF, 0x0D, HFLC)
                        Name (ERTF, Buffer (0x23)
                        {
                            /* 0000 */  0x02, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF, 0x00,  /* ........ */
                            /* 0008 */  0x00, 0x00, 0x00, 0x00, 0xA0, 0xF5, 0x03, 0x00,  /* ........ */
                            /* 0010 */  0x00, 0x00, 0x00, 0xA0, 0xEF, 0x03, 0x00, 0x00,  /* ........ */
                            /* 0018 */  0x00, 0x00, 0xA0, 0xEF, 0x5F, 0x00, 0x00, 0x00,  /* ...._... */
                            /* 0020 */  0x00, 0xA0, 0xEF                                 /* ... */
                        })
                        CreateByteField (ERTF, 0x0F, EDMA)
                        CreateByteField (ERTF, 0x16, EPIO)
                        CreateByteField (ERTF, 0x0D, EFLC)
                        Name (HPTF, Buffer (0x23)
                        {
                            /* 0000 */  0x02, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF, 0x00,  /* ........ */
                            /* 0008 */  0x00, 0x00, 0x00, 0x00, 0xA0, 0xF5, 0x03, 0x00,  /* ........ */
                            /* 0010 */  0x00, 0x00, 0x00, 0xA0, 0xEF, 0x03, 0x00, 0x00,  /* ........ */
                            /* 0018 */  0x00, 0x00, 0xA0, 0xEF, 0x10, 0x03, 0x00, 0x00,  /* ........ */
                            /* 0020 */  0x00, 0xA0, 0xEF                                 /* ... */
                        })
                        CreateByteField (HPTF, 0x0F, PDMA)
                        CreateByteField (HPTF, 0x16, PPIO)
                        CreateByteField (HPTF, 0x0D, PFLC)
                        Name (HXTF, Buffer (0x2A)
                        {
                            /* 0000 */  0x02, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF, 0x00,  /* ........ */
                            /* 0008 */  0x00, 0x00, 0x00, 0x00, 0xA0, 0xF5, 0x03, 0x00,  /* ........ */
                            /* 0010 */  0x00, 0x00, 0x00, 0xA0, 0xEF, 0x03, 0x00, 0x00,  /* ........ */
                            /* 0018 */  0x00, 0x00, 0xA0, 0xEF, 0x5F, 0x00, 0x00, 0x00,  /* ...._... */
                            /* 0020 */  0x00, 0xA0, 0xEF, 0x10, 0x03, 0x00, 0x00, 0x00,  /* ........ */
                            /* 0028 */  0xA0, 0xEF                                       /* .. */
                        })
                        CreateByteField (HXTF, 0x0F, XDMA)
                        CreateByteField (HXTF, 0x16, XPIO)
                        CreateByteField (HXTF, 0x0D, XFLC)
                        Name (IDTF, Buffer (0x0E)
                        {
                            /* 0000 */  0x03, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF, 0x03,  /* ........ */
                            /* 0008 */  0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF               /* ...... */
                        })
                        CreateByteField (IDTF, 0x01, IDMA)
                        CreateByteField (IDTF, 0x08, IPIO)
                        Name (DDTF, Buffer (0x1C)
                        {
                            /* 0000 */  0x03, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF, 0x03,  /* ........ */
                            /* 0008 */  0x00, 0x00, 0x00, 0x00, 0xA0, 0xEF, 0x00, 0x00,  /* ........ */
                            /* 0010 */  0x00, 0x00, 0x00, 0xA0, 0xE3, 0x00, 0x00, 0x00,  /* ........ */
                            /* 0018 */  0x00, 0x00, 0xA0, 0xE3                           /* .... */
                        })
                        CreateByteField (DDTF, 0x01, DDMA)
                        CreateByteField (DDTF, 0x08, DPIO)
                        CreateByteField (DDTF, 0x0F, DTAT)
                        CreateByteField (DDTF, 0x16, DTFT)
                        Method (_GTF, 0, NotSerialized)  // _GTF: Get Task File
                        {
                            Local0 = \_SB.PCI0.LPC.EC.BGID (0x00)
                            If (\OSSS)
                            {
                                HFLC = 0xE1
                                EFLC = 0xE1
                                PFLC = 0xE1
                                XFLC = 0xE1
                            }

                            If ((Local0 == 0x06))
                            {
                                If (^^DRE0)
                                {
                                    If (^^DIP0)
                                    {
                                        XDMA = ^^BDM0 /* \_SB_.PCI0.IDE0.PRIM.BDM0 */
                                        XPIO = ^^BPI0 /* \_SB_.PCI0.IDE0.PRIM.BPI0 */
                                        Return (HXTF) /* \_SB_.PCI0.IDE0.PRIM.MSTR.HXTF */
                                    }
                                    Else
                                    {
                                        EDMA = ^^BDM0 /* \_SB_.PCI0.IDE0.PRIM.BDM0 */
                                        EPIO = ^^BPI0 /* \_SB_.PCI0.IDE0.PRIM.BPI0 */
                                        Return (ERTF) /* \_SB_.PCI0.IDE0.PRIM.MSTR.ERTF */
                                    }
                                }

                                If (^^DIP0)
                                {
                                    PDMA = ^^BDM0 /* \_SB_.PCI0.IDE0.PRIM.BDM0 */
                                    PPIO = ^^BPI0 /* \_SB_.PCI0.IDE0.PRIM.BPI0 */
                                    Return (HPTF) /* \_SB_.PCI0.IDE0.PRIM.MSTR.HPTF */
                                }

                                HDMA = ^^BDM0 /* \_SB_.PCI0.IDE0.PRIM.BDM0 */
                                HPIO = ^^BPI0 /* \_SB_.PCI0.IDE0.PRIM.BPI0 */
                                Return (HDTF) /* \_SB_.PCI0.IDE0.PRIM.MSTR.HDTF */
                            }

                            Local1 = Zero
                            If ((Local0 == 0x03))
                            {
                                Local1 = One
                            }

                            If ((Local0 == 0x0A))
                            {
                                Local1 = One
                            }

                            If ((Local0 == 0x0B))
                            {
                                Local1 = One
                            }

                            If (Local1)
                            {
                                DTFT = \CDFL
                                DTAT = \CDAH
                                DDMA = ^^BDM0 /* \_SB_.PCI0.IDE0.PRIM.BDM0 */
                                DPIO = ^^BPI0 /* \_SB_.PCI0.IDE0.PRIM.BPI0 */
                                Return (DDTF) /* \_SB_.PCI0.IDE0.PRIM.MSTR.DDTF */
                            }
                            Else
                            {
                                IDMA = ^^BDM0 /* \_SB_.PCI0.IDE0.PRIM.BDM0 */
                                IPIO = ^^BPI0 /* \_SB_.PCI0.IDE0.PRIM.BPI0 */
                                Return (IDTF) /* \_SB_.PCI0.IDE0.PRIM.MSTR.IDTF */
                            }
                        }

                        Method (_EJ0, 1, NotSerialized)  // _EJx: Eject Device
                        {
                            \_SB.PCI0.LPC.EC.BEJ0 (Arg0)
                        }

                        Method (_STA, 0, NotSerialized)  // _STA: Status
                        {
                            If (\_SB.PCI0.LPC.EC.BSTA (0x01))
                            {
                                Return (0x0F)
                            }
                            Else
                            {
                                Return (0x00)
                            }
                        }
                    }
                }
            }

            Device (SATA)
            {
                Name (_ADR, 0x001F0002)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (IDCS, PCI_Config, 0x00, 0x0100)
                Field (IDCS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x40), 
                    PFT0,   1, 
                    PIE0,   1, 
                    PPE0,   1, 
                    PDT0,   1, 
                    PFT1,   1, 
                    PIE1,   1, 
                    PPE1,   1, 
                    PDT1,   1, 
                    PRC0,   2, 
                        ,   2, 
                    PIS0,   2, 
                    PSIE,   1, 
                    PIDE,   1, 
                    SFT0,   1, 
                    SIE0,   1, 
                    SPE0,   1, 
                    SDT0,   1, 
                    SFT1,   1, 
                    SIE1,   1, 
                    SPE1,   1, 
                    SDT1,   1, 
                    SRC0,   2, 
                        ,   2, 
                    SIS0,   2, 
                    SSIE,   1, 
                    SIDE,   1, 
                    PRC1,   2, 
                    PIS1,   2, 
                    SRC1,   2, 
                    SIS1,   2, 
                    Offset (0x48), 
                    PSD0,   1, 
                    PSD1,   1, 
                    SSD0,   1, 
                    SSD1,   1, 
                    Offset (0x4A), 
                    PCT0,   2, 
                        ,   2, 
                    PCT1,   2, 
                    Offset (0x4B), 
                    SCT0,   2, 
                        ,   2, 
                    SCT1,   2, 
                    Offset (0x4C), 
                    Offset (0x54), 
                    PCB0,   1, 
                    PCB1,   1, 
                    SCB0,   1, 
                    SCB1,   1, 
                    PCR0,   1, 
                    PCR1,   1, 
                    SCR0,   1, 
                    SCR1,   1, 
                        ,   2, 
                    WRPP,   1, 
                        ,   1, 
                    FPB0,   1, 
                    FPB1,   1, 
                    FSB0,   1, 
                    FSB1,   1, 
                    PSIG,   2, 
                    SSIG,   2
                }

                Field (IDCS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x40), 
                    PTI0,   4, 
                    PTI1,   4, 
                    Offset (0x42), 
                    STI0,   4, 
                    STI1,   4
                }

                Method (GPCT, 4, NotSerialized)
                {
                    If (!(Arg0 | Arg1))
                    {
                        Return (0x00)
                    }

                    If ((!Arg0 && Arg1))
                    {
                        Return (0x0384)
                    }

                    Return (((0x09 - (Arg2 + Arg3)) * 0x1E))
                }

                Method (GDCT, 4, NotSerialized)
                {
                    If (!Arg0)
                    {
                        Return (0x00)
                    }

                    If (Arg1)
                    {
                        Return (0x14)
                    }

                    If (Arg2)
                    {
                        Return (((0x04 - Arg3) * 0x0F))
                    }

                    Return (((0x04 - Arg3) * 0x1E))
                }

                Method (MTIM, 2, NotSerialized)
                {
                    Local0 = 0x00
                    If (Arg0)
                    {
                        Local0 |= 0x01
                    }

                    If ((Arg0 >= 0x02))
                    {
                        Local0 |= 0x02
                    }

                    If (!Arg1)
                    {
                        Local0 |= 0x04
                    }

                    If (!Arg0)
                    {
                        Local0 |= 0x08
                    }

                    Return (Local0)
                }

                Method (MISP, 1, NotSerialized)
                {
                    If (!Arg0)
                    {
                        Return (0x00)
                    }

                    If ((Arg0 <= 0x02))
                    {
                        Return (0x01)
                    }

                    Return (0x02)
                }

                Method (MRCT, 1, NotSerialized)
                {
                    If ((Arg0 <= 0x02))
                    {
                        Return (0x00)
                    }

                    If ((Arg0 == 0x03))
                    {
                        Return (0x01)
                    }

                    Return (0x03)
                }
            }

            Device (SMBU)
            {
                Name (_ADR, 0x001F0003)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
            }

            Device (USB0)
            {
                Name (_ADR, 0x001D0000)  // _ADR: Address
                Name (_S3D, 0x02)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (U0CS, PCI_Config, 0xC4, 0x04)
                Field (U0CS, DWordAcc, NoLock, Preserve)
                {
                    U0EN,   2, 
                    Offset (0x04)
                }

                Name (_PR0, Package (0x01)  // _PR0: Power Resources for D0
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR1, Package (0x01)  // _PR1: Power Resources for D1
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR2, Package (0x01)  // _PR2: Power Resources for D2
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PRW, Package (0x03)  // _PRW: Power Resources for Wake
                {
                    0x03, 
                    0x03, 
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
                {
                    If (Arg0)
                    {
                        U0EN = 0x03
                    }
                    Else
                    {
                        U0EN = 0x00
                    }

                    \_SB.PCI0.LPC.EC.PNST (Arg0)
                }
            }

            Device (USB1)
            {
                Name (_ADR, 0x001D0001)  // _ADR: Address
                Name (_S3D, 0x02)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (U1CS, PCI_Config, 0xC4, 0x04)
                Field (U1CS, DWordAcc, NoLock, Preserve)
                {
                    U1EN,   2, 
                    Offset (0x04)
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x04, 
                    0x03
                })
                Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
                {
                    If (Arg0)
                    {
                        U1EN = 0x03
                    }
                    Else
                    {
                        U1EN = 0x00
                    }
                }

                Device (URTH)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    Device (UPEX)
                    {
                        Name (_ADR, 0x02)  // _ADR: Address
                    }
                }
            }

            Device (USB2)
            {
                Name (_ADR, 0x001D0002)  // _ADR: Address
                Name (_S3D, 0x02)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (U2CS, PCI_Config, 0xC4, 0x04)
                Field (U2CS, DWordAcc, NoLock, Preserve)
                {
                    U2EN,   2, 
                    Offset (0x04)
                }

                Name (_PR0, Package (0x01)  // _PR0: Power Resources for D0
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR1, Package (0x01)  // _PR1: Power Resources for D1
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR2, Package (0x01)  // _PR2: Power Resources for D2
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PRW, Package (0x03)  // _PRW: Power Resources for Wake
                {
                    0x0C, 
                    0x03, 
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
                {
                    If (Arg0)
                    {
                        U2EN = 0x03
                    }
                    Else
                    {
                        U2EN = 0x00
                    }
                }
            }

            Device (USB3)
            {
                Name (_ADR, 0x001A0000)  // _ADR: Address
                Name (_S3D, 0x02)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (U3CS, PCI_Config, 0xC4, 0x04)
                Field (U3CS, DWordAcc, NoLock, Preserve)
                {
                    U3EN,   2, 
                    Offset (0x04)
                }

                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x0E, 
                    0x03
                })
                Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
                {
                    If (Arg0)
                    {
                        U3EN = 0x03
                    }
                    Else
                    {
                        U3EN = 0x00
                    }
                }
            }

            Device (USB4)
            {
                Name (_ADR, 0x001A0001)  // _ADR: Address
                Name (_S3D, 0x02)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (U4CS, PCI_Config, 0xC4, 0x04)
                Field (U4CS, DWordAcc, NoLock, Preserve)
                {
                    U4EN,   2, 
                    Offset (0x04)
                }

                Name (_PR0, Package (0x01)  // _PR0: Power Resources for D0
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR1, Package (0x01)  // _PR1: Power Resources for D1
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR2, Package (0x01)  // _PR2: Power Resources for D2
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PRW, Package (0x03)  // _PRW: Power Resources for Wake
                {
                    0x05, 
                    0x03, 
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
                {
                    If (Arg0)
                    {
                        U4EN = 0x03
                    }
                    Else
                    {
                        U4EN = 0x00
                    }
                }

                Device (URTH)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    Device (UPDK)
                    {
                        Name (_ADR, 0x02)  // _ADR: Address
                    }
                }
            }

            Device (EHC0)
            {
                Name (_ADR, 0x001D0007)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (U7CS, PCI_Config, 0x60, 0x04)
                Field (U7CS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x02), 
                    PWKI,   1, 
                    PWUC,   6, 
                    Offset (0x04)
                }

                Name (_PR0, Package (0x01)  // _PR0: Power Resources for D0
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR1, Package (0x01)  // _PR1: Power Resources for D1
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR2, Package (0x01)  // _PR2: Power Resources for D2
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Method (_INI, 0, NotSerialized)  // _INI: Initialize
                {
                    PWKI = 0x01
                    PWUC = 0x0F
                }

                Name (_PRW, Package (0x03)  // _PRW: Power Resources for Wake
                {
                    0x0D, 
                    0x03, 
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Device (URTH)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    Device (UPEX)
                    {
                        Name (_ADR, 0x04)  // _ADR: Address
                    }
                }
            }

            Device (EHC1)
            {
                Name (_ADR, 0x001A0007)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                OperationRegion (U8CS, PCI_Config, 0x60, 0x04)
                Field (U8CS, DWordAcc, NoLock, Preserve)
                {
                    Offset (0x02), 
                    PWKI,   1, 
                    PWUC,   4, 
                    Offset (0x04)
                }

                Name (_PR0, Package (0x01)  // _PR0: Power Resources for D0
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR1, Package (0x01)  // _PR1: Power Resources for D1
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Name (_PR2, Package (0x01)  // _PR2: Power Resources for D2
                {
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Method (_INI, 0, NotSerialized)  // _INI: Initialize
                {
                    PWKI = 0x01
                    PWUC = 0x0F
                }

                Name (_PRW, Package (0x03)  // _PRW: Power Resources for Wake
                {
                    0x0D, 
                    0x03, 
                    \_SB.PCI0.LPC.EC.PUBS
                })
                Device (URTH)
                {
                    Name (_ADR, 0x00)  // _ADR: Address
                    Device (UPDK)
                    {
                        Name (_ADR, 0x04)  // _ADR: Address
                    }
                }
            }

            Device (HDEF)
            {
                Name (_ADR, 0x001B0000)  // _ADR: Address
                Name (_S3D, 0x03)  // _S3D: S3 Device State
                Name (RID, 0x00)
                Name (_PRW, Package (0x02)  // _PRW: Power Resources for Wake
                {
                    0x0D, 
                    0x04
                })
                Method (_PSW, 1, NotSerialized)  // _PSW: Power State Wake
                {
                    Noop
                }
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Name (BDEV, 0xFF)
            Name (BSTS, 0x00)
            Name (BHKE, 0x00)
            Name (BXCN, 0x00)
            Method (_Q2C, 0, NotSerialized)  // _Qxx: EC Query
            {
                If ((SFLG & 0x0400))
                {
                    If ((BSTS == 0x00))
                    {
                        BDEV = BGID (0x00)
                        If (BXCN)
                        {
                            NXRE (BDEV)
                        }
                        Else
                        {
                            NBRE (BDEV)
                        }
                    }
                }
            }

            Method (_Q2D, 0, NotSerialized)  // _Qxx: EC Query
            {
                If ((SFLG & 0x0400))
                {
                    BDEV = BGID (0x00)
                    If (BXCN)
                    {
                        NXRC (BDEV)
                    }
                    Else
                    {
                        NBIN (BDEV)
                    }
                }
            }

            Method (_Q38, 0, NotSerialized)  // _Qxx: EC Query
            {
                If ((SFLG & 0x0400))
                {
                    Local0 = BGID (0x00)
                    If ((Local0 != BDEV))
                    {
                        If ((Local0 == 0x0F))
                        {
                            BDIS ()
                            If (BXCN)
                            {
                                Local0 = BDEV /* \_SB_.PCI0.LPC_.EC__.BDEV */
                                BDEV = 0x0F
                                NXEJ (Local0)
                            }
                            Else
                            {
                                NBEJ (BDEV)
                                BDEV = Local0
                            }
                        }
                        Else
                        {
                            If (HPBU)
                            {
                                If (BXCN)
                                {
                                    BDEV = Local0
                                    NXIN (Local0)
                                }
                            }
                            Else
                            {
                                BDEV = Local0
                                If (BXCN)
                                {
                                    NXRC (Local0)
                                }
                                Else
                                {
                                    NBIN (Local0)
                                }
                            }
                        }
                    }
                }
            }

            Method (NBRE, 1, NotSerialized)
            {
                If ((Arg0 < 0x0C))
                {
                    If ((\BIDE == 0x03))
                    {
                        Notify (\_SB.PCI0.SATA.SCND.MSTR, 0x03) // Eject Request
                    }
                    Else
                    {
                        Notify (\_SB.PCI0.IDE0.PRIM.MSTR, 0x03) // Eject Request
                    }
                }

                If ((Arg0 == 0x10))
                {
                    If ((HPAC || HB0A))
                    {
                        If (\WNTF)
                        {
                            Notify (\_SB.PCI0.LPC.EC.BAT1, 0x03) // Eject Request
                        }
                    }
                    Else
                    {
                        LED (0x04, 0xC0)
                        BEEP (0x0F)
                        BSTS = 0x02
                    }
                }
            }

            Method (NBEJ, 1, NotSerialized)
            {
                If ((BSTS == 0x00))
                {
                    If ((Arg0 < 0x0C))
                    {
                        If ((\BIDE == 0x03))
                        {
                            Notify (\_SB.PCI0.SATA.SCND.MSTR, 0x01) // Device Check
                        }
                        Else
                        {
                            Notify (\_SB.PCI0.IDE0.PRIM.MSTR, 0x01) // Device Check
                        }
                    }

                    If ((Arg0 == 0x10))
                    {
                        If (\WNTF)
                        {
                            Notify (\_SB.PCI0.LPC.EC.BAT1, 0x01) // Device Check
                        }
                        Else
                        {
                            Notify (\_SB.PCI0.LPC.EC.BAT1, 0x81) // Information Change
                        }
                    }
                }

                LED (0x04, 0x00)
                BEEP (0x00)
                BSTS = 0x00
            }

            Method (NBIN, 1, NotSerialized)
            {
                If ((Arg0 < 0x0C))
                {
                    If ((Arg0 == 0x06))
                    {
                        BEN (0x02)
                    }
                    Else
                    {
                        BEN (0x01)
                    }

                    LED (0x04, 0x80)
                    If ((\BIDE == 0x03))
                    {
                        Notify (\_SB.PCI0.SATA.SCND.MSTR, 0x01) // Device Check
                    }
                    Else
                    {
                        Notify (\_SB.PCI0.IDE0.PRIM.MSTR, 0x01) // Device Check
                    }
                }

                If ((Arg0 == 0x10))
                {
                    LED (0x04, 0x80)
                    If (\WNTF)
                    {
                        \_SB.PCI0.LPC.EC.BAT1.XB1S = 0x01
                        Notify (\_SB.PCI0.LPC.EC.BAT1, 0x01) // Device Check
                    }
                    Else
                    {
                        Notify (\_SB.PCI0.LPC.EC.BAT1, 0x81) // Information Change
                    }
                }

                BEEP (0x00)
                BSTS = 0x00
            }

            Method (BSCN, 0, NotSerialized)
            {
                If (!HPBU)
                {
                    Local0 = BGID (0x00)
                    BDEV = Local0
                    If ((Local0 < 0x0C))
                    {
                        If ((Local0 == 0x06))
                        {
                            BEN (0x02)
                        }
                        Else
                        {
                            BEN (0x01)
                        }

                        LED (0x04, 0x80)
                    }

                    If ((Local0 == 0x0E))
                    {
                        BEN (0x00)
                        LED (0x04, 0x80)
                    }

                    If ((Local0 == 0x10))
                    {
                        LED (0x04, 0x80)
                        \_SB.PCI0.LPC.EC.BAT1.XB1S = 0x01
                    }

                    BEEP (0x00)
                    BSTS = 0x00
                }
            }

            Method (BEJ0, 1, NotSerialized)
            {
                If (Arg0)
                {
                    BDIS ()
                    LED (0x04, 0x00)
                    \BHDP (0x01, 0x00)
                    BDEV = 0x0F
                    BSTS = 0x01
                    If (BHKE)
                    {
                        BHKE = 0x00
                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x3003)
                    }
                }
                Else
                {
                    LED (0x04, 0x80)
                    BSTS = 0x00
                }
            }

            Method (BEJ3, 1, NotSerialized)
            {
                If (Arg0)
                {
                    BDIS ()
                    BSTS = 0x01
                }
                Else
                {
                    BSTS = 0x00
                }
            }

            Method (BPTS, 1, NotSerialized)
            {
                HDBM = 0x01
                If ((BSTS != 0x00))
                {
                    BDEV = 0x0F
                    BSTS = 0x00
                }

                BHKE = 0x00
                Local0 = 0x01
                If ((BDEV != 0x0F))
                {
                    If ((!\LFDC && (BDEV == 0x0D)))
                    {
                        Local0 = 0x00
                    }
                }
                Else
                {
                    Local0 = 0x00
                }

                If ((Arg0 >= 0x04))
                {
                    Local0 = 0x00
                }

                If (Local0)
                {
                    BUWK (0x01)
                }
                Else
                {
                    LED (0x04, 0x00)
                    BUWK (0x00)
                }
            }

            Method (BWAK, 1, NotSerialized)
            {
                BUWK (0x00)
                Local0 = BGID (0x00)
                If ((BSTS == 0x00))
                {
                    If ((\_SB.PCI0.LPC.EC.BAT2.XB2S || (HBCS == 0x02))) {}
                    Else
                    {
                        If (HB1A)
                        {
                            \_SB.PCI0.LPC.EC.BAT2.XB2S = 0x01
                            Notify (\_SB.PCI0.LPC.EC.BAT2, 0x01) // Device Check
                        }
                    }

                    If ((SFLG & 0x0400))
                    {
                        If ((BSTS == 0x00))
                        {
                            If ((Local0 != BDEV))
                            {
                                If ((Local0 != 0x10))
                                {
                                    \_SB.PCI0.LPC.EC.BAT1.XB1S = 0x00
                                }

                                If (BXCN)
                                {
                                    BDEV = Local0
                                    NXRC (Local0)
                                }
                                Else
                                {
                                    NBEJ (BDEV)
                                    BDEV = Local0
                                    NBIN (Local0)
                                }
                            }
                            Else
                            {
                                If ((\LFDC || (BDEV != 0x0D)))
                                {
                                    If ((Local0 != 0x0F))
                                    {
                                        LED (0x04, 0x80)
                                        If (HPBU)
                                        {
                                            BHKE = ((Arg0 << 0x08) | 0x2005)
                                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (BHKE)
                                            If ((Arg0 <= 0x02)) {}
                                            Else
                                            {
                                                If (BXCN)
                                                {
                                                    NXRE (Local0)
                                                }
                                                Else
                                                {
                                                    NBRE (Local0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Method (BDIS, 0, NotSerialized)
            {
                If (\_SB.PCI0.LPC.BPRS)
                {
                    If ((\BIDE == 0x03))
                    {
                        \_SB.PCI0.SATA.SIE0 = 0x00
                        \_SB.PCI0.SATA.STI0 = 0x00
                        \_SB.PCI0.LPC.URST = 0x00
                        Stall (0x0F)
                        \_SB.PCI0.SATA.SSIG = 0x01
                    }
                    Else
                    {
                        \_SB.PCI0.IDE0.PIE0 = 0x00
                        \_SB.PCI0.IDE0.PTI0 = 0x00
                        \_SB.PCI0.LPC.URST = 0x00
                        Stall (0x0F)
                        \_SB.PCI0.IDE0.PSIG = 0x01
                    }

                    \_SB.PCI0.LPC.UBPW = 0x00
                }
            }

            Method (BEN, 1, NotSerialized)
            {
                \_SB.PCI0.LPC.URST = 0x00
                \_SB.PCI0.LPC.UBPW = 0x01
                Sleep (0x0F)
                If (Arg0)
                {
                    If ((\BIDE == 0x03))
                    {
                        \_SB.PCI0.SATA.SSIG = 0x00
                        \_SB.PCI0.SATA.SIDE = 0x01
                    }
                    Else
                    {
                        \_SB.PCI0.IDE0.PSIG = 0x00
                        \_SB.PCI0.IDE0.PIDE = 0x01
                    }

                    Stall (0x2D)
                    \_SB.PCI0.LPC.URST = 0x01
                    If (!\WVIS)
                    {
                        If ((Arg0 == 0x02))
                        {
                            Sleep (0x07D0)
                        }
                        Else
                        {
                            Sleep (0x0190)
                        }
                    }
                }

                If (\WVIS)
                {
                    Local0 = 0x3C
                    Local1 = 0x00
                    If ((\BIDE == 0x03))
                    {
                        Local1 = 0x01
                    }

                    While (Local0)
                    {
                        Sleep (0x01F4)
                        If (HSWA (Local1))
                        {
                            Break
                        }

                        Local0--
                    }
                }
            }

            Method (BSTA, 1, NotSerialized)
            {
                If (!\_SB.PCI0.LPC.BPRS)
                {
                    Return (0x00)
                }

                BINI ()
                If ((Arg0 == 0x00))
                {
                    Return ((BDEV == 0x0D))
                }

                If ((Arg0 == 0x01))
                {
                    Return ((BDEV < 0x0C))
                }

                If ((Arg0 == 0x02))
                {
                    Return ((BDEV == 0x0E))
                }

                Return (0x00)
            }

            Method (BUWK, 1, NotSerialized)
            {
                If (\H8DR)
                {
                    If (Arg0)
                    {
                        \_SB.PCI0.LPC.EC.HWBU = 0x01
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.EC.HWBU = 0x00
                    }
                }
                Else
                {
                    If (Arg0)
                    {
                        \MBEC (0x32, 0xFF, 0x80)
                    }
                    Else
                    {
                        \MBEC (0x32, 0x7F, 0x00)
                    }
                }
            }

            Method (BINI, 0, NotSerialized)
            {
                If ((BDEV == 0xFF))
                {
                    BDEV = BGID (0x00)
                }
            }

            Method (BGID, 1, NotSerialized)
            {
                Local0 = 0x0F
                If (Arg0)
                {
                    Local0 = 0xFF
                }
                Else
                {
                    If ((\_SB.PCI0.LPC.EC.GSID () == 0x03))
                    {
                        Local0 = BAID ()
                    }

                    If ((Local0 == 0x0F))
                    {
                        If (\H8DR)
                        {
                            If ((HBCS == 0x02))
                            {
                                Local0 = 0x10
                            }
                        }
                        Else
                        {
                            If ((\RBEC (0xCE) & 0x02))
                            {
                                Local0 = 0x10
                            }
                        }
                    }
                }

                If ((\HDUB && (Local0 < 0x0C)))
                {
                    Local0 = 0x0F
                }

                Return (Local0)
            }

            Method (BAID, 0, NotSerialized)
            {
                If (((BAHD == 0x00) && (BAAT == 0x00)))
                {
                    Return (0x0B)
                }
                Else
                {
                    If (((BAHD == 0x01) && (BAAT == 0x00)))
                    {
                        Return (0x06)
                    }
                    Else
                    {
                        Return (0x0F)
                    }
                }
            }

            Method (NXRE, 1, NotSerialized)
            {
                If ((Arg0 == 0x0F))
                {
                    LED (0x04, 0x00)
                    BSTS = 0x00
                }

                If ((Arg0 < 0x0C))
                {
                    LED (0x04, 0xC0)
                    Notify (\_SB.SWAP, 0x83) // Device-Specific Change
                }

                If ((Arg0 == 0x0E))
                {
                    LED (0x04, 0xC0)
                    Notify (\_SB.SWAP, 0x83) // Device-Specific Change
                }

                If ((Arg0 == 0x10))
                {
                    If ((HPAC || HB0A))
                    {
                        LED (0x04, 0xC0)
                        Notify (\_SB.SWAP, 0x83) // Device-Specific Change
                    }
                    Else
                    {
                        LED (0x04, 0xC0)
                        BEEP (0x0F)
                        BSTS = 0x02
                    }
                }
            }

            Method (NXRC, 1, NotSerialized)
            {
                If ((Arg0 < 0x0C))
                {
                    LED (0x04, 0x80)
                    If ((Arg0 == 0x06))
                    {
                        BEN (0x02)
                    }
                    Else
                    {
                        BEN (0x01)
                    }

                    Notify (\_SB.SWAP, 0x80) // Status Change
                }

                If ((Arg0 == 0x0E))
                {
                    LED (0x04, 0x80)
                    BEN (0x00)
                    Notify (\_SB.SWAP, 0x80) // Status Change
                }

                If ((Arg0 == 0x10))
                {
                    Notify (\_SB.PCI0.LPC.EC.BAT1, 0x81) // Information Change
                    LED (0x04, 0x80)
                    Notify (\_SB.SWAP, 0x80) // Status Change
                }

                BEEP (0x00)
                BSTS = 0x00
            }

            Method (NXEJ, 1, NotSerialized)
            {
                If ((Arg0 == 0x10))
                {
                    Notify (\_SB.PCI0.LPC.EC.BAT1, 0x81) // Information Change
                }

                Notify (\_SB.SWAP, 0x82) // Device-Specific Change
                LED (0x04, 0x00)
                BEEP (0x00)
                BSTS = 0x00
            }

            Method (NXIN, 1, NotSerialized)
            {
                Notify (\_SB.SWAP, 0x81) // Information Change
            }
        }

        Scope (\_SB.PCI0.LPC.EC.BAT1)
        {
            Method (_EJ0, 1, NotSerialized)  // _EJx: Eject Device
            {
                B1ST = 0x00
                XB1S = 0x00
                \_SB.PCI0.LPC.EC.BEJ0 (Arg0)
            }
        }

        Scope (\_SB)
        {
            Device (SWAP)
            {
                Name (_HID, EisaId ("IBM0069"))  // _HID: Hardware ID
                Method (_STA, 0, NotSerialized)  // _STA: Status
                {
                    If (\WMEF)
                    {
                        Return (0x0F)
                    }
                    Else
                    {
                        Return (0x00)
                    }
                }

                Method (XCNN, 1, NotSerialized)
                {
                    \_SB.PCI0.LPC.EC.BXCN = Arg0
                    Return (0x09)
                }

                Method (XSWP, 0, NotSerialized)
                {
                    Return (0x01)
                }

                Method (XEJ0, 1, NotSerialized)
                {
                    \_SB.PCI0.LPC.EC.BEJ0 (Arg0)
                }

                Method (XEJ3, 1, NotSerialized)
                {
                    \_SB.PCI0.LPC.EC.BEJ3 (Arg0)
                }

                Method (XDID, 0, NotSerialized)
                {
                    Name (XPCK, Package (0x06)
                    {
                        0x00, 
                        0x00, 
                        0xFFFFFFFF, 
                        0xFFFFFFFF, 
                        0xFFFFFFFF, 
                        0x00
                    })
                    Local0 = \_SB.PCI0.LPC.EC.BDEV
                    Index (XPCK, 0x00) = Local0
                    If ((Local0 < 0x0C))
                    {
                        If ((\BIDE == 0x03))
                        {
                            Index (XPCK, 0x02) = \_SB.PCI0.SATA._ADR
                            Index (XPCK, 0x03) = \_SB.PCI0.SATA.SCND._ADR /* External reference */
                            Index (XPCK, 0x04) = \_SB.PCI0.SATA.SCND.MSTR._ADR /* External reference */
                        }
                        Else
                        {
                            Index (XPCK, 0x02) = \_SB.PCI0.IDE0._ADR
                            Index (XPCK, 0x03) = \_SB.PCI0.IDE0.PRIM._ADR
                            Index (XPCK, 0x04) = \_SB.PCI0.IDE0.PRIM.MSTR._ADR
                        }
                    }

                    If ((Local0 == 0x10))
                    {
                        Index (XPCK, 0x02) = \_SB.PCI0.LPC.EC.BAT1._HID
                        Index (XPCK, 0x04) = \_SB.PCI0.LPC.EC.BAT1._UID
                    }

                    Index (XPCK, 0x05) = (\_SB.PCI0.LPC.BPRS ^ 0x00)
                    Return (XPCK) /* \_SB_.SWAP.XDID.XPCK */
                }

                Method (XSTM, 1, NotSerialized)
                {
                    Name (XDMY, Buffer (0x14) {})
                    If ((\BIDE == 0x03))
                    {
                        \_SB.PCI0.SATA.SCND._STM (XDMY, Arg0, 0x00)
                    }
                    Else
                    {
                        \_SB.PCI0.IDE0.PRIM._STM (XDMY, Arg0, 0x00)
                    }
                }

                Method (XGTF, 0, NotSerialized)
                {
                    If ((\BIDE == 0x03))
                    {
                        Return (\_SB.PCI0.SATA.SCND.MSTR._GTF) /* External reference */
                    }
                    Else
                    {
                        Return (\_SB.PCI0.IDE0.PRIM.MSTR._GTF ())
                    }
                }
            }
        }

        Scope (\_SB)
        {
            Device (GDCK)
            {
                Name (_HID, EisaId ("IBM0079"))  // _HID: Hardware ID
                Name (_CID, EisaId ("PNP0C15") /* Docking Station */)  // _CID: Compatible ID
                Name (DOID, 0xFFFFFFFF)
                Name (DIDB, 0xFFFFFFFF)
                Name (FLAG, 0x00)
                Name (WUCT, 0x00)
                Name (DHKE, 0x00)
                Event (DEVT)
                Method (DSTA, 0, NotSerialized)
                {
                    UDCK ()
                    UDKT ()
                    If (((GDID () == 0x4C004D24) || (GDID () == 0x44004D24)))
                    {
                        Local0 = 0x0F
                    }
                    Else
                    {
                        If (!\W98F)
                        {
                            Local0 = 0x00
                        }
                        Else
                        {
                            Local0 = 0x0C
                        }
                    }

                    Return (Local0)
                }

                Method (DPTS, 1, NotSerialized)
                {
                    If (((Arg0 >= 0x01) && (Arg0 <= 0x04)))
                    {
                        DHKE = 0x00
                        If (DFLG (0x02, 0x02))
                        {
                            DOID = 0x00
                            DFLG (0x01, 0x02)
                        }

                        If (((GDID () == 0x4C004D24) || (GDID () == 0x44004D24)))
                        {
                            \_SB.PCI0.LPC.EC.DDWK (0x01)
                        }

                        DIDB = GDID ()
                        DFLG (0x00, 0x0100)
                    }
                }

                Name (DDTM, 0x00)
                Method (DWAK, 1, NotSerialized)
                {
                    DOID = 0xFFFFFFFF
                    If (((Arg0 >= 0x01) && (Arg0 <= 0x04)))
                    {
                        DDTM = 0x00
                        If (((DIDB == 0x4C004D24) || (DIDB == 0x44004D24)))
                        {
                            DDTM = 0x01
                        }

                        If (DDTM)
                        {
                            DDTM = 0x00
                            If ((GDID () == 0x4C004D24))
                            {
                                DDTM = 0x01
                            }

                            If ((GDID () == 0x44004D24))
                            {
                                DDTM = 0x01
                            }

                            If (DDTM)
                            {
                                If ((Arg0 == 0x04))
                                {
                                    If ((\_SB.PCI0.LPC.WAKR & 0x08))
                                    {
                                        DGPE ()
                                    }
                                }

                                DHKE = (Arg0 << 0x08)
                                If (!DFLG (0x02, 0x08)) {}
                            }
                            Else
                            {
                                \_SB.PCI0.LPC.BUSD = 0x01
                                \_SB.PCI0.LPC.EC.DATT (0x00, 0x01)
                                \_SB.PCI0.LPC.EC.DATT (0x01, 0x00)
                                Notify (\_SB.GDCK, 0x00) // Bus Check
                                \DHDP (0x00)
                            }
                        }
                        Else
                        {
                            DDTM = 0x00
                            If ((GDID () == 0x4C004D24))
                            {
                                DDTM = 0x01
                            }

                            If ((GDID () == 0x44004D24))
                            {
                                DDTM = 0x01
                            }

                            If (DDTM)
                            {
                                WDCK ()
                            }
                            Else
                            {
                                Noop
                            }
                        }

                        DFLG (0x01, 0x0100)
                        DFLG (0x01, 0x02)
                        DFLG (0x01, 0x10)
                        DFLG (0x01, 0x20)
                        \_SB.PCI0.LPC.DSCI = 0x01
                    }
                }

                Method (DGPE, 0, NotSerialized)
                {
                    DFLG (0x00, 0x08)
                }

                Method (DDCK, 1, NotSerialized)
                {
                    If (Arg0)
                    {
                        \_SB.PCI0.LPC.EC.LED (0x08, 0x00)
                        \_SB.PCI0.LPC.EC.LED (0x09, 0x80)
                        \_SB.PCI0.LPC.LCON (0x01)
                        BCON (0x01)
                        \_SB.PCI0.LPC.EC.DATT (0x00, 0x00)
                        \_SB.PCI0.LPC.EC.DATT (0x01, 0x01)
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.EC.LED (0x08, 0x80)
                        \_SB.PCI0.LPC.EC.LED (0x09, 0xC0)
                        DFLG (0x00, 0x02)
                        \DHDP (0x00)
                        BCON (0x00)
                        \_SB.PCI0.LPC.LCON (0x00)
                        \_SB.PCI0.LPC.EC.DATT (0x00, 0x01)
                        \_SB.PCI0.LPC.EC.DATT (0x01, 0x00)
                    }

                    Return (0x01)
                }

                Method (DEJ0, 1, NotSerialized)
                {
                    If (Arg0)
                    {
                        DOID = 0x00
                        UDKI ()
                    }

                    DFLG (0x01, 0x02)
                    \_SB.PCI0.LPC.EC.LED (0x08, 0x00)
                    \_SB.PCI0.LPC.EC.LED (0x09, 0x00)
                }

                Method (DEJ3, 1, NotSerialized)
                {
                    If (Arg0)
                    {
                        DFLG (0x00, 0x10)
                        If ((\SPS == 0x03))
                        {
                            PDE3 ()
                        }
                    }
                }

                Method (DEJ4, 1, NotSerialized)
                {
                    If (Arg0)
                    {
                        DFLG (0x00, 0x20)
                    }
                }

                Method (PDE3, 0, NotSerialized)
                {
                    Noop
                }

                Name (HIDE, 0x00)
                Method (WDCK, 0, NotSerialized)
                {
                    If ((DFLG (0x02, 0x10) || DFLG (0x02, 0x20)))
                    {
                        DDCK (0x01)
                        If (\W98F)
                        {
                            DFLG (0x00, 0x0200)
                            HIDE = 0x05
                        }
                    }
                    Else
                    {
                        Notify (\_SB.GDCK, 0x00) // Bus Check
                    }
                }

                Method (UDCK, 0, NotSerialized)
                {
                    If (DFLG (0x02, 0x08))
                    {
                        If (!DFLG (0x02, 0x0100))
                        {
                            \_SB.PCI0.LPC.EC.LED (0x08, 0x80)
                            \_SB.PCI0.LPC.EC.LED (0x09, 0xC0)
                            DHKE |= 0x2004
                            If ((\UOPT == 0x00))
                            {
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (DHKE)
                            }

                            If (\W98F)
                            {
                                Notify (\_SB.GDCK, 0x01) // Device Check
                            }
                            Else
                            {
                                Notify (\_SB.GDCK, 0x03) // Eject Request
                            }

                            DFLG (0x01, 0x08)
                        }
                    }
                }

                Method (UDKI, 0, NotSerialized)
                {
                    If (\WNTF)
                    {
                        WUCT = 0x01
                    }
                    Else
                    {
                        WUCT = 0x05
                    }
                }

                Method (UDKT, 0, NotSerialized)
                {
                    If ((DHKE & 0x2004))
                    {
                        If ((GDID () == 0x00))
                        {
                            If (!WUCT--)
                            {
                                DHKE = 0x00
                                If ((\UOPT == 0x00))
                                {
                                    \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x4003)
                                }
                            }
                        }
                    }
                }

                Method (GDID, 0, NotSerialized)
                {
                    If ((DOID == 0xFFFFFFFF))
                    {
                        \_SB.GDCK.G_ID = 0xFFFFFFFF
                        DOID = RDID ()
                    }

                    Return (DOID) /* \_SB_.GDCK.DOID */
                }

                Method (RDID, 0, NotSerialized)
                {
                    Local0 = 0x00
                    If (\_SB.PCI0.LPC.EPWG)
                    {
                        If ((\_SB.GDCK.GGID () == 0x00))
                        {
                            If (\H8DR)
                            {
                                If (\_SB.PCI0.LPC.EC.EEPR ())
                                {
                                    Local0 = \_SB.PCI0.LPC.EC.HDEP
                                }
                                Else
                                {
                                    Local0 = 0x4C004D24
                                }
                            }
                            Else
                            {
                                Local0 = \DCKI
                            }
                        }

                        If ((\_SB.GDCK.GGID () == 0x01))
                        {
                            Local0 = 0x44004D24
                        }

                        If ((\_SB.GDCK.GGID () == 0x03))
                        {
                            Local0 = 0x0200AE30
                        }
                    }

                    Return (Local0)
                }

                Method (RDSR, 0, NotSerialized)
                {
                    Local0 = 0x00
                    If ((GDID () != 0x00))
                    {
                        If ((\_SB.GDCK.GGID () == 0x00))
                        {
                            If (\H8DR)
                            {
                                If (\_SB.PCI0.LPC.EC.EEPR ())
                                {
                                    Local0 = \_SB.PCI0.LPC.EC.HDEN
                                }
                            }
                            Else
                            {
                                Local0 = \DCKS
                            }
                        }

                        If ((\_SB.GDCK.GGID () == 0x01))
                        {
                            Local0 = 0x00
                        }
                    }

                    Return (Local0)
                }

                Method (BCON, 1, NotSerialized)
                {
                    Local0 = \_SB.PCI0.LPC.EC.DATT (0x00, 0x02)
                    \_SB.PCI0.LPC.EC.DATT (0x00, 0x01)
                    \_SB.PCI0.LPC.SERQ |= 0x40
                    \_SB.PCI0.LPC.SERQ &= 0x7F
                    Local1 = \_SB.PCI0.LPC.CLKR
                    If (Arg0)
                    {
                        \_SB.PCI0.LPC.CLKR = 0x00
                        \_SB.PCI0.LPC.BUSC = 0x01
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.BUSD = 0x01
                    }

                    \_SB.PCI0.LPC.CLKR = Local1
                    \_SB.PCI0.LPC.SERQ |= 0xC0
                    \_SB.PCI0.LPC.SERQ &= 0xBF
                    If ((Local0 == 0x00))
                    {
                        \_SB.PCI0.LPC.EC.DATT (0x00, 0x00)
                    }
                }

                Method (DFLG, 2, NotSerialized)
                {
                    If ((Arg0 == 0x00))
                    {
                        FLAG |= Arg1
                    }

                    If ((Arg0 == 0x01))
                    {
                        FLAG &= ~Arg1
                    }

                    If ((FLAG & Arg1))
                    {
                        Return (0x01)
                    }
                    Else
                    {
                        Return (0x00)
                    }
                }

                Scope (\_SB.PCI0.LPC.EC)
                {
                    Method (_Q37, 0, NotSerialized)  // _Qxx: EC Query
                    {
                        If (\_SB.PCI0.LPC.EPWG)
                        {
                            Local0 = 0x07D0
                            Sleep (0x64)
                            \_SB.GDCK.G_ID = 0xFFFFFFFF
                            While (((\_SB.GDCK.GGID () == 0x07) && Local0))
                            {
                                Sleep (0x01)
                                \_SB.GDCK.G_ID = 0xFFFFFFFF
                                Local0--
                            }

                            \_SB.GDCK.DOID = 0xFFFFFFFF
                            If (((\_SB.GDCK.GDID () == 0x4C004D24) || (\_SB.GDCK.GDID () == 0x44004D24)))
                            {
                                If (HPAC)
                                {
                                    \_SB.PCI0.LPC.DRST = 0x00
                                    Notify (\_SB.GDCK, 0x00) // Bus Check
                                }
                            }
                        }
                    }

                    Method (EEPR, 0, NotSerialized)
                    {
                        Local0 = 0x00
                        If (\H8DR)
                        {
                            HDEO = 0x00
                            HDEC = 0x0A
                            While (!(HDEC & 0xC0))
                            {
                                Sleep (0x01)
                            }

                            If (!(HDEC & 0x40))
                            {
                                Local1 = 0x00
                                Local2 = HDEN /* \_SB_.PCI0.LPC_.EC__.HDEN */
                                Local3 = 0x04
                                While (Local3)
                                {
                                    Local1 += (Local2 & 0xFF)
                                    Local2 >>= 0x08
                                    Local3--
                                }

                                Local2 = HDEP /* \_SB_.PCI0.LPC_.EC__.HDEP */
                                Local3 = 0x04
                                While (Local3)
                                {
                                    Local1 += (Local2 & 0xFF)
                                    Local2 >>= 0x08
                                    Local3--
                                }

                                Local1 += HDEM /* \_SB_.PCI0.LPC_.EC__.HDEM */
                                Local1 += HDES /* \_SB_.PCI0.LPC_.EC__.HDES */
                                If (!(Local1 & 0xFF))
                                {
                                    Local0 = 0x01
                                }
                            }
                        }

                        Return (Local0)
                    }
                }

                Method (_STA, 0, NotSerialized)  // _STA: Status
                {
                    Local0 = GGID ()
                    If (!\W98F)
                    {
                        Local1 = 0x00
                    }
                    Else
                    {
                        Local1 = 0x0C
                    }

                    If ((Local0 == 0x03))
                    {
                        Local1 = \_SB.PCI0.LPC.EC.SSTA ()
                    }

                    Return (Local1)
                }

                Method (_INI, 0, NotSerialized)  // _INI: Initialize
                {
                    \_SB.PCI0.LPC.EC.SINI ()
                    \_SB.PCI0.LPC.EC.DATT (0x02, 0x01)
                    If ((GGID () == 0x07))
                    {
                        \_SB.PCI0.LPC.EC.DATT (0x01, 0x00)
                        \_SB.PCI0.LPC.EC.DATT (0x00, 0x01)
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.EC.DATT (0x01, 0x01)
                        \_SB.PCI0.LPC.EC.DATT (0x00, 0x00)
                    }

                    \_SB.PCI0.LPC.EC.DDWK (0x00)
                    \_SB.PCI0.LPC.DSCI = 0x01
                }

                Method (_DCK, 1, NotSerialized)  // _DCK: Dock Present
                {
                    Local0 = 0x00
                    If ((GGID () == 0x03))
                    {
                        Local0 = \_SB.PCI0.LPC.EC.SDCK (Arg0)
                    }

                    If (\VIGD)
                    {
                        \_SB.PCI0.VID.VDSW (Arg0)
                    }

                    Return (Local0)
                }

                Name (UDOP, 0x00)
                Method (_EJ0, 1, NotSerialized)  // _EJx: Eject Device
                {
                    If ((GGID () == 0x03))
                    {
                        \_SB.PCI0.LPC.EC.SEJ0 (Arg0)
                    }
                }

                Method (XEJ3, 1, NotSerialized)
                {
                    If ((GGID () == 0x03))
                    {
                        \_SB.PCI0.LPC.EC.SEJ3 (Arg0)
                    }
                }

                Method (_EJ4, 1, NotSerialized)  // _EJx: Eject Device
                {
                    If ((GGID () == 0x03))
                    {
                        \_SB.PCI0.LPC.EC.SEJ4 (Arg0)
                    }
                }

                Method (PEJ3, 0, NotSerialized)
                {
                    If ((GGID () == 0x03))
                    {
                        \_SB.PCI0.LPC.EC.PSE3 ()
                    }
                }

                Method (_BDN, 0, NotSerialized)  // _BDN: BIOS Dock Name
                {
                    Local0 = 0x00
                    If ((GGID () == 0x03))
                    {
                        Local0 = \_SB.PCI0.LPC.EC.SLBN ()
                    }

                    Return (Local0)
                }

                Method (_UID, 0, NotSerialized)  // _UID: Unique ID
                {
                    Local0 = 0x00
                    If ((GGID () == 0x03))
                    {
                        Local0 = \_SB.PCI0.LPC.EC.SLUD ()
                    }

                    Return (Local0)
                }

                Method (GPTS, 1, NotSerialized)
                {
                    \_SB.PCI0.LPC.EC.SPTS (Arg0)
                }

                Method (GWAK, 1, NotSerialized)
                {
                    \_SB.PCI0.LPC.EC.SWAK (Arg0)
                    \_SB.PCI0.LPC.EC.DDWK (0x00)
                }

                Method (GGPE, 0, NotSerialized)
                {
                    If ((GGID () == 0x03))
                    {
                        \_SB.PCI0.LPC.EC.SGPE ()
                    }
                }

                Name (G_ID, 0xFFFFFFFF)
                Method (GGID, 0, NotSerialized)
                {
                    Local0 = G_ID /* \_SB_.GDCK.G_ID */
                    If ((Local0 == 0xFFFFFFFF))
                    {
                        Local0 = \_SB.PCI0.LPC.DKI0
                        Local1 = \_SB.PCI0.LPC.DKI1
                        Local2 = \_SB.PCI0.LPC.GL03
                        Local2 &= 0x01
                        Local0 |= (Local1 << 0x01)
                        Local0 |= (Local2 << 0x02)
                        G_ID = Local0
                    }

                    Return (Local0)
                }
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Method (_Q50, 0, NotSerialized)  // _Qxx: EC Query
            {
                Local0 = \_SB.GDCK.GGID ()
                If ((Local0 != 0x07))
                {
                    \_SB.PCI0.LPC.EC.LED (0x08, 0x80)
                    If ((ES07 == 0x01))
                    {
                        \_SB.PCI0.LPC.EC.LED (0x09, 0xC0)
                        If ((Local0 == 0x03))
                        {
                            \_SB.PCI0.LPC.EC.SPEJ ()
                        }

                        If (\W98F)
                        {
                            Notify (\_SB.GDCK, 0x01) // Device Check
                        }
                        Else
                        {
                            Notify (\_SB.GDCK, 0x03) // Eject Request
                        }

                        ES07 = 0x01
                    }

                    If ((ES01 == 0x01))
                    {
                        If (!HPBU)
                        {
                            If ((SFLG & 0x0400))
                            {
                                BDEV = BGID (0x00)
                                If (BXCN)
                                {
                                    NXRC (BDEV)
                                }
                                Else
                                {
                                    NBIN (BDEV)
                                }
                            }
                        }

                        ES01 = One
                    }

                    If ((ES10 == 0x01))
                    {
                        ES10 = 0x01
                    }
                }
            }

            Method (_Q58, 0, NotSerialized)  // _Qxx: EC Query
            {
                \_SB.GDCK.G_ID = 0xFFFFFFFF
                \_SB.PCI0.LPC.EC.SLID = 0xFFFFFFFF
                Local0 = \_SB.GDCK.GGID ()
                If ((Local0 == 0x03))
                {
                    ASSI (0x00)
                    Sleep (0x64)
                    If ((\_SB.PCI0.LPC.SIOD != 0xFF))
                    {
                        Notify (\_SB.GDCK, 0x00) // Bus Check
                    }
                }

                \_SB.PCI0.IGBE.ABWA (0x00)
            }

            Method (GUSB, 1, NotSerialized)
            {
                Local0 = (Arg0 << 0x02)
                If (\H8DR)
                {
                    UHPW = Arg0
                    SLIS = Arg0
                }
                Else
                {
                    UHPW = Arg0
                    \MBEC (0x03, 0xFB, Local0)
                }
            }

            Method (DATT, 2, NotSerialized)
            {
                Local0 = 0x00
                If ((Arg0 == 0x00))
                {
                    If ((Arg1 == 0x01))
                    {
                        If (\H8DR)
                        {
                            HAM6 |= 0x80
                        }
                        Else
                        {
                            \MBEC (0x16, 0xFF, 0x80)
                        }

                        Local0 = 0x01
                    }

                    If ((Arg1 == 0x00))
                    {
                        If (\H8DR)
                        {
                            HAM6 &= 0x7F
                        }
                        Else
                        {
                            \MBEC (0x16, 0x7F, 0x00)
                        }
                    }

                    If ((Arg1 == 0x02))
                    {
                        If (\H8DR)
                        {
                            If ((HAM6 & 0x80))
                            {
                                Local0 = 0x01
                            }
                        }
                        Else
                        {
                            If ((\RBEC (0x16) & 0x80))
                            {
                                Local0 = 0x01
                            }
                        }
                    }
                }

                If ((Arg0 == 0x01))
                {
                    If ((Arg1 == 0x01))
                    {
                        If (\H8DR)
                        {
                            HAMA |= 0x01
                        }
                        Else
                        {
                            \MBEC (0x1A, 0xFF, 0x01)
                        }

                        Local0 = 0x01
                    }

                    If ((Arg1 == 0x00))
                    {
                        If (\H8DR)
                        {
                            HAMA &= 0xFE
                        }
                        Else
                        {
                            \MBEC (0x1A, 0xFE, 0x00)
                        }
                    }

                    If ((Arg1 == 0x02))
                    {
                        If (\H8DR)
                        {
                            If ((HAMA & 0x01))
                            {
                                Local0 = 0x01
                            }
                        }
                        Else
                        {
                            If ((\RBEC (0x1A) & 0x01))
                            {
                                Local0 = 0x01
                            }
                        }
                    }
                }

                If ((Arg0 == 0x02))
                {
                    If ((Arg1 == 0x01))
                    {
                        If (\H8DR)
                        {
                            HAMB |= 0x01
                        }
                        Else
                        {
                            \MBEC (0x1B, 0xFF, 0x01)
                        }

                        Local0 = 0x01
                    }

                    If ((Arg1 == 0x00))
                    {
                        If (\H8DR)
                        {
                            HAMB &= 0xFE
                        }
                        Else
                        {
                            \MBEC (0x1B, 0xFE, 0x00)
                        }
                    }

                    If ((Arg1 == 0x02))
                    {
                        If (\H8DR)
                        {
                            If ((HAMB & 0x01))
                            {
                                Local0 = 0x01
                            }
                        }
                        Else
                        {
                            If ((\RBEC (0x1B) & 0x01))
                            {
                                Local0 = 0x01
                            }
                        }
                    }
                }

                Return (Local0)
            }

            Method (DDWK, 1, NotSerialized)
            {
                Local0 = 0x00
                If ((Arg0 == 0x01))
                {
                    If (\H8DR)
                    {
                        HWDK = One
                    }
                    Else
                    {
                        \MBEC (0x32, 0xFF, 0x08)
                    }

                    Local0 = 0x01
                }

                If ((Arg0 == 0x00))
                {
                    If (\H8DR)
                    {
                        HWDK = Zero
                    }
                    Else
                    {
                        \MBEC (0x32, 0xF7, 0x00)
                    }
                }

                If ((Arg0 == 0x02))
                {
                    If (\H8DR)
                    {
                        If (HWDK)
                        {
                            Local0 = 0x01
                        }
                    }
                    Else
                    {
                        If ((\RBEC (0x32) & 0x08))
                        {
                            Local0 = 0x01
                        }
                    }
                }

                Return (Local0)
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Name (SLID, 0xFFFFFFFF)
            Name (SIDB, 0xFFFFFFFF)
            Name (SFLG, 0x00)
            Name (SUCT, 0x00)
            Name (SHKE, 0x00)
            Name (IFLG, 0x00)
            Method (SLBN, 0, NotSerialized)
            {
                Return (0x03)
            }

            Method (SLUD, 0, NotSerialized)
            {
                Return (0x00)
            }

            Method (SSTA, 0, NotSerialized)
            {
                SUDK ()
                SUDT ()
                If ((GSID () == 0x03))
                {
                    Local0 = 0x0F
                }
                Else
                {
                    If (!\W98F)
                    {
                        Local0 = 0x00
                    }
                    Else
                    {
                        Local0 = 0x0C
                    }
                }

                If (\W98F)
                {
                    Local0 = HIDS (Local0)
                }

                Return (Local0)
            }

            Method (SINI, 0, NotSerialized)
            {
                If ((GSID () == 0x03))
                {
                    If (!IFLG)
                    {
                        ES07 = 0x01
                    }

                    SFLG |= 0x0400
                }
                Else
                {
                    SFLG &= ~0x0400
                }

                IFLG = 0x01
            }

            Method (SPTS, 1, NotSerialized)
            {
                If (((Arg0 >= 0x01) && (Arg0 <= 0x04)))
                {
                    SHKE = 0x00
                    SIDB = 0x00
                    \_SB.PCI0.LPC.GO16 = Zero
                    If ((Arg0 == 0x03))
                    {
                        \_SB.PCI0.LPC.GER0 = 0x80
                    }

                    If ((SFLG & 0x02))
                    {
                        SLID = 0x00
                        SFLG &= ~0x02
                    }

                    If ((GSID () == 0x03))
                    {
                        If ((Arg0 == 0x03))
                        {
                            \_SB.PCI0.LPC.EC.DDWK (0x01)
                        }

                        SIDB = 0x03
                    }

                    SFLG |= 0x0100
                }
            }

            Method (SWAK, 1, NotSerialized)
            {
                SLID = 0xFFFFFFFF
                If (((Arg0 >= 0x01) && (Arg0 <= 0x04)))
                {
                    If ((SIDB == 0x03))
                    {
                        If ((GSID () == 0x03))
                        {
                            LED (0x03, 0x80)
                            SHKE = (Arg0 << 0x08)
                            If ((Arg0 == 0x03))
                            {
                                \_SB.PCI0.LPC.GO16 = One
                                \_SB.PCI0.LPC.GER0 = 0x82
                            }

                            If ((Arg0 == 0x04))
                            {
                                ES07 = 0x01
                            }
                        }
                        Else
                        {
                            GUSB (0x00)
                            Notify (\_SB.GDCK, 0x00) // Bus Check
                            SFLG &= ~0x0400
                        }
                    }
                    Else
                    {
                        If ((GSID () == 0x03))
                        {
                            ASSI (0x00)
                            Sleep (0x64)
                            If ((\_SB.PCI0.LPC.SIOD != 0xFF))
                            {
                                WSDK ()
                            }
                        }
                        Else
                        {
                            Noop
                        }
                    }

                    If ((0xF3 != ATMX))
                    {
                        ATMX = 0xF3
                        Sleep (0x64)
                    }

                    SFLG &= ~0x0100
                    SFLG &= ~0x02
                    SFLG &= ~0x10
                    SFLG &= ~0x20
                }

                HB1I = 0x00
            }

            Method (SGPE, 0, NotSerialized)
            {
                SFLG |= 0x08
            }

            Method (SDCK, 1, NotSerialized)
            {
                If (\H8DR)
                {
                    If (Arg0)
                    {
                        Sleep (0x64)
                        If (!BXCN)
                        {
                            BSCN ()
                        }

                        \_SB.PCI0.LPC.EC.DATT (0x01, 0x01)
                        HB1I = 0x00
                        SFLG |= 0x0400
                    }
                    Else
                    {
                        SFLG |= 0x02
                        GUSB (0x00)
                        HB1I = 0x01
                        If (\WNTF)
                        {
                            \_SB.PCI0.LPC.EC.BAT1.B1ST = 0x00
                            \_SB.PCI0.LPC.EC.BAT1.XB1S = 0x00
                            \_SB.PCI0.LPC.EC.BAT2.B2ST = 0x00
                            \_SB.PCI0.LPC.EC.BAT2.XB2S = 0x00
                        }

                        BEJ0 (0x01)
                        If (BXCN)
                        {
                            Notify (\_SB.SWAP, 0x82) // Device-Specific Change
                        }

                        \_SB.PCI0.LPC.EC.DATT (0x01, 0x00)
                        SFLG &= ~0x0400
                    }
                }

                Return (0x01)
            }

            Method (SEJ0, 1, NotSerialized)
            {
                SLID = 0x00
                If (Arg0)
                {
                    ASSI (0x01)
                }

                LED (0x03, 0x00)
                SUDI ()
                SFLG &= ~0x02
            }

            Method (SEJ3, 1, NotSerialized)
            {
                SFLG |= 0x10
                If ((\SPS == 0x03))
                {
                    PSE3 ()
                }
            }

            Method (SEJ4, 1, NotSerialized)
            {
                SFLG |= 0x20
            }

            Method (PSE3, 0, NotSerialized)
            {
                If ((SFLG & 0x10))
                {
                    LED (0x03, 0x00)
                }
            }

            Name (SHDE, 0x00)
            Method (WSDK, 0, NotSerialized)
            {
                If ((SFLG & (0x10 | 0x20)))
                {
                    SDCK (0x01)
                    If (\W98F)
                    {
                        SFLG |= 0x0200
                        SHDE = 0x05
                    }
                }
                Else
                {
                    Notify (\_SB.GDCK, 0x00) // Bus Check
                }
            }

            Method (HIDS, 1, NotSerialized)
            {
                Local0 = Arg0
                If ((SFLG & 0x0200))
                {
                    If ((Arg0 == 0x0F))
                    {
                        If (\W98F)
                        {
                            Local0 = 0x0C
                        }

                        SHDE--
                        If (!SHDE)
                        {
                            SFLG &= ~0x0200
                            Notify (\_SB.GDCK, 0x00) // Bus Check
                        }
                    }
                    Else
                    {
                        SFLG &= ~0x0200
                    }
                }

                Return (Local0)
            }

            Method (SUDK, 0, NotSerialized)
            {
                If ((SFLG & 0x08))
                {
                    If (!(SFLG & 0x0100))
                    {
                        SHKE |= 0x2004
                        If ((\UOPT == 0x00))
                        {
                            \_SB.PCI0.LPC.EC.HKEY.MHKQ (SHKE)
                        }

                        If (\W98F)
                        {
                            Notify (\_SB.GDCK, 0x01) // Device Check
                        }
                        Else
                        {
                            Notify (\_SB.GDCK, 0x03) // Eject Request
                        }

                        SFLG &= ~0x08
                    }
                }
            }

            Method (SUDI, 0, NotSerialized)
            {
                If (\WNTF)
                {
                    SUCT = 0x01
                }
                Else
                {
                    SUCT = 0x05
                }
            }

            Method (SUDT, 0, NotSerialized)
            {
                If ((SHKE & 0x2004))
                {
                    If ((GSID () == 0x00))
                    {
                        If (!SUCT--)
                        {
                            SHKE = 0x00
                            If ((\UOPT == 0x00))
                            {
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x4003)
                            }
                        }
                    }
                }
            }

            Method (GSID, 0, NotSerialized)
            {
                If ((SLID == 0xFFFFFFFF))
                {
                    \_SB.GDCK.G_ID = 0xFFFFFFFF
                    If ((\_SB.GDCK.GGID () == 0x03))
                    {
                        SLID = 0x03
                    }
                    Else
                    {
                        SLID = 0x00
                    }
                }

                Return (SLID) /* \_SB_.PCI0.LPC_.EC__.SLID */
            }

            Method (SPEJ, 0, NotSerialized)
            {
                LED (0x03, 0x00)
                Sleep (0xC8)
                LED (0x03, 0x80)
                Sleep (0xC8)
                LED (0x03, 0x00)
                Sleep (0xC8)
                LED (0x03, 0x80)
                Sleep (0xC8)
                LED (0x03, 0x00)
                Sleep (0xC8)
                LED (0x03, 0x80)
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Method (RPTS, 1, NotSerialized)
            {
                Noop
            }

            Method (RWAK, 1, NotSerialized)
            {
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Method (_Q43, 0, NotSerialized)  // _Qxx: EC Query
            {
                \UCMS (0x18)
            }

            Method (SAUM, 1, NotSerialized)
            {
                If ((Arg0 > 0x03))
                {
                    Noop
                }
                Else
                {
                    If (\H8DR)
                    {
                        HAUM = Arg0
                    }
                    Else
                    {
                        \MBEC (0x03, 0x9F, (Arg0 << 0x05))
                    }
                }
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Name (BRTB, Package (0x02)
            {
                Package (0x10)
                {
                    0x27, 
                    0x35, 
                    0x45, 
                    0x55, 
                    0x60, 
                    0x6C, 
                    0x76, 
                    0x81, 
                    0x8E, 
                    0x9B, 
                    0xA8, 
                    0xB6, 
                    0xC5, 
                    0xD8, 
                    0xEC, 
                    0xFF
                }, 

                Package (0x10)
                {
                    0x27, 
                    0x31, 
                    0x3D, 
                    0x49, 
                    0x55, 
                    0x61, 
                    0x67, 
                    0x6E, 
                    0x76, 
                    0x7D, 
                    0x86, 
                    0x91, 
                    0x9A, 
                    0xA4, 
                    0xAE, 
                    0xB8
                }
            })
            Name (BRTF, 0x01)
            Method (_Q14, 0, NotSerialized)  // _Qxx: EC Query
            {
                If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x8000))
                {
                    \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1010)
                }

                If (\NBCF)
                {
                    If (\VIGD)
                    {
                        Notify (\_SB.PCI0.VID.LCD0, 0x86) // Device-Specific
                    }
                    Else
                    {
                        Notify (\_SB.PCI0.AGP.VID.LCD0, 0x86) // Device-Specific
                    }
                }
                Else
                {
                    If (\VIGD)
                    {
                        \BRLV = \UCMS (0x15)
                        Local0 = \BRLV
                        If ((Local0 != 0x0F))
                        {
                            Local0++
                            \BRLV = Local0
                        }

                        \_SB.PCI0.LPC.EC.BRNS ()
                        \UCMS (0x16)
                    }
                    Else
                    {
                        \UCMS (0x04)
                    }
                }
            }

            Method (_Q15, 0, NotSerialized)  // _Qxx: EC Query
            {
                If (\VCDB)
                {
                    \VCDB = 0x00
                    \BRLV = \UCMS (0x15)
                    \_SB.PCI0.LPC.EC.BRNS ()
                    \UCMS (0x16)
                    Return (0x00)
                }

                If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x00010000))
                {
                    \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1011)
                }

                If (\NBCF)
                {
                    If (\VIGD)
                    {
                        Notify (\_SB.PCI0.VID.LCD0, 0x87) // Device-Specific
                    }
                    Else
                    {
                        Notify (\_SB.PCI0.AGP.VID.LCD0, 0x87) // Device-Specific
                    }
                }
                Else
                {
                    If (\VIGD)
                    {
                        \BRLV = \UCMS (0x15)
                        Local0 = \BRLV
                        If (Local0)
                        {
                            Local0--
                            \BRLV = Local0
                        }

                        \_SB.PCI0.LPC.EC.BRNS ()
                        \UCMS (0x16)
                    }
                    Else
                    {
                        \UCMS (0x05)
                    }
                }
            }

            Method (BRNS, 0, NotSerialized)
            {
                Local0 = \BRLV
                Local1 = 0x00
                If (\BRHB)
                {
                    If (!\_SB.PCI0.LPC.EC.AC._PSR ())
                    {
                        Local1 = 0x01
                    }
                }

                Local2 = DerefOf (Index (DerefOf (Index (BRTB, Local1)), Local0))
                \_SB.PCI0.VID.AINT (0x01, Local2)
            }

            Method (BRTO, 1, NotSerialized)
            {
                If (BRTF)
                {
                    Local0 = Arg0
                    While ((Local0 > 0x01))
                    {
                        If ((\BRFQ == 0x01))
                        {
                            Sleep (0x64)
                            Local0--
                        }
                        Else
                        {
                            If ((\BRFQ == 0x03))
                            {
                                Sleep (0x64)
                                Local0--
                            }
                            Else
                            {
                                Local0 = 0x00
                            }
                        }
                    }
                }
            }

            Method (BRTT, 0, NotSerialized)
            {
                If (\VIGD)
                {
                    Local0 = \BRLV
                    If ((Local0 == 0x00))
                    {
                        If ((\BRFQ != 0x02))
                        {
                            If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x080C))
                            {
                                \BRFQ = 0x01
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x5010)
                            }
                        }
                    }
                    Else
                    {
                        If ((\BRFQ != 0x00))
                        {
                            If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x080C))
                            {
                                \BRFQ = 0x03
                                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x5010)
                            }
                        }
                    }
                }
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Method (_Q19, 0, NotSerialized)  // _Qxx: EC Query
            {
                If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x00800000))
                {
                    \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1018)
                }

                \UCMS (0x03)
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Method (_Q63, 0, NotSerialized)  // _Qxx: EC Query
            {
                If (\_SB.PCI0.LPC.EC.HKEY.MHKK (0x00080000))
                {
                    \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x1014)
                }

                \UCMS (0x0B)
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Method (_Q70, 0, NotSerialized)  // _Qxx: EC Query
            {
                FNST ()
            }

            Method (_Q72, 0, NotSerialized)  // _Qxx: EC Query
            {
                FNST ()
            }

            Method (_Q73, 0, NotSerialized)  // _Qxx: EC Query
            {
                FNST ()
            }

            Method (FNST, 0, NotSerialized)
            {
                If (\H8DR)
                {
                    Local0 = HFNS /* \_SB_.PCI0.LPC_.EC__.HFNS */
                    Local1 = HFNE /* \_SB_.PCI0.LPC_.EC__.HFNE */
                }
                Else
                {
                    Local0 = (\RBEC (0x0E) & 0x03)
                    Local1 = (\RBEC (0x00) & 0x08)
                }

                If (Local1)
                {
                    If ((Local0 == 0x00))
                    {
                        \UCMS (0x11)
                    }

                    If ((Local0 == 0x01))
                    {
                        \UCMS (0x0F)
                    }

                    If ((Local0 == 0x02))
                    {
                        \UCMS (0x10)
                    }
                }
            }
        }

        Scope (\_SB.PCI0.LPC.EC.HKEY)
        {
            Name (WGFL, 0x00)
            Method (WLSW, 0, NotSerialized)
            {
                Return (\_SB.PCI0.LPC.EC.GSTS)
            }

            Method (GWAN, 0, NotSerialized)
            {
                Local0 = 0x00
                If ((WGFL & 0x01))
                {
                    Local0 |= 0x01
                }

                If ((WGFL & 0x08))
                {
                    Return (Local0)
                }

                If (WPWS ())
                {
                    Local0 |= 0x02
                }

                If ((WGFL & 0x04))
                {
                    Local0 |= 0x04
                }

                Return (Local0)
            }

            Method (SWAN, 1, NotSerialized)
            {
                If ((Arg0 & 0x02))
                {
                    WPWC (0x01)
                }
                Else
                {
                    WPWC (0x00)
                }

                If ((Arg0 & 0x04))
                {
                    WGFL |= 0x04
                    \WGSV (0x02)
                }
                Else
                {
                    WGFL &= ~0x04
                    \WGSV (0x03)
                }
            }

            Method (GBDC, 0, NotSerialized)
            {
                Local0 = 0x00
                If ((WGFL & 0x10))
                {
                    Local0 |= 0x01
                }

                If ((WGFL & 0x80))
                {
                    Return (Local0)
                }

                If (BPWS ())
                {
                    Local0 |= 0x02
                }

                If ((WGFL & 0x40))
                {
                    Local0 |= 0x04
                }

                Return (Local0)
            }

            Method (SBDC, 1, NotSerialized)
            {
                If ((Arg0 & 0x02))
                {
                    BPWC (0x01)
                }
                Else
                {
                    BPWC (0x00)
                }

                If ((Arg0 & 0x04))
                {
                    WGFL |= 0x40
                    \BLTH (0x02)
                }
                Else
                {
                    WGFL &= ~0x40
                    \BLTH (0x03)
                }
            }

            Method (WPWS, 0, NotSerialized)
            {
                If (\H8DR)
                {
                    Local0 = \_SB.PCI0.LPC.EC.DCWW
                }
                Else
                {
                    Local0 = ((\RBEC (0x3A) & 0x40) >> 0x06)
                }

                Return (Local0)
            }

            Method (WTGL, 0, NotSerialized)
            {
                If ((WGFL & 0x01))
                {
                    WPWC (!WPWS ())
                }
            }

            Method (WPWC, 1, NotSerialized)
            {
                If ((Arg0 && ((WGFL & 0x01) && !(WGFL & 0x08
                    ))))
                {
                    If (\H8DR)
                    {
                        \_SB.PCI0.LPC.EC.DCWW = One
                    }
                    Else
                    {
                        \MBEC (0x3A, 0xFF, 0x40)
                    }

                    WGFL |= 0x02
                }
                Else
                {
                    If (\H8DR)
                    {
                        \_SB.PCI0.LPC.EC.DCWW = Zero
                    }
                    Else
                    {
                        \MBEC (0x3A, 0xBF, 0x00)
                    }

                    WGFL &= ~0x02
                }
            }

            Method (BPWS, 0, NotSerialized)
            {
                If (\H8DR)
                {
                    Local0 = \_SB.PCI0.LPC.EC.DCBD
                }
                Else
                {
                    Local0 = ((\RBEC (0x3A) & 0x10) >> 0x04)
                }

                Return (Local0)
            }

            Method (BTGL, 0, NotSerialized)
            {
                If ((WGFL & 0x10))
                {
                    BPWC (!BPWS ())
                }
            }

            Method (BPWC, 1, NotSerialized)
            {
                If ((Arg0 && ((WGFL & 0x10) && !(WGFL & 0x80
                    ))))
                {
                    If (\H8DR)
                    {
                        \_SB.PCI0.LPC.EC.DCBD = One
                    }
                    Else
                    {
                        \MBEC (0x3A, 0xFF, 0x10)
                    }

                    WGFL |= 0x20
                }
                Else
                {
                    If (\H8DR)
                    {
                        \_SB.PCI0.LPC.EC.DCBD = Zero
                    }
                    Else
                    {
                        \MBEC (0x3A, 0xEF, 0x00)
                    }

                    WGFL &= ~0x20
                }
            }

            Method (WGIN, 0, NotSerialized)
            {
                WGFL = 0x00
                WGFL = \WGSV (0x01)
                If (WPWS ())
                {
                    WGFL |= 0x02
                }

                If (BPWS ())
                {
                    WGFL |= 0x20
                }
            }

            Method (WGPS, 1, NotSerialized)
            {
                If ((Arg0 >= 0x04))
                {
                    \BLTH (0x05)
                }

                If (!(WGFL & 0x04))
                {
                    WPWC (0x00)
                }

                If (!(WGFL & 0x40))
                {
                    BPWC (0x00)
                }
            }

            Method (WGWK, 1, NotSerialized)
            {
                If ((WGFL & 0x20))
                {
                    BPWC (0x01)
                }

                If ((WGFL & 0x02))
                {
                    WPWC (0x01)
                }
            }
        }

        Scope (\_SB.PCI0.LPC.EC)
        {
            Method (_Q41, 0, NotSerialized)  // _Qxx: EC Query
            {
                \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x7000)
            }
        }
    }

    Scope (\_SB.PCI0.IDE0.PRIM)
    {
        Name (_EJD, "_SB.GDCK")  // _EJD: Ejection Dependent Device
    }

    Scope (\_SB.PCI0.LPC.EC.BAT1)
    {
        Name (_EJD, "_SB.GDCK")  // _EJD: Ejection Dependent Device
    }

    Scope (\_SB.PCI0.USB4.URTH.UPDK)
    {
        Name (_EJD, "_SB.GDCK")  // _EJD: Ejection Dependent Device
    }

    Scope (\_SB.PCI0.EHC1.URTH.UPDK)
    {
        Name (_EJD, "_SB.GDCK")  // _EJD: Ejection Dependent Device
    }

    Name (\_S0, Package (0x04)  // _S0_: S0 System State
    {
        0x00, 
        0x00, 
        0x00, 
        0x00
    })
    Name (\_S3, Package (0x04)  // _S3_: S3 System State
    {
        0x05, 
        0x05, 
        0x00, 
        0x00
    })
    Name (\_S4, Package (0x04)  // _S4_: S4 System State
    {
        0x06, 
        0x06, 
        0x00, 
        0x00
    })
    Name (\_S5, Package (0x04)  // _S5_: S5 System State
    {
        0x07, 
        0x07, 
        0x00, 
        0x00
    })
    Method (\_PTS, 1, NotSerialized)  // _PTS: Prepare To Sleep
    {
        Local0 = 0x01
        If ((Arg0 == \SPS))
        {
            Local0 = 0x00
        }

        If (((Arg0 == 0x00) || (Arg0 >= 0x06)))
        {
            Local0 = 0x00
        }

        If (Local0)
        {
            \SPS = Arg0
            \_SB.PCI0.LPC.EC.HKEY.MHKE (0x00)
            If (\_SB.PCI0.LPC.EC.KBLT)
            {
                \UCMS (0x0D)
            }

            If ((Arg0 == 0x01))
            {
                \FNID = \_SB.PCI0.LPC.EC.HFNI
                \_SB.PCI0.LPC.EC.HFNI = 0x00
                \_SB.PCI0.LPC.EC.HFSP = 0x00
            }

            If ((Arg0 == 0x03))
            {
                \VVPD (0x03)
                \TRAP ()
                \ACST = \_SB.PCI0.LPC.EC.AC._PSR ()
            }

            If ((Arg0 == 0x04))
            {
                \_SB.SLPB._PSW (0x00)
                If (\SPEN)
                {
                    \STEP (0x07)
                }

                \TRAP ()
            }

            If ((Arg0 == 0x05))
            {
                \TRAP ()
            }

            \_SB.PCI0.LPC.EC.BPTS (Arg0)
            If ((Arg0 >= 0x04))
            {
                \_SB.PCI0.LPC.EC.HWLB = 0x00
            }
            Else
            {
                \_SB.PCI0.LPC.EC.HWLB = 0x01
            }

            If ((Arg0 != 0x05))
            {
                \_SB.PCI0.LPC.EC.HCMU = 0x01
                \_SB.GDCK.GPTS (Arg0)
                If (\W98F)
                {
                    \CBRI ()
                }
            }

            \_SB.PCI0.LPC.EC.HKEY.WGPS (Arg0)
        }
    }

    Name (WAKI, Package (0x02)
    {
        0x00, 
        0x00
    })
    Method (\_WAK, 1, NotSerialized)  // _WAK: Wake
    {
        If (((Arg0 == 0x00) || (Arg0 >= 0x05)))
        {
            Return (WAKI) /* \WAKI */
        }

        \SPS = 0x00
        \_SB.PCI0.LPC.EC.HCMU = 0x00
        \_SB.PCI0.LPC.EC.HFSP = 0x80
        \_SB.PCI0.LPC.EC.EVNT (0x01)
        \_SB.PCI0.LPC.EC.HKEY.MHKE (0x01)
        \_SB.PCI0.LPC.EC.FNST ()
        \UCMS (0x0D)
        \LIDB = 0x00
        \_SB.PCI0.IGBE.ABWA (0x00)
        If ((Arg0 == 0x01))
        {
            \FNID = \_SB.PCI0.LPC.EC.HFNI
        }

        If ((Arg0 == 0x03))
        {
            THRM (0x00)
            If (!\_SB.PCI0.LPC.EC.HKEY.DHC4)
            {
                If (\_SB.PCI0.LPC.EC.AC._PSR ())
                {
                    \C4AC = 0x00
                }
                Else
                {
                    \C4AC = 0x01
                }
            }

            If (\OSC4)
            {
                \_SB.PCI0.LPC.C4C3 = 0x00
                Notify (\_PR.CPU0, 0x81) // C-State Change
                If (\MPEN)
                {
                    Notify (\_PR.CPU1, 0x81) // C-State Change
                }
            }
            Else
            {
                If (\WNTF)
                {
                    If (\_SB.PCI0.LPC.EC.HKEY.CKC4 (0x00))
                    {
                        \_SB.PCI0.LPC.C4C3 = 0x00
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.C4C3 = 0x01
                    }
                }
            }

            If ((\ACST != \_SB.PCI0.LPC.EC.AC._PSR ()))
            {
                \_SB.PCI0.LPC.EC.ATMC ()
            }

            If (((\CFGD & 0x01000000) && (\WXPF && (\WSPV <= 0x01))))
            {
                If ((\CFGD & 0xF0))
                {
                    PPMS (0x00)
                }
            }

            If (\VIGD)
            {
                \_SB.PCI0.VID.GLIS (\_SB.LID._LID ())
                Local0 = \_SB.GDCK.GGID ()
                If (((Local0 == 0x00) || (Local0 == 0x01)))
                {
                    \_SB.PCI0.VID.GDCS (0x01)
                }
                Else
                {
                    \_SB.PCI0.VID.GDCS (0x00)
                }

                If (\WVIS)
                {
                    \VBTD ()
                }
            }

            If (\H8DR)
            {
                If (\_SB.PCI0.LPC.EC.HTAB)
                {
                    \_SB.PCI0.LPC.EC.HAM5 &= 0xF3
                    \_SB.PCI0.LPC.EC.HDIM = 0x00
                }
                Else
                {
                    \_SB.PCI0.LPC.EC.HAM5 |= 0x0C
                    \_SB.PCI0.LPC.EC.HDIM = 0x01
                }
            }
        }

        If ((Arg0 == 0x04))
        {
            \NVSS (0x00)
            If (DTSE)
            {
                THRM (0x02)
            }

            If (\W98F)
            {
                Notify (\_SB.SLPB, 0x02) // Device Wake
            }

            If (\WMEF)
            {
                \_SB.PCI0.LPC.EC.BEEP (0x05)
            }

            If (!\W98F)
            {
                \_SB.PCI0.LPC.EC.HSPA = 0x00
            }

            If (!\_SB.PCI0.LPC.EC.HKEY.DHC4)
            {
                If (\_SB.PCI0.LPC.EC.AC._PSR ())
                {
                    \C4AC = 0x00
                }
                Else
                {
                    \C4AC = 0x01
                }
            }

            If (\OSC4)
            {
                Notify (\_PR.CPU0, 0x81) // C-State Change
                If (\MPEN)
                {
                    Notify (\_PR.CPU1, 0x81) // C-State Change
                }
            }
            Else
            {
                If (\WNTF)
                {
                    If (\_SB.PCI0.LPC.EC.HKEY.CKC4 (0x00))
                    {
                        \_SB.PCI0.LPC.C4C3 = 0x00
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.C4C3 = 0x01
                    }
                }
            }

            If (\SPEN)
            {
                \STEP (0x08)
            }

            \_SB.PCI0.LPC.EC.ATMC ()
            If (((\CFGD & 0x01000000) && (\WXPF && (\WSPV <= 0x01))))
            {
                If ((\CFGD & 0xF0))
                {
                    PPMS (0x00)
                }
            }
        }

        If ((\_SB.PCI0.EXP3.PDS ^ \_SB.PCI0.EXP3.XCPF))
        {
            If (\_SB.PCI0.EXP3.PDS)
            {
                \_SB.PCI0.EXP3.XCPF = 0x01
            }
            Else
            {
                \_SB.PCI0.EXP3.XCPF = 0x00
            }

            Notify (\_SB.PCI0.EXP3, 0x00) // Bus Check
        }

        \_SB.GDCK.GWAK (Arg0)
        If ((\_SB.PCI0.LPC.EC.GSID () == 0x03))
        {
            \_SB.PCI0.LPC.EC.BWAK (Arg0)
        }

        \_SB.PCI0.LPC.EC.HKEY.WGWK (Arg0)
        Notify (\_TZ.THM0, 0x80) // Thermal Status Change
        Notify (\_TZ.THM1, 0x80) // Thermal Status Change
        \VSLD (\_SB.LID._LID ())
        If (\VIGD)
        {
            \_SB.PCI0.VID.GLIS (\_SB.LID._LID ())
        }

        If ((\W98F && !\WMEF))
        {
            Notify (\_SB.PCI0.USB0, 0x00) // Bus Check
            Notify (\_SB.PCI0.USB1, 0x00) // Bus Check
        }

        If ((Arg0 < 0x04))
        {
            If ((\RRBF & 0x02))
            {
                Local0 = (Arg0 << 0x08)
                Local0 = (0x2013 | Local0)
                \_SB.PCI0.LPC.EC.HKEY.MHKQ (Local0)
            }
        }

        If ((Arg0 == 0x04))
        {
            Local0 = 0x00
            Local1 = \CSUM (0x00)
            If ((Local1 != \CHKC))
            {
                Local0 = 0x01
                \CHKC = Local1
            }

            Local1 = \CSUM (0x01)
            If ((Local1 != \CHKE))
            {
                Local0 = 0x01
                \CHKE = Local1
            }

            If (Local0)
            {
                Notify (\_SB, 0x00) // Bus Check
            }
        }

        \RRBF = Zero
        Return (WAKI) /* \WAKI */
    }

    Scope (\_SI)
    {
        Method (_SST, 1, NotSerialized)  // _SST: System Status
        {
            If ((Arg0 == 0x00))
            {
                \_SB.PCI0.LPC.EC.LED (0x00, 0x00)
                \_SB.PCI0.LPC.EC.LED (0x07, 0x00)
            }

            If ((Arg0 == 0x01))
            {
                If ((\SPS || \WNTF))
                {
                    \_SB.PCI0.LPC.EC.BEEP (0x05)
                }

                \_SB.PCI0.LPC.EC.LED (0x00, 0x80)
                \_SB.PCI0.LPC.EC.LED (0x07, 0x00)
            }

            If ((Arg0 == 0x02))
            {
                \_SB.PCI0.LPC.EC.LED (0x00, 0x80)
                \_SB.PCI0.LPC.EC.LED (0x07, 0xC0)
            }

            If ((Arg0 == 0x03))
            {
                If ((\SPS > 0x03))
                {
                    \_SB.PCI0.LPC.EC.BEEP (0x07)
                }
                Else
                {
                    If ((\SPS == 0x03))
                    {
                        \_SB.PCI0.LPC.EC.BEEP (0x03)
                        \_SB.GDCK.PEJ3 ()
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.EC.BEEP (0x04)
                    }
                }

                If ((\SPS == 0x03)) {}
                Else
                {
                    \_SB.PCI0.LPC.EC.LED (0x00, 0x80)
                }

                \_SB.PCI0.LPC.EC.LED (0x07, 0xC0)
            }

            If ((Arg0 == 0x04))
            {
                \_SB.PCI0.LPC.EC.HKEY.SVWG ()
                \_SB.PCI0.LPC.EC.BEEP (0x03)
                \_SB.PCI0.LPC.EC.LED (0x07, 0xC0)
            }
        }
    }

    Scope (\_GPE)
    {
        Method (_L18, 0, NotSerialized)  // _Lxx: Level-Triggered GPE
        {
            Local0 = \_SB.PCI0.LPC.EC.HWAK
            \RRBF = Local0
            Sleep (0x0A)
            If ((Local0 & 0x02)) {}
            If ((Local0 & 0x04))
            {
                If (\W98F)
                {
                    Notify (\_SB.SLPB, 0x02) // Device Wake
                }
                Else
                {
                    Notify (\_SB.LID, 0x02) // Device Wake
                }
            }

            If ((Local0 & 0x10))
            {
                Local0 &= 0xF7
                Notify (\_SB.SLPB, 0x02) // Device Wake
            }

            If ((Local0 & 0x08))
            {
                \_SB.GDCK.GGPE ()
                Notify (\_SB.SLPB, 0x02) // Device Wake
            }

            If ((Local0 & 0x10))
            {
                Notify (\_SB.SLPB, 0x02) // Device Wake
            }

            If ((Local0 & 0x40)) {}
            If ((Local0 & 0x80))
            {
                Notify (\_SB.SLPB, 0x02) // Device Wake
            }

            If ((Local0 & 0x0300))
            {
                Notify (\_SB.SLPB, 0x02) // Device Wake
            }
        }

        Method (_L09, 0, NotSerialized)  // _Lxx: Level-Triggered GPE
        {
            If (\_SB.PCI0.EXP0.PSP0)
            {
                \_SB.PCI0.EXP0.PSP0 = 0x01
                Notify (\_SB.PCI0.EXP0, 0x02) // Device Wake
            }

            If (\_SB.PCI0.EXP1.PSP1)
            {
                \_SB.PCI0.EXP1.PSP1 = 0x01
                Notify (\_SB.PCI0.EXP1, 0x02) // Device Wake
            }

            If (\_SB.PCI0.EXP2.PSP2)
            {
                \_SB.PCI0.EXP2.PSP2 = 0x01
                Notify (\_SB.PCI0.EXP2, 0x02) // Device Wake
            }

            If (\_SB.PCI0.EXP3.PSP3)
            {
                \_SB.PCI0.EXP3.PSP3 = 0x01
                \_SB.PCI0.EXP3.PMCS = 0x01
                Notify (\_SB.PCI0.EXP3, 0x02) // Device Wake
            }

            If (\_SB.PCI0.EXP4.PSP4)
            {
                \_SB.PCI0.EXP4.PSP4 = 0x01
                \_SB.PCI0.EXP4.PMS4 = 0x01
                Notify (\_SB.PCI0.EXP4, 0x02) // Device Wake
            }
        }

        Method (_L01, 0, NotSerialized)  // _Lxx: Level-Triggered GPE
        {
            If (\_SB.PCI0.EXP3.HPCS)
            {
                \_SB.PCI0.EXP3.HPCS = 0x01
                If (\_SB.PCI0.EXP3.ABP)
                {
                    \_SB.PCI0.EXP3.ABP = 0x01
                }

                If (\_SB.PCI0.EXP3.PDC)
                {
                    \_SB.PCI0.EXP3.PDC = 0x01
                    \_SB.PCI0.EXP3.XCPF = 0x00
                    Notify (\_SB.PCI0.EXP3, 0x00) // Bus Check
                    If (\_SB.PCI0.EXP3.PDS)
                    {
                        \_SB.PCI0.EXP3.XCPF = 0x01
                        Sleep (0x64)
                        Notify (\_SB.PCI0.EXP3.EXUP, 0x01) // Device Check
                    }
                }
            }
        }

        Method (_L02, 0, NotSerialized)  // _Lxx: Level-Triggered GPE
        {
            \_SB.PCI0.LPC.SWGE = 0x00
            If ((\SWGP & 0x01))
            {
                \SWGP &= ~0x01
                If (\_SB.PCI0.LPC.EC.HKEY.DHKC)
                {
                    If (DT02)
                    {
                        \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x6022)
                    }
                }

                Notify (\_TZ.THM1, 0x80) // Thermal Status Change
                If (\SPEN)
                {
                    If (\OSPX)
                    {
                        Notify (\_PR.CPU0, 0x80) // Performance Capability Change
                        If (\MPEN)
                        {
                            Notify (\_PR.CPU1, 0x80) // Performance Capability Change
                        }
                    }
                    Else
                    {
                        If (DT00)
                        {
                            \STEP (0x09)
                        }
                        Else
                        {
                            \STEP (0x0A)
                        }
                    }
                }
            }

            If ((\CWUE && (\SWGP & 0x02)))
            {
                \SWGP &= ~0x02
                If (\OSC4)
                {
                    Notify (\_PR.CPU0, 0x81) // C-State Change
                    If (\MPEN)
                    {
                        Notify (\_PR.CPU1, 0x81) // C-State Change
                    }
                }
                Else
                {
                    If (\_SB.PCI0.LPC.EC.HKEY.CKC4 (0x00))
                    {
                        \_SB.PCI0.LPC.C4C3 = 0x00
                    }
                    Else
                    {
                        \_SB.PCI0.LPC.C4C3 = 0x01
                    }
                }
            }
        }

        Method (_L06, 0, NotSerialized)  // _Lxx: Level-Triggered GPE
        {
            If (\_SB.PCI0.VID.GSSE)
            {
                \_SB.PCI0.VID.OPRN ()
            }
            Else
            {
                \_SB.PCI0.LPC.SCIS = 0x01
            }
        }
    }

    Scope (\_SB.PCI0.LPC.EC.HKEY)
    {
        Method (MHQT, 1, NotSerialized)
        {
            If ((\WNTF && \TATC))
            {
                If ((Arg0 == 0x00))
                {
                    Local0 = \TATC
                    Return (Local0)
                }
                Else
                {
                    If ((Arg0 == 0x01))
                    {
                        Local0 = \TDFA
                        Local0 += (\TDTA << 0x04)
                        Local0 += (\TDFD << 0x08)
                        Local0 += (\TDTD << 0x0C)
                        Local0 += (\TNFT << 0x10)
                        Local0 += (\TNTT << 0x14)
                        Return (Local0)
                    }
                    Else
                    {
                        If ((Arg0 == 0x02))
                        {
                            Local0 = \TCFA
                            Local0 += (\TCTA << 0x04)
                            Local0 += (\TCFD << 0x08)
                            Local0 += (\TCTD << 0x0C)
                            Return (Local0)
                        }
                        Else
                        {
                            If ((Arg0 == 0x03)) {}
                            Else
                            {
                                If ((Arg0 == 0x04))
                                {
                                    Local0 = \TATW
                                    Return (Local0)
                                }
                                Else
                                {
                                    Noop
                                }
                            }
                        }
                    }
                }
            }

            Return (0x00)
        }

        Method (MHAT, 1, NotSerialized)
        {
            If ((\WNTF && \TATC))
            {
                Local0 = (Arg0 & 0xFF)
                If (!ATMV (Local0))
                {
                    Return (0x00)
                }

                Local0 = ((Arg0 >> 0x08) & 0xFF)
                If (!ATMV (Local0))
                {
                    Return (0x00)
                }

                \TCFA = (Arg0 & 0x0F)
                \TCTA = ((Arg0 >> 0x04) & 0x0F)
                \TCFD = ((Arg0 >> 0x08) & 0x0F)
                \TCTD = ((Arg0 >> 0x0C) & 0x0F)
                ATMC ()
                Return (0x01)
            }

            Return (0x00)
        }

        Method (MHGT, 1, NotSerialized)
        {
            If ((\WNTF && \TATC))
            {
                Local0 = (\TSFT << 0x10)
                Local0 += (\TSTT << 0x14)
                Local1 = (Arg0 & 0xFF)
                If (!ATMV (Local1))
                {
                    Return (0xFFFF)
                }

                Local1 = (Arg0 & 0x0F)
                If ((Local1 == 0x00))
                {
                    Local0 += \TIF0
                }
                Else
                {
                    If ((Local1 == 0x01))
                    {
                        Local0 += \TIF1
                    }
                    Else
                    {
                        If ((Local1 == 0x02))
                        {
                            Local0 += \TIF2
                        }
                        Else
                        {
                            Local0 += 0xFF
                        }
                    }
                }

                Local1 = ((Arg0 >> 0x04) & 0x0F)
                If ((Local1 == 0x00))
                {
                    Local0 += (\TIT0 << 0x08)
                }
                Else
                {
                    If ((Local1 == 0x01))
                    {
                        Local0 += (\TIT1 << 0x08)
                    }
                    Else
                    {
                        If ((Local1 == 0x02))
                        {
                            Local0 += (\TIT2 << 0x08)
                        }
                        Else
                        {
                            Local0 += (0xFF << 0x08)
                        }
                    }
                }

                Return (Local0)
            }

            Return (0x00)
        }

        Method (ATMV, 1, NotSerialized)
        {
            Local1 = (Arg0 & 0x0F)
            Local0 = \TNFT
            If ((Local1 >= Local0))
            {
                Return (0x00)
            }

            Local2 = ((Arg0 >> 0x04) & 0x0F)
            Local0 = \TNTT
            If ((Local2 >= Local0))
            {
                Return (0x00)
            }

            If (\TATL)
            {
                If ((Local1 ^ Local2))
                {
                    Return (0x00)
                }
            }

            Return (0x01)
        }
    }

    Scope (\_SB.PCI0.LPC.EC)
    {
        Method (ATMC, 0, NotSerialized)
        {
            If ((\WNTF && \TATC))
            {
                If (HPAC)
                {
                    Local0 = \TCFA
                    Local1 = \TCTA
                    ATMX = ((Local1 << 0x04) | Local0)
                    If ((\TCTA == 0x00))
                    {
                        \TCRT = \TCR0
                        \TPSV = \TPS0
                    }
                    Else
                    {
                        If ((\TCTA == 0x01))
                        {
                            \TCRT = \TCR1
                            \TPSV = \TPS1
                        }
                        Else
                        {
                        }
                    }
                }
                Else
                {
                    Local0 = \TCFD
                    Local1 = \TCTD
                    ATMX = ((Local1 << 0x04) | Local0)
                    If ((\TCTD == 0x00))
                    {
                        \TCRT = \TCR0
                        \TPSV = \TPS0
                    }
                    Else
                    {
                        If ((\TCTD == 0x01))
                        {
                            \TCRT = \TCR1
                            \TPSV = \TPS1
                        }
                        Else
                        {
                        }
                    }
                }

                Notify (\_TZ.THM0, 0x81) // Thermal Trip Point Change
                THRM (0x01)
            }
        }
    }

    Scope (\_TZ)
    {
        ThermalZone (THM0)
        {
            Method (_CRT, 0, NotSerialized)  // _CRT: Critical Temperature
            {
                Return (C2K (0x7F))
            }

            Method (_TMP, 0, NotSerialized)  // _TMP: Temperature
            {
                If (\H8DR)
                {
                    Local0 = \_SB.PCI0.LPC.EC.TMP0
                    Local1 = \_SB.PCI0.LPC.EC.HT12
                    Local2 = \_SB.PCI0.LPC.EC.HT13
                }
                Else
                {
                    Local0 = \RBEC (0x78)
                    Local1 = (\RBEC (0x20) & 0x40)
                    Local2 = (\RBEC (0x20) & 0x80)
                }

                If (Local2)
                {
                    Return (C2K (0x80))
                }

                If (!\_SB.PCI0.LPC.EC.HKEY.DHKC)
                {
                    If (Local1)
                    {
                        Return (C2K (0x80))
                    }
                }

                Return (C2K (Local0))
            }
        }

        ThermalZone (THM1)
        {
            Method (_PSL, 0, NotSerialized)  // _PSL: Passive List
            {
                If (\MPEN)
                {
                    Return (Package (0x02)
                    {
                        \_PR.CPU0, 
                        \_PR.CPU1
                    })
                }

                Return (Package (0x01)
                {
                    \_PR.CPU0
                })
            }

            Method (_CRT, 0, NotSerialized)  // _CRT: Critical Temperature
            {
                Return (\TCRT)
            }

            Method (_PSV, 0, NotSerialized)  // _PSV: Passive Temperature
            {
                Return (\TPSV)
            }

            Method (_TC1, 0, NotSerialized)  // _TC1: Thermal Constant 1
            {
                Return (\TTC1)
            }

            Method (_TC2, 0, NotSerialized)  // _TC2: Thermal Constant 2
            {
                Return (\TTC2)
            }

            Method (_TSP, 0, NotSerialized)  // _TSP: Thermal Sampling Period
            {
                Return (\TTSP)
            }

            Method (_TMP, 0, NotSerialized)  // _TMP: Temperature
            {
                If (\DTSE)
                {
                    THRM (0x02)
                    Local0 = DTS1 /* \DTS1 */
                    If ((DTS0 >= DTS1))
                    {
                        Local0 = DTS0 /* \DTS0 */
                    }

                    If (!\_SB.PCI0.LPC.EC.HKEY.DHKC)
                    {
                        If (DT02)
                        {
                            Local0 = (\TCRT + 0x01)
                            Return (Local0)
                        }
                    }

                    Return (C2K (Local0))
                }
                Else
                {
                    Return (\_TZ.THM0._TMP ())
                }
            }
        }

        Method (C2K, 1, NotSerialized)
        {
            Local0 = ((Arg0 * 0x0A) + 0x0AAC)
            If ((Local0 <= 0x0AAC))
            {
                Local0 = 0x0BB8
            }

            If ((Local0 > 0x0FAC))
            {
                Local0 = 0x0BB8
            }

            Return (Local0)
        }
    }

    Scope (\_SB.PCI0.LPC.EC)
    {
        Method (_Q40, 0, NotSerialized)  // _Qxx: EC Query
        {
            Notify (\_TZ.THM0, 0x80) // Thermal Status Change
            If (\H8DR)
            {
                Local0 = \_SB.PCI0.LPC.EC.HT11
                Local1 = \_SB.PCI0.LPC.EC.HT12
            }
            Else
            {
                Local0 = (\RBEC (0x20) & 0x20)
                Local1 = (\RBEC (0x20) & 0x40)
            }

            If (\_SB.PCI0.LPC.EC.HKEY.DHKC)
            {
                If (Local1)
                {
                    \_SB.PCI0.LPC.EC.HKEY.MHKQ (0x6022)
                }
            }

            If (VIGD)
            {
                Noop
            }
            Else
            {
                \VTHR ()
            }

            If (\SPEN)
            {
                If (\OSPX)
                {
                    Notify (\_PR.CPU0, 0x80) // Performance Capability Change
                    If (\MPEN)
                    {
                        Notify (\_PR.CPU1, 0x80) // Performance Capability Change
                    }
                }
                Else
                {
                    If ((\_SB.PCI0.LPC.EC.HT00 || \_SB.PCI0.LPC.EC.HT10))
                    {
                        \STEP (0x09)
                    }
                    Else
                    {
                        \STEP (0x0A)
                    }
                }
            }
        }
    }

    Name (GPIC, 0x00)
    Method (_PIC, 1, NotSerialized)  // _PIC: Interrupt Model
    {
        \GPIC = Arg0
    }

    OperationRegion (SMI0, SystemIO, 0xB2, 0x01)
    Field (SMI0, ByteAcc, NoLock, Preserve)
    {
        APMC,   8
    }

    Field (MNVS, AnyAcc, NoLock, Preserve)
    {
        Offset (0xFC0), 
        CMD,    8, 
        ERR,    32, 
        PAR0,   32, 
        PAR1,   32, 
        PAR2,   32, 
        PAR3,   32
    }

    Mutex (MSMI, 0x07)
    Method (SMI, 5, NotSerialized)
    {
        Acquire (MSMI, 0xFFFF)
        CMD = Arg0
        PAR0 = Arg1
        PAR1 = Arg2
        PAR2 = Arg3
        PAR3 = Arg4
        APMC = 0xF5
        While ((ERR == 0x01))
        {
            Sleep (0x64)
            APMC = 0xF5
        }

        Local0 = PAR0 /* \PAR0 */
        Release (MSMI)
        Return (Local0)
    }

    Method (RPCI, 1, NotSerialized)
    {
        Return (SMI (0x00, 0x00, Arg0, 0x00, 0x00))
    }

    Method (WPCI, 2, NotSerialized)
    {
        SMI (0x00, 0x01, Arg0, Arg1, 0x00)
    }

    Method (MPCI, 3, NotSerialized)
    {
        SMI (0x00, 0x02, Arg0, Arg1, Arg2)
    }

    Method (RBEC, 1, NotSerialized)
    {
        Return (SMI (0x00, 0x03, Arg0, 0x00, 0x00))
    }

    Method (WBEC, 2, NotSerialized)
    {
        SMI (0x00, 0x04, Arg0, Arg1, 0x00)
    }

    Method (MBEC, 3, NotSerialized)
    {
        SMI (0x00, 0x05, Arg0, Arg1, Arg2)
    }

    Method (RISA, 1, NotSerialized)
    {
        Return (SMI (0x00, 0x06, Arg0, 0x00, 0x00))
    }

    Method (WISA, 2, NotSerialized)
    {
        SMI (0x00, 0x07, Arg0, Arg1, 0x00)
    }

    Method (MISA, 3, NotSerialized)
    {
        SMI (0x00, 0x08, Arg0, Arg1, Arg2)
    }

    Method (VEXP, 0, NotSerialized)
    {
        SMI (0x01, 0x00, 0x00, 0x00, 0x00)
    }

    Method (VUPS, 1, NotSerialized)
    {
        SMI (0x01, 0x01, Arg0, 0x00, 0x00)
    }

    Method (VSDS, 2, NotSerialized)
    {
        SMI (0x01, 0x02, Arg0, Arg1, 0x00)
    }

    Method (VDDC, 0, NotSerialized)
    {
        SMI (0x01, 0x03, 0x00, 0x00, 0x00)
    }

    Method (VVPD, 1, NotSerialized)
    {
        SMI (0x01, 0x04, Arg0, 0x00, 0x00)
    }

    Method (VNRS, 1, NotSerialized)
    {
        SMI (0x01, 0x05, Arg0, 0x00, 0x00)
    }

    Method (GLPW, 0, NotSerialized)
    {
        Return (SMI (0x01, 0x06, 0x00, 0x00, 0x00))
    }

    Method (VSLD, 1, NotSerialized)
    {
        SMI (0x01, 0x07, Arg0, 0x00, 0x00)
    }

    Method (VEVT, 1, NotSerialized)
    {
        Return (SMI (0x01, 0x08, Arg0, 0x00, 0x00))
    }

    Method (VTHR, 0, NotSerialized)
    {
        Return (SMI (0x01, 0x09, 0x00, 0x00, 0x00))
    }

    Method (VBRC, 1, NotSerialized)
    {
        SMI (0x01, 0x0A, Arg0, 0x00, 0x00)
    }

    Method (VBRG, 0, NotSerialized)
    {
        Return (SMI (0x01, 0x0E, 0x00, 0x00, 0x00))
    }

    Method (VBTD, 0, NotSerialized)
    {
        Return (SMI (0x01, 0x0F, 0x00, 0x00, 0x00))
    }

    Method (UCMS, 1, NotSerialized)
    {
        Return (SMI (0x02, Arg0, 0x00, 0x00, 0x00))
    }

    Method (BHDP, 2, NotSerialized)
    {
        Return (SMI (0x03, 0x00, Arg0, Arg1, 0x00))
    }

    Method (DHDP, 1, NotSerialized)
    {
        Return (SMI (0x03, 0x01, Arg0, 0x00, 0x00))
    }

    Method (STEP, 1, NotSerialized)
    {
        SMI (0x04, Arg0, 0x00, 0x00, 0x00)
    }

    Method (TRAP, 0, NotSerialized)
    {
        SMI (0x05, 0x00, 0x00, 0x00, 0x00)
    }

    Method (CBRI, 0, NotSerialized)
    {
        SMI (0x05, 0x01, 0x00, 0x00, 0x00)
    }

    Method (ASSI, 1, NotSerialized)
    {
        SMI (0x05, 0x05, Arg0, 0x00, 0x00)
    }

    Method (HSWA, 1, NotSerialized)
    {
        If ((Arg0 <= 0x01))
        {
            Return (SMI (0x05, 0x04, Arg0, 0x00, 0x00))
        }
        Else
        {
            Return (0x01)
        }
    }

    Method (ACBS, 1, NotSerialized)
    {
        Return (SMI (0x05, 0x06, Arg0, 0x00, 0x00))
    }

    Method (BLTH, 1, NotSerialized)
    {
        Return (SMI (0x06, Arg0, 0x00, 0x00, 0x00))
    }

    Method (FISP, 0, NotSerialized)
    {
        SMI (0x07, 0x00, 0x00, 0x00, 0x00)
    }

    Method (ATCC, 1, NotSerialized)
    {
        SMI (0x08, Arg0, 0x00, 0x00, 0x00)
    }

    Method (WGSV, 1, NotSerialized)
    {
        Return (SMI (0x09, Arg0, 0x00, 0x00, 0x00))
    }

    Method (THRM, 1, NotSerialized)
    {
        Return (SMI (0x0A, Arg0, 0x00, 0x00, 0x00))
    }

    Method (PPMS, 1, NotSerialized)
    {
        Return (SMI (0x0B, Arg0, 0x00, 0x00, 0x00))
    }

    Method (TPHY, 1, NotSerialized)
    {
        SMI (0x0C, Arg0, 0x00, 0x00, 0x00)
    }

    Method (CSUM, 1, NotSerialized)
    {
        Return (SMI (0x0E, Arg0, 0x00, 0x00, 0x00))
    }

    Method (NVSS, 1, NotSerialized)
    {
        Return (SMI (0x0F, Arg0, 0x00, 0x00, 0x00))
    }

    Method (DPIO, 2, NotSerialized)
    {
        If (!Arg0)
        {
            Return (0x00)
        }

        If ((Arg0 > 0xF0))
        {
            Return (0x00)
        }

        If ((Arg0 > 0xB4))
        {
            If (Arg1)
            {
                Return (0x02)
            }
            Else
            {
                Return (0x01)
            }
        }

        If ((Arg0 > 0x78))
        {
            Return (0x03)
        }

        Return (0x04)
    }

    Method (DUDM, 2, NotSerialized)
    {
        If (!Arg1)
        {
            Return (0xFF)
        }

        If ((Arg0 > 0x5A))
        {
            Return (0x00)
        }

        If ((Arg0 > 0x3C))
        {
            Return (0x01)
        }

        If ((Arg0 > 0x2D))
        {
            Return (0x02)
        }

        If ((Arg0 > 0x1E))
        {
            Return (0x03)
        }

        If ((Arg0 > 0x14))
        {
            Return (0x04)
        }

        Return (0x05)
    }

    Method (DMDM, 2, NotSerialized)
    {
        If (Arg1)
        {
            Return (0x00)
        }

        If (!Arg0)
        {
            Return (0x00)
        }

        If ((Arg0 > 0x96))
        {
            Return (0x01)
        }

        If ((Arg0 > 0x78))
        {
            Return (0x02)
        }

        Return (0x03)
    }

    Method (UUDM, 2, NotSerialized)
    {
        If (!(Arg0 & 0x04))
        {
            Return (0x00)
        }

        If ((Arg1 & 0x20))
        {
            Return (0x14)
        }

        If ((Arg1 & 0x10))
        {
            Return (0x1E)
        }

        If ((Arg1 & 0x08))
        {
            Return (0x2D)
        }

        If ((Arg1 & 0x04))
        {
            Return (0x3C)
        }

        If ((Arg1 & 0x02))
        {
            Return (0x5A)
        }

        If ((Arg1 & 0x01))
        {
            Return (0x78)
        }

        Return (0x00)
    }

    Method (UMDM, 4, NotSerialized)
    {
        If (!(Arg0 & 0x02))
        {
            Return (0x00)
        }

        If ((Arg1 & 0x04))
        {
            Return (Arg3)
        }

        If ((Arg1 & 0x02))
        {
            If ((Arg3 <= 0x78))
            {
                Return (0xB4)
            }
            Else
            {
                Return (Arg3)
            }
        }

        If ((Arg2 & 0x04))
        {
            If ((Arg3 <= 0xB4))
            {
                Return (0xF0)
            }
            Else
            {
                Return (Arg3)
            }
        }

        Return (0x00)
    }

    Method (UPIO, 4, NotSerialized)
    {
        If (!(Arg0 & 0x02))
        {
            If ((Arg2 == 0x02))
            {
                Return (0xF0)
            }
            Else
            {
                Return (0x0384)
            }
        }

        If ((Arg1 & 0x02))
        {
            Return (Arg3)
        }

        If ((Arg1 & 0x01))
        {
            If ((Arg3 <= 0x78))
            {
                Return (0xB4)
            }
            Else
            {
                Return (Arg3)
            }
        }

        If ((Arg2 == 0x02))
        {
            Return (0xF0)
        }
        Else
        {
            Return (0x0384)
        }
    }

    Method (FDMA, 2, NotSerialized)
    {
        If ((Arg1 != 0xFF))
        {
            Return ((Arg1 | 0x40))
        }

        If ((Arg0 >= 0x03))
        {
            Return (((Arg0 - 0x02) | 0x20))
        }

        If (Arg0)
        {
            Return (0x12)
        }

        Return (0x00)
    }

    Method (FPIO, 1, NotSerialized)
    {
        If ((Arg0 >= 0x03))
        {
            Return ((Arg0 | 0x08))
        }

        If ((Arg0 == 0x01))
        {
            Return (0x01)
        }

        Return (0x00)
    }

    Method (SCMP, 2, NotSerialized)
    {
        Local0 = SizeOf (Arg0)
        If ((Local0 != SizeOf (Arg1)))
        {
            Return (One)
        }

        Local0++
        Name (STR1, Buffer (Local0) {})
        Name (STR2, Buffer (Local0) {})
        STR1 = Arg0
        STR2 = Arg1
        Local1 = Zero
        While ((Local1 < Local0))
        {
            Local2 = DerefOf (Index (STR1, Local1))
            Local3 = DerefOf (Index (STR2, Local1))
            If ((Local2 != Local3))
            {
                Return (One)
            }

            Local1++
        }

        Return (Zero)
    }

    Name (SPS, 0x00)
    Name (OSIF, 0x00)
    Name (W98F, 0x00)
    Name (WNTF, 0x00)
    Name (WMEF, 0x00)
    Name (WXPF, 0x00)
    Name (WVIS, 0x00)
    Name (WSPV, 0x00)
    Name (LNUX, 0x00)
    Name (H8DR, 0x00)
    Name (MEMX, 0x00)
    Name (ACST, 0x00)
    Name (FNID, 0x00)
    Name (RRBF, 0x00)
    Name (NBCF, 0x00)
}



ECDT
----
[000h 0000   4]                    Signature : "ECDT"    [Embedded Controller Boot Resources Table]
[004h 0004   4]                 Table Length : 00000052
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : 34
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : "LNVO"
[020h 0032   4]        Asl Compiler Revision : 00000001


[024h 0036  12]      Command/Status Register : [Generic Address Structure]
[024h 0036   1]                     Space ID : 01 [SystemIO]
[025h 0037   1]                    Bit Width : 08
[026h 0038   1]                   Bit Offset : 00
[027h 0039   1]         Encoded Access Width : 00 [Undefined/Legacy]
[028h 0040   8]                      Address : 0000000000000066

[030h 0048  12]                Data Register : [Generic Address Structure]
[030h 0048   1]                     Space ID : 01 [SystemIO]
[031h 0049   1]                    Bit Width : 08
[032h 0050   1]                   Bit Offset : 00
[033h 0051   1]         Encoded Access Width : 00 [Undefined/Legacy]
[034h 0052   8]                      Address : 0000000000000062

[03Ch 0060   4]                          UID : 00000000
[040h 0064   1]                   GPE Number : 12
[041h 0065  17]                     Namepath : "\_SB.PCI0.LPC.EC"

Raw Table Data: Length 82 (0x52)

  0000: 45 43 44 54 52 00 00 00 01 34 4C 45 4E 4F 56 4F  ECDTR....4LENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 4C 4E 56 4F  TP-7S   @...LNVO
  0020: 01 00 00 00 01 08 00 00 66 00 00 00 00 00 00 00  ........f.......
  0030: 01 08 00 00 62 00 00 00 00 00 00 00 00 00 00 00  ....b...........
  0040: 12 5C 5F 53 42 2E 50 43 49 30 2E 4C 50 43 2E 45  .\_SB.PCI0.LPC.E
  0050: 43 00                                            C.


FACP
----
[000h 0000   4]                    Signature : "FACP"    [Fixed ACPI Description Table (FADT)]
[004h 0004   4]                 Table Length : 000000F4
[008h 0008   1]                     Revision : 03
[009h 0009   1]                     Checksum : 06
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : "LNVO"
[020h 0032   4]        Asl Compiler Revision : 00000001

[024h 0036   4]                 FACS Address : 7E6E4000
[028h 0040   4]                 DSDT Address : 7E6BD1DB
[02Ch 0044   1]                        Model : 00
[02Dh 0045   1]                   PM Profile : 02 [Mobile]
[02Eh 0046   2]                SCI Interrupt : 0009
[030h 0048   4]             SMI Command Port : 000000B2
[034h 0052   1]            ACPI Enable Value : F0
[035h 0053   1]           ACPI Disable Value : F1
[036h 0054   1]               S4BIOS Command : 00
[037h 0055   1]              P-State Control : F3
[038h 0056   4]     PM1A Event Block Address : 00001000
[03Ch 0060   4]     PM1B Event Block Address : 00000000
[040h 0064   4]   PM1A Control Block Address : 00001004
[044h 0068   4]   PM1B Control Block Address : 00000000
[048h 0072   4]    PM2 Control Block Address : 00001020
[04Ch 0076   4]       PM Timer Block Address : 00001008
[050h 0080   4]           GPE0 Block Address : 00001028
[054h 0084   4]           GPE1 Block Address : 00000000
[058h 0088   1]       PM1 Event Block Length : 04
[059h 0089   1]     PM1 Control Block Length : 02
[05Ah 0090   1]     PM2 Control Block Length : 01
[05Bh 0091   1]        PM Timer Block Length : 04
[05Ch 0092   1]            GPE0 Block Length : 08
[05Dh 0093   1]            GPE1 Block Length : 00
[05Eh 0094   1]             GPE1 Base Offset : 00
[05Fh 0095   1]                 _CST Support : 85
[060h 0096   2]                   C2 Latency : 0001
[062h 0098   2]                   C3 Latency : 0023
[064h 0100   2]               CPU Cache Size : 0000
[066h 0102   2]           Cache Flush Stride : 0000
[068h 0104   1]            Duty Cycle Offset : 01
[069h 0105   1]             Duty Cycle Width : 03
[06Ah 0106   1]          RTC Day Alarm Index : 0D
[06Bh 0107   1]        RTC Month Alarm Index : 00
[06Ch 0108   1]            RTC Century Index : 32
[06Dh 0109   2]   Boot Flags (decoded below) : 0012
               Legacy Devices Supported (V2) : 0
            8042 Present on ports 60/64 (V2) : 1
                        VGA Not Present (V4) : 0
                      MSI Not Supported (V4) : 0
                PCIe ASPM Not Supported (V4) : 1
                   CMOS RTC Not Present (V5) : 0
[06Fh 0111   1]                     Reserved : 00
[070h 0112   4]        Flags (decoded below) : 0000C2AD
      WBINVD instruction is operational (V1) : 1
              WBINVD flushes all caches (V1) : 0
                    All CPUs support C1 (V1) : 1
                  C2 works on MP system (V1) : 1
            Control Method Power Button (V1) : 0
            Control Method Sleep Button (V1) : 1
        RTC wake not in fixed reg space (V1) : 0
            RTC can wake system from S4 (V1) : 1
                        32-bit PM Timer (V1) : 0
                      Docking Supported (V1) : 1
               Reset Register Supported (V2) : 0
                            Sealed Case (V3) : 0
                    Headless - No Video (V3) : 0
        Use native instr after SLP_TYPx (V3) : 0
              PCIEXP_WAK Bits Supported (V4) : 1
                     Use Platform Timer (V4) : 1
               RTC_STS valid on S4 wake (V4) : 0
                Remote Power-on capable (V4) : 0
                 Use APIC Cluster Model (V4) : 0
     Use APIC Physical Destination Mode (V4) : 0
                       Hardware Reduced (V5) : 0
                      Low Power S0 Idle (V5) : 0

[074h 0116  12]               Reset Register : [Generic Address Structure]
[074h 0116   1]                     Space ID : 01 [SystemIO]
[075h 0117   1]                    Bit Width : 08
[076h 0118   1]                   Bit Offset : 00
[077h 0119   1]         Encoded Access Width : 00 [Undefined/Legacy]
[078h 0120   8]                      Address : 0000000000000CF9

[080h 0128   1]         Value to cause reset : 06
[081h 0129   2]    ARM Flags (decoded below) : 0000
                              PSCI Compliant : 0
                       Must use HVC for PSCI : 0

[083h 0131   1]          FADT Minor Revision : 00
[084h 0132   8]                 FACS Address : 000000007E6E4000
[08Ch 0140   8]                 DSDT Address : 000000007E6BD1DB
[094h 0148  12]             PM1A Event Block : [Generic Address Structure]
[094h 0148   1]                     Space ID : 01 [SystemIO]
[095h 0149   1]                    Bit Width : 20
[096h 0150   1]                   Bit Offset : 00
[097h 0151   1]         Encoded Access Width : 00 [Undefined/Legacy]
[098h 0152   8]                      Address : 0000000000001000

[0A0h 0160  12]             PM1B Event Block : [Generic Address Structure]
[0A0h 0160   1]                     Space ID : 00 [SystemMemory]
[0A1h 0161   1]                    Bit Width : 00
[0A2h 0162   1]                   Bit Offset : 00
[0A3h 0163   1]         Encoded Access Width : 00 [Undefined/Legacy]
[0A4h 0164   8]                      Address : 0000000000000000

[0ACh 0172  12]           PM1A Control Block : [Generic Address Structure]
[0ACh 0172   1]                     Space ID : 01 [SystemIO]
[0ADh 0173   1]                    Bit Width : 10
[0AEh 0174   1]                   Bit Offset : 00
[0AFh 0175   1]         Encoded Access Width : 00 [Undefined/Legacy]
[0B0h 0176   8]                      Address : 0000000000001004

[0B8h 0184  12]           PM1B Control Block : [Generic Address Structure]
[0B8h 0184   1]                     Space ID : 00 [SystemMemory]
[0B9h 0185   1]                    Bit Width : 00
[0BAh 0186   1]                   Bit Offset : 00
[0BBh 0187   1]         Encoded Access Width : 00 [Undefined/Legacy]
[0BCh 0188   8]                      Address : 0000000000000000

[0C4h 0196  12]            PM2 Control Block : [Generic Address Structure]
[0C4h 0196   1]                     Space ID : 01 [SystemIO]
[0C5h 0197   1]                    Bit Width : 08
[0C6h 0198   1]                   Bit Offset : 00
[0C7h 0199   1]         Encoded Access Width : 00 [Undefined/Legacy]
[0C8h 0200   8]                      Address : 0000000000001020

[0D0h 0208  12]               PM Timer Block : [Generic Address Structure]
[0D0h 0208   1]                     Space ID : 01 [SystemIO]
[0D1h 0209   1]                    Bit Width : 20
[0D2h 0210   1]                   Bit Offset : 00
[0D3h 0211   1]         Encoded Access Width : 00 [Undefined/Legacy]
[0D4h 0212   8]                      Address : 0000000000001008

[0DCh 0220  12]                   GPE0 Block : [Generic Address Structure]
[0DCh 0220   1]                     Space ID : 01 [SystemIO]
[0DDh 0221   1]                    Bit Width : 20
[0DEh 0222   1]                   Bit Offset : 00
[0DFh 0223   1]         Encoded Access Width : 00 [Undefined/Legacy]
[0E0h 0224   8]                      Address : 0000000000001028

[0E8h 0232  12]                   GPE1 Block : [Generic Address Structure]
[0E8h 0232   1]                     Space ID : 01 [SystemIO]
[0E9h 0233   1]                    Bit Width : 20
[0EAh 0234   1]                   Bit Offset : 00
[0EBh 0235   1]         Encoded Access Width : 00 [Undefined/Legacy]
[0ECh 0236   8]                      Address : 000000000000102C


Raw Table Data: Length 244 (0xF4)

  0000: 46 41 43 50 F4 00 00 00 03 06 4C 45 4E 4F 56 4F  FACP......LENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 4C 4E 56 4F  TP-7S   @...LNVO
  0020: 01 00 00 00 00 40 6E 7E DB D1 6B 7E 00 02 09 00  .....@n~..k~....
  0030: B2 00 00 00 F0 F1 00 F3 00 10 00 00 00 00 00 00  ................
  0040: 04 10 00 00 00 00 00 00 20 10 00 00 08 10 00 00  ........ .......
  0050: 28 10 00 00 00 00 00 00 04 02 01 04 08 00 00 85  (...............
  0060: 01 00 23 00 00 00 00 00 01 03 0D 00 32 12 00 00  ..#.........2...
  0070: AD C2 00 00 01 08 00 00 F9 0C 00 00 00 00 00 00  ................
  0080: 06 00 00 00 00 40 6E 7E 00 00 00 00 DB D1 6B 7E  .....@n~......k~
  0090: 00 00 00 00 01 20 00 00 00 10 00 00 00 00 00 00  ..... ..........
  00A0: 00 00 00 00 00 00 00 00 00 00 00 00 01 10 00 00  ................
  00B0: 04 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  00C0: 00 00 00 00 01 08 00 00 20 10 00 00 00 00 00 00  ........ .......
  00D0: 01 20 00 00 08 10 00 00 00 00 00 00 01 20 00 00  . ........... ..
  00E0: 28 10 00 00 00 00 00 00 01 20 00 00 2C 10 00 00  (........ ..,...
  00F0: 00 00 00 00                                      ....


FACS
----
[000h 0000   4]                    Signature : "FACS"
[004h 0004   4]                       Length : 00000040
[008h 0008   4]           Hardware Signature : 00001449
[00Ch 0012   4]    32 Firmware Waking Vector : 00000000
[010h 0016   4]                  Global Lock : 00000000
[014h 0020   4]        Flags (decoded below) : 00000000
                      S4BIOS Support Present : 0
                  64-bit Wake Supported (V2) : 0
[018h 0024   8]    64 Firmware Waking Vector : 0000000000000000
[020h 0032   1]                      Version : 01
[021h 0033   3]                     Reserved : 000000
[024h 0036   4]    OspmFlags (decoded below) : 00000000
               64-bit Wake Env Required (V2) : 0

Raw Table Data: Length 64 (0x40)

  0000: 46 41 43 53 40 00 00 00 49 14 00 00 00 00 00 00  FACS@...I.......
  0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0020: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................


HPET
----
[000h 0000   4]                    Signature : "HPET"    [High Precision Event Timer table]
[004h 0004   4]                 Table Length : 00000038
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : 7F
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : "LNVO"
[020h 0032   4]        Asl Compiler Revision : 00000001

[024h 0036   4]            Hardware Block ID : 8086A201

[028h 0040  12]         Timer Block Register : [Generic Address Structure]
[028h 0040   1]                     Space ID : 00 [SystemMemory]
[029h 0041   1]                    Bit Width : 00
[02Ah 0042   1]                   Bit Offset : 00
[02Bh 0043   1]         Encoded Access Width : 00 [Undefined/Legacy]
[02Ch 0044   8]                      Address : 00000000FED00000

[034h 0052   1]              Sequence Number : 00
[035h 0053   2]          Minimum Clock Ticks : 0080
[037h 0055   1]        Flags (decoded below) : 00
                             4K Page Protect : 0
                            64K Page Protect : 0

Raw Table Data: Length 56 (0x38)

  0000: 48 50 45 54 38 00 00 00 01 7F 4C 45 4E 4F 56 4F  HPET8.....LENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 4C 4E 56 4F  TP-7S   @...LNVO
  0020: 01 00 00 00 01 A2 86 80 00 00 00 00 00 00 D0 FE  ................
  0030: 00 00 00 00 00 80 00 00                          ........


MCFG
----
[000h 0000   4]                    Signature : "MCFG"    [Memory Mapped Configuration table]
[004h 0004   4]                 Table Length : 0000003C
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : 57
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : "LNVO"
[020h 0032   4]        Asl Compiler Revision : 00000001

[024h 0036   8]                     Reserved : 0000000000000000

[02Ch 0044   8]                 Base Address : 00000000F0000000
[034h 0052   2]         Segment Group Number : 0000
[036h 0054   1]             Start Bus Number : 00
[037h 0055   1]               End Bus Number : 3F
[038h 0056   4]                     Reserved : 00000000

Raw Table Data: Length 60 (0x3C)

  0000: 4D 43 46 47 3C 00 00 00 01 57 4C 45 4E 4F 56 4F  MCFG<....WLENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 4C 4E 56 4F  TP-7S   @...LNVO
  0020: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 F0  ................
  0030: 00 00 00 00 00 00 00 3F 00 00 00 00              .......?....


RSDP
----
[000h 0000   8]                    Signature : "RSD PTR "
[008h 0008   1]                     Checksum : 98
[009h 0009   6]                       Oem ID : "LENOVO"
[00Fh 0015   1]                     Revision : 02
[010h 0016   4]                 RSDT Address : 7E6BCCBF
[014h 0020   4]                       Length : 00000024
[018h 0024   8]                 XSDT Address : 000000007E6BCD1F
[020h 0032   1]            Extended Checksum : 07
[021h 0033   3]                     Reserved : 000000

Raw Table Data: Length 36 (0x24)

  0000: 52 53 44 20 50 54 52 20 98 4C 45 4E 4F 56 4F 02  RSD PTR .LENOVO.
  0010: BF CC 6B 7E 24 00 00 00 1F CD 6B 7E 00 00 00 00  ..k~$.....k~....
  0020: 07 00 00 00                                      ....


RSDT
----
[000h 0000   4]                    Signature : "RSDT"    [Root System Description Table]
[004h 0004   4]                 Table Length : 00000060
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : 75
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : " LTP"
[020h 0032   4]        Asl Compiler Revision : 00000000

[024h 0036   4]       ACPI Table Address   0 : 7E6BCF00
[028h 0040   4]       ACPI Table Address   1 : 7E6BCF81
[02Ch 0044   4]       ACPI Table Address   2 : 7E6CBB4E
[030h 0048   4]       ACPI Table Address   3 : 7E6CBBA0
[034h 0052   4]       ACPI Table Address   4 : 7E6CBBD2
[038h 0056   4]       ACPI Table Address   5 : 7E6CBC3A
[03Ch 0060   4]       ACPI Table Address   6 : 7E6CBC76
[040h 0064   4]       ACPI Table Address   7 : 7E6CBDF0
[044h 0068   4]       ACPI Table Address   8 : 7E6CBF66
[048h 0072   4]       ACPI Table Address   9 : 7E6CBF8E
[04Ch 0076   4]       ACPI Table Address  10 : 7E6E2697
[050h 0080   4]       ACPI Table Address  11 : 7E6E28F6
[054h 0084   4]       ACPI Table Address  12 : 7E6E299C
[058h 0088   4]       ACPI Table Address  13 : 7E6E2E93
[05Ch 0092   4]       ACPI Table Address  14 : 7E6E3750

Raw Table Data: Length 96 (0x60)

  0000: 52 53 44 54 60 00 00 00 01 75 4C 45 4E 4F 56 4F  RSDT`....uLENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 20 4C 54 50  TP-7S   @... LTP
  0020: 00 00 00 00 00 CF 6B 7E 81 CF 6B 7E 4E BB 6C 7E  ......k~..k~N.l~
  0030: A0 BB 6C 7E D2 BB 6C 7E 3A BC 6C 7E 76 BC 6C 7E  ..l~..l~:.l~v.l~
  0040: F0 BD 6C 7E 66 BF 6C 7E 8E BF 6C 7E 97 26 6E 7E  ..l~f.l~..l~.&n~
  0050: F6 28 6E 7E 9C 29 6E 7E 93 2E 6E 7E 50 37 6E 7E  .(n~.)n~..n~P7n~


SLIC
----
[000h 0000   4]                    Signature : "SLIC"    [Software Licensing Description Table]
[004h 0004   4]                 Table Length : 00000176
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : B5
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : " LTP"
[020h 0032   4]        Asl Compiler Revision : 00000000


[024h 0036   4]                Subtable Type : 00000000 [Public Key Structure]
[028h 0040   4]                       Length : 0000009C

[02Ch 0044   1]                     Key Type : 06
[02Dh 0045   1]                      Version : 02
[02Eh 0046   2]                     Reserved : 0000
[030h 0048   4]                    Algorithm : 00002400
[034h 0052   4]                        Magic : "RSA1"
[038h 0056   4]                    BitLength : 00000400
[03Ch 0060   4]                     Exponent : 00010001
[040h 0064 128]                      Modulus : 69 16 4A 9F B1 4B 3A FB 80 20 AA AF C4 F9 3E C1 \
                                               80 49 EE 6A 65 26 72 1E CD BF 5F 2F 96 D6 C0 0A \
                                               92 F5 06 B5 00 B2 3B 29 02 E2 4C 8D C2 F2 BC 41 \
                                               77 9C 70 F0 F3 1B 09 D2 63 5A DC A8 83 F8 5E C9 \
                                               15 95 F9 FA FD DC 05 B7 4D 67 7F 2D B3 84 33 20 \
                                               E1 D1 79 2A A7 6A 77 D1 B6 20 2A 76 42 C5 D5 E9 \
                                               B6 43 40 55 44 C3 C9 37 99 5F 41 97 70 F3 D1 F6 \
                                               07 EC 7B 1A 29 A1 C1 F1 91 FD 48 86 6E 3E CE CB

[0C0h 0192   4]                Subtable Type : 00000001 [Windows Marker Structure]
[0C4h 0196   4]                       Length : 000000B6

[0C8h 0200   4]                      Version : 00020000
[0CCh 0204   6]                       Oem ID : "LENOVO"
[0D2h 0210   8]                 Oem Table ID : "TP-7S   "
[0DAh 0218   8]                 Windows Flag : "WINDOWS "
[0E2h 0226   4]                 SLIC Version : 00000000
[0E6h 0230  16]                     Reserved : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[0F6h 0246 128]                    Signature : A3 B4 A9 1B 7D 8A BA 4B A9 46 2E E3 48 8E EE D4 \
                                               DF 0A 0F C5 E6 DD DD CF 69 FF 6E EE 65 E9 A9 8D \
                                               21 F1 F5 0B 1E 00 26 45 98 FB 38 39 4B DA AD C1 \
                                               A1 EB 11 6D E0 54 C8 59 21 52 37 9B 68 5D 51 4C \
                                               12 DC 74 FE 70 E3 0F 57 D3 09 3A 09 A9 EB AC 45 \
                                               5B 5C BD BC 40 EF FD FE EF 04 0B 78 D1 45 34 84 \
                                               B7 61 D7 4D 87 CC B1 D7 D2 CA 3A AB 22 DA 16 57 \
                                               D3 BC DF 9F 5D 98 BD 0A 37 E5 80 1A 5F 2B 43 16

Raw Table Data: Length 374 (0x176)

  0000: 53 4C 49 43 76 01 00 00 01 B5 4C 45 4E 4F 56 4F  SLICv.....LENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 20 4C 54 50  TP-7S   @... LTP
  0020: 00 00 00 00 00 00 00 00 9C 00 00 00 06 02 00 00  ................
  0030: 00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00  .$..RSA1........
  0040: 69 16 4A 9F B1 4B 3A FB 80 20 AA AF C4 F9 3E C1  i.J..K:.. ....>.
  0050: 80 49 EE 6A 65 26 72 1E CD BF 5F 2F 96 D6 C0 0A  .I.je&r..._/....
  0060: 92 F5 06 B5 00 B2 3B 29 02 E2 4C 8D C2 F2 BC 41  ......;)..L....A
  0070: 77 9C 70 F0 F3 1B 09 D2 63 5A DC A8 83 F8 5E C9  w.p.....cZ....^.
  0080: 15 95 F9 FA FD DC 05 B7 4D 67 7F 2D B3 84 33 20  ........Mg.-..3 
  0090: E1 D1 79 2A A7 6A 77 D1 B6 20 2A 76 42 C5 D5 E9  ..y*.jw.. *vB...
  00A0: B6 43 40 55 44 C3 C9 37 99 5F 41 97 70 F3 D1 F6  .C@UD..7._A.p...
  00B0: 07 EC 7B 1A 29 A1 C1 F1 91 FD 48 86 6E 3E CE CB  ..{.).....H.n>..
  00C0: 01 00 00 00 B6 00 00 00 00 00 02 00 4C 45 4E 4F  ............LENO
  00D0: 56 4F 54 50 2D 37 53 20 20 20 57 49 4E 44 4F 57  VOTP-7S   WINDOW
  00E0: 53 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00  S ..............
  00F0: 00 00 00 00 00 00 A3 B4 A9 1B 7D 8A BA 4B A9 46  ..........}..K.F
  0100: 2E E3 48 8E EE D4 DF 0A 0F C5 E6 DD DD CF 69 FF  ..H...........i.
  0110: 6E EE 65 E9 A9 8D 21 F1 F5 0B 1E 00 26 45 98 FB  n.e...!.....&E..
  0120: 38 39 4B DA AD C1 A1 EB 11 6D E0 54 C8 59 21 52  89K......m.T.Y!R
  0130: 37 9B 68 5D 51 4C 12 DC 74 FE 70 E3 0F 57 D3 09  7.h]QL..t.p..W..
  0140: 3A 09 A9 EB AC 45 5B 5C BD BC 40 EF FD FE EF 04  :....E[\..@.....
  0150: 0B 78 D1 45 34 84 B7 61 D7 4D 87 CC B1 D7 D2 CA  .x.E4..a.M......
  0160: 3A AB 22 DA 16 57 D3 BC DF 9F 5D 98 BD 0A 37 E5  :."..W....]...7.
  0170: 80 1A 5F 2B 43 16                                .._+C.


SSDT1
-----
DefinitionBlock ("ssdt1.aml", "SSDT", 1, "LENOVO", "TP-7S   ", 0x00001240)
{
    /*
     * iASL Warning: There were 3 external control methods found during
     * disassembly, but additional ACPI tables to resolve these externals
     * were not specified. This resulting disassembler output file may not
     * compile because the disassembler did not know how many arguments
     * to assign to these methods. To specify the tables needed to resolve
     * external control method references, the -e option can be used to
     * specify the filenames. Example iASL invocations:
     *     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml
     *     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml
     *     iasl -e ssdt*.aml -d dsdt.aml
     *
     * In addition, the -fe option can be used to specify a file containing
     * control method external declarations with the associated method
     * argument counts. Each line of the file must be of the form:
     *     External (<method pathname>, MethodObj, <argument count>)
     * Invocation:
     *     iasl -fe refs.txt -d dsdt.aml
     *
     * The following methods were unresolved and many not compile properly
     * because the disassembler had to guess at the number of arguments
     * required for each:
     */
    External (_SB_.PCI0.LPC_.EC__.BRNS, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (UCMS, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (VBRC, MethodObj)    // Warning: Unresolved method, guessing 1 arguments

    External (_SB_.PCI0.AGP_.VID_.LCD0, DeviceObj)
    External (_SB_.PCI0.VID_.LCD0, DeviceObj)
    External (BRLV, IntObj)
    External (NBCF, UnknownObj)
    External (VBRG, IntObj)

    Scope (\)
    {
        Method (KOU2, 0, NotSerialized)
        {
            Stall (0x64)
        }
    }

    Scope (\_SB.PCI0.VID.LCD0)
    {
        Method (_BCL, 0, NotSerialized)  // _BCL: Brightness Control Levels
        {
            \NBCF = 0x01
            Return (Package (0x12)
            {
                0x64, 
                0x64, 
                0x14, 
                0x19, 
                0x1E, 
                0x23, 
                0x28, 
                0x2D, 
                0x32, 
                0x37, 
                0x3C, 
                0x41, 
                0x46, 
                0x4B, 
                0x50, 
                0x55, 
                0x5A, 
                0x64
            })
        }

        Name (BCLP, Package (0x10)
        {
            0x14, 
            0x19, 
            0x1E, 
            0x23, 
            0x28, 
            0x2D, 
            0x32, 
            0x37, 
            0x3C, 
            0x41, 
            0x46, 
            0x4B, 
            0x50, 
            0x55, 
            0x5A, 
            0x64
        })
        Name (BCLL, Package (0x10)
        {
            0x00, 
            0x01, 
            0x02, 
            0x03, 
            0x04, 
            0x05, 
            0x06, 
            0x07, 
            0x08, 
            0x09, 
            0x0A, 
            0x0B, 
            0x0C, 
            0x0D, 
            0x0E, 
            0x0F
        })
        Method (_BCM, 1, NotSerialized)  // _BCM: Brightness Control Method
        {
            Local0 = Match (BCLP, MEQ, Arg0, MTR, 0x00, 0x00)
            If ((Local0 != Ones))
            {
                \BRLV = DerefOf (Index (BCLL, Local0))
                \_SB.PCI0.LPC.EC.BRNS (\UCMS (0x16))
            }
        }

        Method (_BQC, 0, NotSerialized)  // _BQC: Brightness Query Current
        {
            Local0 = \BRLV /* External reference */
            If ((Local0 <= 0x0F))
            {
                Return (DerefOf (Index (BCLP, Local0)))
            }
            Else
            {
                Return (Zero)
            }
        }
    }

    Scope (\_SB.PCI0.AGP.VID.LCD0)
    {
        Method (_BCL, 0, NotSerialized)  // _BCL: Brightness Control Levels
        {
            NBCF = 0x01
            Return (Package (0x12)
            {
                0x64, 
                0x64, 
                0x14, 
                0x19, 
                0x1E, 
                0x23, 
                0x28, 
                0x2D, 
                0x32, 
                0x37, 
                0x3C, 
                0x41, 
                0x46, 
                0x4B, 
                0x50, 
                0x55, 
                0x5A, 
                0x64
            })
        }

        Name (BCLP, Package (0x10)
        {
            0x14, 
            0x19, 
            0x1E, 
            0x23, 
            0x28, 
            0x2D, 
            0x32, 
            0x37, 
            0x3C, 
            0x41, 
            0x46, 
            0x4B, 
            0x50, 
            0x55, 
            0x5A, 
            0x64
        })
        Name (BCLL, Package (0x10)
        {
            0x00, 
            0x01, 
            0x02, 
            0x03, 
            0x04, 
            0x05, 
            0x06, 
            0x07, 
            0x08, 
            0x09, 
            0x0A, 
            0x0B, 
            0x0C, 
            0x0D, 
            0x0E, 
            0x0F
        })
        Method (_BCM, 1, NotSerialized)  // _BCM: Brightness Control Method
        {
            Local0 = Match (BCLP, MEQ, Arg0, MTR, 0x00, 0x00)
            If ((Local0 != Ones))
            {
                Local1 = DerefOf (Index (BCLL, Local0))
                \VBRC (Local1)
            }
        }

        Method (_BQC, 0, NotSerialized)  // _BQC: Brightness Query Current
        {
            Local0 = \VBRG /* External reference */
            If ((Local0 <= 0x0F))
            {
                Return (DerefOf (Index (BCLP, Local0)))
            }
            Else
            {
                Return (Zero)
            }
        }
    }
}



SSDT10
------
DefinitionBlock ("ssdt10.aml", "SSDT", 1, "PmRef", "Cpu1Cst", 0x00000100)
{

    External (_PR_.CPU0._CST, IntObj)
    External (_PR_.CPU1, DeviceObj)
    External (CFGD, UnknownObj)
    External (PDC1, UnknownObj)

    Scope (\_PR.CPU1)
    {
        Method (_CST, 0, NotSerialized)  // _CST: C-States
        {
            If (((CFGD & 0x01000000) && !(PDC1 & 0x10)))
            {
                Return (Package (0x02)
                {
                    0x01, 
                    Package (0x04)
                    {
                        ResourceTemplate ()
                        {
                            Register (FFixedHW, 
                                0x00,               // Bit Width
                                0x00,               // Bit Offset
                                0x0000000000000000, // Address
                                ,)
                        }, 

                        0x01, 
                        0x9D, 
                        0x03E8
                    }
                })
            }

            Return (\_PR.CPU0._CST) /* External reference */
        }
    }
}



SSDT2
-----
DefinitionBlock ("ssdt2.aml", "SSDT", 1, "LENOVO", "TP-7S   ", 0x00001240)
{

    External (_PR_.CPU0, DeviceObj)
    External (_PSS, IntObj)
    External (CFGD, UnknownObj)
    External (PDC0, UnknownObj)

    Scope (\_PR.CPU0)
    {
        Name (_TPC, 0x00)  // _TPC: Throttling Present Capabilities
        Method (_PTC, 0, NotSerialized)  // _PTC: Processor Throttling Control
        {
            If ((PDC0 & 0x04))
            {
                Return (Package (0x02)
                {
                    ResourceTemplate ()
                    {
                        Register (FFixedHW, 
                            0x00,               // Bit Width
                            0x00,               // Bit Offset
                            0x0000000000000000, // Address
                            ,)
                    }, 

                    ResourceTemplate ()
                    {
                        Register (FFixedHW, 
                            0x00,               // Bit Width
                            0x00,               // Bit Offset
                            0x0000000000000000, // Address
                            ,)
                    }
                })
            }

            Return (Package (0x02)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x04,               // Bit Width
                        0x01,               // Bit Offset
                        0x0000000000001010, // Address
                        ,)
                }, 

                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x04,               // Bit Width
                        0x01,               // Bit Offset
                        0x0000000000001010, // Address
                        ,)
                }
            })
        }

        Name (TSSI, Package (0x08)
        {
            Package (0x05)
            {
                0x64, 
                0x03E8, 
                0x00, 
                0x00, 
                0x00
            }, 

            Package (0x05)
            {
                0x58, 
                0x036B, 
                0x00, 
                0x0F, 
                0x00
            }, 

            Package (0x05)
            {
                0x4B, 
                0x02EE, 
                0x00, 
                0x0E, 
                0x00
            }, 

            Package (0x05)
            {
                0x3F, 
                0x0271, 
                0x00, 
                0x0D, 
                0x00
            }, 

            Package (0x05)
            {
                0x32, 
                0x01F4, 
                0x00, 
                0x0C, 
                0x00
            }, 

            Package (0x05)
            {
                0x26, 
                0x0177, 
                0x00, 
                0x0B, 
                0x00
            }, 

            Package (0x05)
            {
                0x19, 
                0xFA, 
                0x00, 
                0x0A, 
                0x00
            }, 

            Package (0x05)
            {
                0x0D, 
                0x7D, 
                0x00, 
                0x09, 
                0x00
            }
        })
        Name (TSSM, Package (0x08)
        {
            Package (0x05)
            {
                0x64, 
                0x03E8, 
                0x00, 
                0x00, 
                0x00
            }, 

            Package (0x05)
            {
                0x58, 
                0x036B, 
                0x00, 
                0x1E, 
                0x00
            }, 

            Package (0x05)
            {
                0x4B, 
                0x02EE, 
                0x00, 
                0x1C, 
                0x00
            }, 

            Package (0x05)
            {
                0x3F, 
                0x0271, 
                0x00, 
                0x1A, 
                0x00
            }, 

            Package (0x05)
            {
                0x32, 
                0x01F4, 
                0x00, 
                0x18, 
                0x00
            }, 

            Package (0x05)
            {
                0x26, 
                0x0177, 
                0x00, 
                0x16, 
                0x00
            }, 

            Package (0x05)
            {
                0x19, 
                0xFA, 
                0x00, 
                0x14, 
                0x00
            }, 

            Package (0x05)
            {
                0x0D, 
                0x7D, 
                0x00, 
                0x12, 
                0x00
            }
        })
        Name (TSSF, 0x00)
        Method (_TSS, 0, NotSerialized)  // _TSS: Throttling Supported States
        {
            If ((!TSSF && CondRefOf (_PSS)))
            {
                Local0 = _PSS /* External reference */
                Local1 = SizeOf (Local0)
                Local1--
                Local2 = DerefOf (Index (DerefOf (Index (Local0, Local1)), 0x01))
                Local3 = 0x00
                While ((Local3 < SizeOf (TSSI)))
                {
                    Local4 = ((Local2 * (0x08 - Local3)) / 0x08)
                    Index (DerefOf (Index (TSSI, Local3)), 0x01) = Local4
                    Index (DerefOf (Index (TSSM, Local3)), 0x01) = Local4
                    Local3++
                }

                TSSF = Ones
            }

            If ((PDC0 & 0x04))
            {
                Return (TSSM) /* \_PR_.CPU0.TSSM */
            }

            Return (TSSI) /* \_PR_.CPU0.TSSI */
        }

        Method (_TSD, 0, NotSerialized)  // _TSD: Throttling State Dependencies
        {
            If (((CFGD & 0x01000000) && !(PDC0 & 0x04)))
            {
                Return (Package (0x01)
                {
                    Package (0x05)
                    {
                        0x05, 
                        0x00, 
                        0x00, 
                        0xFD, 
                        0x02
                    }
                })
            }

            Return (Package (0x01)
            {
                Package (0x05)
                {
                    0x05, 
                    0x00, 
                    0x00, 
                    0xFC, 
                    0x01
                }
            })
        }
    }
}



SSDT3
-----
DefinitionBlock ("ssdt3.aml", "SSDT", 1, "LENOVO", "TP-7S   ", 0x00001240)
{

    External (_PR_.CPU0._PTC, IntObj)
    External (_PR_.CPU0._TSS, IntObj)
    External (_PR_.CPU1, DeviceObj)
    External (CFGD, UnknownObj)
    External (PDC1, UnknownObj)

    Scope (\_PR.CPU1)
    {
        Name (_TPC, 0x00)  // _TPC: Throttling Present Capabilities
        Method (_PTC, 0, NotSerialized)  // _PTC: Processor Throttling Control
        {
            Return (\_PR.CPU0._PTC) /* External reference */
        }

        Method (_TSS, 0, NotSerialized)  // _TSS: Throttling Supported States
        {
            Return (\_PR.CPU0._TSS) /* External reference */
        }

        Method (_TSD, 0, NotSerialized)  // _TSD: Throttling State Dependencies
        {
            If (((CFGD & 0x01000000) && !(PDC1 & 0x04)))
            {
                Return (Package (0x01)
                {
                    Package (0x05)
                    {
                        0x05, 
                        0x00, 
                        0x00, 
                        0xFD, 
                        0x02
                    }
                })
            }

            Return (Package (0x01)
            {
                Package (0x05)
                {
                    0x05, 
                    0x00, 
                    0x01, 
                    0xFC, 
                    0x01
                }
            })
        }
    }
}



SSDT4
-----
DefinitionBlock ("ssdt4.aml", "SSDT", 1, "LENOVO", "TP-7S   ", 0x00001240)
{
    /*
     * iASL Warning: There were 3 external control methods found during
     * disassembly, but additional ACPI tables to resolve these externals
     * were not specified. This resulting disassembler output file may not
     * compile because the disassembler did not know how many arguments
     * to assign to these methods. To specify the tables needed to resolve
     * external control method references, the -e option can be used to
     * specify the filenames. Example iASL invocations:
     *     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml
     *     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml
     *     iasl -e ssdt*.aml -d dsdt.aml
     *
     * In addition, the -fe option can be used to specify a file containing
     * control method external declarations with the associated method
     * argument counts. Each line of the file must be of the form:
     *     External (<method pathname>, MethodObj, <argument count>)
     * Invocation:
     *     iasl -fe refs.txt -d dsdt.aml
     *
     * The following methods were unresolved and many not compile properly
     * because the disassembler had to guess at the number of arguments
     * required for each:
     */
    External (DTSE, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (PPMS, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (THRM, MethodObj)    // Warning: Unresolved method, guessing 1 arguments

    External (_PR_.CPU0, DeviceObj)
    External (_PR_.CPU1, DeviceObj)
    External (WSPV, UnknownObj)
    External (WXPF, UnknownObj)

    Scope (\)
    {
        Name (SSDT, Package (0x0C)
        {
            "CPU0IST ", 
            0x7E6E1D72, 
            0x00000282, 
            "CPU1IST ", 
            0x7E6E1CAA, 
            0x000000C8, 
            "CPU0CST ", 
            0x7E6E2079, 
            0x0000061E, 
            "CPU1CST ", 
            0x7E6E1FF4, 
            0x00000085
        })
        Name (CFGD, 0x113F69F7)
        Name (\PDC0, 0x80000000)
        Name (\PDC1, 0x80000000)
        Name (\SDTL, 0x00)
    }

    Scope (\_PR.CPU0)
    {
        Name (HI0, 0x00)
        Name (HC0, 0x00)
        Method (_PDC, 1, NotSerialized)  // _PDC: Processor Driver Capabilities
        {
            CreateDWordField (Arg0, 0x00, REVS)
            CreateDWordField (Arg0, 0x04, SIZE)
            Local0 = SizeOf (Arg0)
            Local1 = (Local0 - 0x08)
            CreateField (Arg0, 0x40, (Local1 * 0x08), TEMP)
            Name (STS0, Buffer (0x04)
            {
                 0x00, 0x00, 0x00, 0x00                           /* .... */
            })
            Concatenate (STS0, TEMP, Local2)
            _OSC (ToUUID ("4077a616-290c-47be-9ebd-d87058713953"), REVS, SIZE, Local2)
        }

        Method (_OSC, 4, NotSerialized)  // _OSC: Operating System Capabilities
        {
            CreateDWordField (Arg3, 0x00, STS0)
            CreateDWordField (Arg3, 0x04, CAP0)
            CreateDWordField (Arg0, 0x00, IID0)
            CreateDWordField (Arg0, 0x04, IID1)
            CreateDWordField (Arg0, 0x08, IID2)
            CreateDWordField (Arg0, 0x0C, IID3)
            Name (UID0, ToUUID ("4077a616-290c-47be-9ebd-d87058713953"))
            CreateDWordField (UID0, 0x00, EID0)
            CreateDWordField (UID0, 0x04, EID1)
            CreateDWordField (UID0, 0x08, EID2)
            CreateDWordField (UID0, 0x0C, EID3)
            If (!(((IID0 == EID0) && (IID1 == EID1)) && ((
                IID2 == EID2) && (IID3 == EID3))))
            {
                STS0 = 0x06
                Return (Arg3)
            }

            If ((Arg1 != 0x01))
            {
                STS0 = 0x0A
                Return (Arg3)
            }

            PDC0 = ((PDC0 & 0x7FFFFFFF) | CAP0) /* \_PR_.CPU0._OSC.CAP0 */
            If ((CFGD & 0x01))
            {
                If ((((CFGD & 0x01000000) && ((PDC0 & 0x09) == 
                    0x09)) && !(SDTL & 0x01)))
                {
                    SDTL |= 0x01
                    OperationRegion (IST0, SystemMemory, DerefOf (Index (SSDT, 0x01)), DerefOf (Index (SSDT, 0x02)))
                    Load (IST0, HI0) /* \_PR_.CPU0.HI0_ */
                }
            }

            If ((CFGD & 0xF0))
            {
                If ((((CFGD & 0x01000000) && (PDC0 & 0x18)) && !
                    (SDTL & 0x02)))
                {
                    SDTL |= 0x02
                    OperationRegion (CST0, SystemMemory, DerefOf (Index (SSDT, 0x07)), DerefOf (Index (SSDT, 0x08)))
                    Load (CST0, HC0) /* \_PR_.CPU0.HC0_ */
                }
            }

            Return (Arg3)
        }
    }

    Scope (\_PR.CPU1)
    {
        Name (HI1, 0x00)
        Name (HC1, 0x00)
        Method (_PDC, 1, NotSerialized)  // _PDC: Processor Driver Capabilities
        {
            CreateDWordField (Arg0, 0x00, REVS)
            CreateDWordField (Arg0, 0x04, SIZE)
            Local0 = SizeOf (Arg0)
            Local1 = (Local0 - 0x08)
            CreateField (Arg0, 0x40, (Local1 * 0x08), TEMP)
            Name (STS1, Buffer (0x04)
            {
                 0x00, 0x00, 0x00, 0x00                           /* .... */
            })
            Concatenate (STS1, TEMP, Local2)
            _OSC (ToUUID ("4077a616-290c-47be-9ebd-d87058713953"), REVS, SIZE, Local2)
        }

        Method (_OSC, 4, NotSerialized)  // _OSC: Operating System Capabilities
        {
            CreateDWordField (Arg3, 0x00, STS1)
            CreateDWordField (Arg3, 0x04, CAP1)
            CreateDWordField (Arg0, 0x00, IID0)
            CreateDWordField (Arg0, 0x04, IID1)
            CreateDWordField (Arg0, 0x08, IID2)
            CreateDWordField (Arg0, 0x0C, IID3)
            Name (UID1, ToUUID ("4077a616-290c-47be-9ebd-d87058713953"))
            CreateDWordField (UID1, 0x00, EID0)
            CreateDWordField (UID1, 0x04, EID1)
            CreateDWordField (UID1, 0x08, EID2)
            CreateDWordField (UID1, 0x0C, EID3)
            If (!(((IID0 == EID0) && (IID1 == EID1)) && ((
                IID2 == EID2) && (IID3 == EID3))))
            {
                STS1 = 0x06
                Return (Arg3)
            }

            If ((Arg1 != 0x01))
            {
                STS1 = 0x0A
                Return (Arg3)
            }

            PDC1 = ((PDC1 & 0x7FFFFFFF) | CAP1) /* \_PR_.CPU1._OSC.CAP1 */
            If ((CFGD & 0x01))
            {
                If ((((CFGD & 0x01000000) && ((PDC1 & 0x09) == 
                    0x09)) && !(SDTL & 0x10)))
                {
                    SDTL |= 0x10
                    OperationRegion (IST1, SystemMemory, DerefOf (Index (SSDT, 0x04)), DerefOf (Index (SSDT, 0x05)))
                    Load (IST1, HI1) /* \_PR_.CPU1.HI1_ */
                }
            }

            If ((CFGD & 0xF0))
            {
                If ((((CFGD & 0x01000000) && (PDC1 & 0x18)) && !
                    (SDTL & 0x20)))
                {
                    SDTL |= 0x20
                    OperationRegion (CST1, SystemMemory, DerefOf (Index (SSDT, 0x0A)), DerefOf (Index (SSDT, 0x0B)))
                    Load (CST1, HC1) /* \_PR_.CPU1.HC1_ */
                }
            }

            Return (Arg3)
        }

        Method (_INI, 0, NotSerialized)  // _INI: Initialize
        {
            If (\DTSE (THRM (0x00), If ((\WXPF && (\WSPV <= 0x01)))
                    {
                        PPMS (0x00)
                    })) {}
        }
    }
}



SSDT5
-----
DefinitionBlock ("ssdt5.aml", "SSDT", 1, "LENOVO", "TP-7S   ", 0x00001240)
{
    /*
     * iASL Warning: There were 24 external control methods found during
     * disassembly, but additional ACPI tables to resolve these externals
     * were not specified. This resulting disassembler output file may not
     * compile because the disassembler did not know how many arguments
     * to assign to these methods. To specify the tables needed to resolve
     * external control method references, the -e option can be used to
     * specify the filenames. Example iASL invocations:
     *     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml
     *     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml
     *     iasl -e ssdt*.aml -d dsdt.aml
     *
     * In addition, the -fe option can be used to specify a file containing
     * control method external declarations with the associated method
     * argument counts. Each line of the file must be of the form:
     *     External (<method pathname>, MethodObj, <argument count>)
     * Invocation:
     *     iasl -fe refs.txt -d dsdt.aml
     *
     * The following methods were unresolved and many not compile properly
     * because the disassembler had to guess at the number of arguments
     * required for each:
     */
    External (DPIO, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (DUDM, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (FDMA, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (FISP, MethodObj)    // Warning: Unresolved method, guessing 0 arguments
    External (FPB0, MethodObj)    // Warning: Unresolved method, guessing 3 arguments
    External (FPB1, MethodObj)    // Warning: Unresolved method, guessing 3 arguments
    External (GDCT, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (GPCT, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (MTIM, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (PCB0, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (PCB1, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (PCT0, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (PCT1, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (PDT0, MethodObj)    // Warning: Unresolved method, guessing 3 arguments
    External (PDT1, MethodObj)    // Warning: Unresolved method, guessing 3 arguments
    External (PIS0, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (PIS1, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (PRC0, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (PRC1, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (PTI0, MethodObj)    // Warning: Unresolved method, guessing 0 arguments
    External (PTI1, MethodObj)    // Warning: Unresolved method, guessing 0 arguments
    External (UMDM, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (UPIO, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (UUDM, MethodObj)    // Warning: Unresolved method, guessing 2 arguments

    External (_SB_.PCI0.SATA, DeviceObj)
    External (FPIO, IntObj)
    External (MISP, IntObj)
    External (MRCT, IntObj)
    External (OSSS, IntObj)
   

SSDT6
-----
DefinitionBlock ("ssdt6.aml", "SSDT", 1, "LENOVO", "TP-7S   ", 0x00001240)
{
    /*
     * iASL Warning: There were 18 external control methods found during
     * disassembly, but additional ACPI tables to resolve these externals
     * were not specified. This resulting disassembler output file may not
     * compile because the disassembler did not know how many arguments
     * to assign to these methods. To specify the tables needed to resolve
     * external control method references, the -e option can be used to
     * specify the filenames. Example iASL invocations:
     *     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml
     *     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml
     *     iasl -e ssdt*.aml -d dsdt.aml
     *
     * In addition, the -fe option can be used to specify a file containing
     * control method external declarations with the associated method
     * argument counts. Each line of the file must be of the form:
     *     External (<method pathname>, MethodObj, <argument count>)
     * Invocation:
     *     iasl -fe refs.txt -d dsdt.aml
     *
     * The following methods were unresolved and many not compile properly
     * because the disassembler had to guess at the number of arguments
     * required for each:
     */
    External (_SB_.PCI0.LPC_.EC__.BEJ0, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (_SB_.PCI0.LPC_.EC__.BSTA, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (DPIO, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (DUDM, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (FDMA, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (FSB0, MethodObj)    // Warning: Unresolved method, guessing 3 arguments
    External (GDCT, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (GPCT, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (MTIM, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (SCB0, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (SCT0, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (SDT0, MethodObj)    // Warning: Unresolved method, guessing 3 arguments
    External (SIS0, MethodObj)    // Warning: Unresolved method, guessing 2 arguments
    External (SRC0, MethodObj)    // Warning: Unresolved method, guessing 1 arguments
    External (STI0, MethodObj)    // Warning: Unresolved method, guessing 0 arguments
    External (UMDM, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (UPIO, MethodObj)    // Warning: Unresolved method, guessing 4 arguments
    External (UUDM, MethodObj)    // Warning: Unresolved method, guessing 2 arguments

    External (_SB_.PCI0.LPC_.EC__.BGID, IntObj)
    External (_SB_.PCI0.SATA, DeviceObj)
    External (CDAH, IntObj)
    External (CDFL, IntObj)
    External (FPIO, IntObj)
    External (MISP, IntObj)
    External (MRCT, IntObj)
    External (OSSS, IntObj)
    External (SCR0, UnknownObj)
    External (SFT0, UnknownObj)
    External (SIE0, IntObj)
    External (SSD0, IntObj)
    External (W98F, IntObj)

    Scope (\_SB.PCI0.SATA)
    {
        Device (SCND)
        {
            Name (_ADR, 0x01)  // _ADR: Address
            Name (BGTM, Buffer (0x14) {})
            CreateDWordField (BGTM, 0x00, GTP0)
            CreateDWord

SSDT7
-----
DefinitionBlock ("ssdt7.aml", "SSDT", 1, "PmRef", "Cpu0Ist", 0x00000100)
{

    External (_PR_.CPU0, DeviceObj)
    External (_SB_.PCI0.LPC_.EC__.HT10, UnknownObj)
    External (_SB_.PCI0.LPC_.EC__.LPMD, IntObj)
    External (CFGD, UnknownObj)
    External (DT00, UnknownObj)
    External (LWST, IntObj)
    External (NPSS, IntObj)
    External (PDC0, UnknownObj)

    Scope (\_PR.CPU0)
    {
        Method (_PPC, 0, NotSerialized)  // _PPC: Performance Present Capabilites
        {
            Local0 = 0x00
            Local0 = \_SB.PCI0.LPC.EC.LPMD /* External reference */
            If (!Local0)
            {
                If ((\DT00 || \_SB.PCI0.LPC.EC.HT10))
                {
                    Local0 = \LWST /* External reference */
                }
            }

            Return (Local0)
        }

        Method (_PCT, 0, NotSerialized)  // _PCT: Performance Control
        {
            If (((CFGD & 0x01) && (PDC0 & 0x01)))
            {
                Return (Package (0x02)
                {
                    ResourceTemplate ()
                    {
                        Register (FFixedHW, 
                            0x00,               // Bit Width
                            0x00,               // Bit Offset
                            0x0000000000000000, // Address
                            ,)
                    }, 

                    ResourceTemplate ()
                    {
                        Register (FFixedHW, 
                            0x00,               // Bit Width
                            0x00,               // Bit Offset
                            0x0000000000000000, // Address
                            ,)
                    }
                })
            }

            Return (Package (0x02)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x10,               // Bit Width
                        0x00,               // Bit Offset
                        0x00000000000000B2, // Address
                        ,)
                }, 

                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x00000000000000B3, // Address
                        ,)
                }
            })
        }

        Method (XPSS, 0, NotSerialized)
        {
            If ((PDC0 & 0x01))
            {
                Return (NPSS) /* External reference */
            }

            Return (SPSS) /* \_PR_.CPU0.SPSS */
        }

        Name (SPSS, Package (0x04)
        {
            Package (0x06)
            {
                0x00000709, 
                0x000088B8, 
                0x0000006E, 
                0x0000000A, 
                0x00000083, 
                0x00000000
            }, 

            Package (0x06)
            {
                0x00000708, 
                0x000088B8, 
                0x0000006E, 
                0x0000000A, 
                0x00000183, 
                0x00000001
            }, 

            Package (0x06)
            {
                0x000004B0, 
                0x00003E80, 
                0x0000006E, 
                0x0000000A, 
                0x00000283, 
                0x00000002
            }, 

            Package (0x06)
            {
                0x00000320, 
                0x000036B0, 
                0x0000006E, 
                0x0000000A, 
                0x00000383, 
                0x00000003
            }
        })
        Name (_PSS, Package (0x04)  // _PSS: Performance Supported States
        {
            Package (0x06)
            {
                0x00000709, 
                0x000088B8, 
                0x0000000A, 
                0x0000000A, 
                0x00000A24, 
                0x00000A24
            }, 

            Package (0x06)
            {
                0x00000708, 
                0x000088B8, 
                0x0000000A, 
                0x0000000A, 
                0x00000919, 
                0x00000919
            }, 

            Package (0x06)
            {
                0x000004B0, 
                0x00003E80, 
                0x0000000A, 
                0x0000000A, 
                0x00000615, 
                0x00000615
            }, 

            Package (0x06)
            {
                0x00000320, 
                0x000036B0, 
                0x0000000A, 
                0x0000000A, 
                0x0000880F, 
                0x0000880F
            }
        })
        Method (_PSD, 0, NotSerialized)  // _PSD: Power State Dependencies
        {
            If ((CFGD & 0x01000000))
            {
                If ((PDC0 & 0x0800))
                {
                    Return (Package (0x01)
                    {
                        Package (0x05)
                        {
                            0x05, 
                            0x00, 
                            0x00, 
                            0xFE, 
                            0x02
                        }
                    })
                }

                Return (Package (0x01)
                {
                    Package (0x05)
                    {
                        0x05, 
                        0x00, 
                        0x00, 
                        0xFC, 
                        0x02
                    }
                })
            }

            Return (Package (0x01)
            {
                Package (0x05)
                {
                    0x05, 
                    0x00, 
                    0x00, 
                    0xFC, 
                    0x01
                }
            })
        }
    }
}



SSDT8
-----
DefinitionBlock ("ssdt8.aml", "SSDT", 1, "PmRef", "Cpu0Cst", 0x00000100)
{
    /*
     * iASL Warning: There were 1 external control methods found during
     * disassembly, but additional ACPI tables to resolve these externals
     * were not specified. This resulting disassembler output file may not
     * compile because the disassembler did not know how many arguments
     * to assign to these methods. To specify the tables needed to resolve
     * external control method references, the -e option can be used to
     * specify the filenames. Example iASL invocations:
     *     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml
     *     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml
     *     iasl -e ssdt*.aml -d dsdt.aml
     *
     * In addition, the -fe option can be used to specify a file containing
     * control method external declarations with the associated method
     * argument counts. Each line of the file must be of the form:
     *     External (<method pathname>, MethodObj, <argument count>)
     * Invocation:
     *     iasl -fe refs.txt -d dsdt.aml
     *
     * The following methods were unresolved and many not compile properly
     * because the disassembler had to guess at the number of arguments
     * required for each:
     */
    External (_SB_.PCI0.LPC_.EC__.HKEY.CKC4, MethodObj)    // Warning: Unresolved method, guessing 1 arguments

    External (_PR_.CPU0, DeviceObj)
    External (C2NA, IntObj)
    External (C3NA, IntObj)
    External (CFGD, UnknownObj)
    External (PDC0, UnknownObj)

    Scope (\_PR.CPU0)
    {
        Name (CMW1, Package (0x02)
        {
            0x01, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }
        })
        Name (CMW2, Package (0x03)
        {
            0x02, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000010, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x02, 
                0x01, 
                0x01F4
            }
        })
        Name (CMW3, Package (0x04)
        {
            0x03, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000010, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x02, 
                0x01, 
                0x01F4
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000020, // Address
                        0x03,               // Access Size
                        )
                }, 

                0x03, 
                0x11, 
                0xFA
            }
        })
        Name (CMW4, Package (0x04)
        {
            0x03, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000010, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x02, 
                0x01, 
                0x01F4
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000030, // Address
                        0x03,               // Access Size
                        )
                }, 

                0x03, 
                0x39, 
                0x64
            }
        })
        Name (C1M1, Package (0x02)
        {
            0x01, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }
        })
        Name (C1M2, Package (0x03)
        {
            0x02, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001014, // Address
                        ,)
                }, 

                0x02, 
                0x01, 
                0x01F4
            }
        })
        Name (C1M3, Package (0x04)
        {
            0x03, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001014, // Address
                        ,)
                }, 

                0x02, 
                0x01, 
                0x01F4
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001015, // Address
                        ,)
                }, 

                0x03, 
                0x11, 
                0xFA
            }
        })
        Name (C1M4, Package (0x04)
        {
            0x03, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x01,               // Bit Width
                        0x02,               // Bit Offset
                        0x0000000000000000, // Address
                        0x01,               // Access Size
                        )
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001014, // Address
                        ,)
                }, 

                0x02, 
                0x01, 
                0x01F4
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001016, // Address
                        ,)
                }, 

                0x03, 
                0x39, 
                0x64
            }
        })
        Name (CST1, Package (0x02)
        {
            0x01, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x00,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000000000, // Address
                        ,)
                }, 

                0x01, 
                0x01, 
                0x03E8
            }
        })
        Name (CST2, Package (0x03)
        {
            0x02, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x00,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000000000, // Address
                        ,)
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001014, // Address
                        ,)
                }, 

                0x02, 
                0x01, 
                0x01F4
            }
        })
        Name (CST3, Package (0x04)
        {
            0x03, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x00,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000000000, // Address
                        ,)
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001014, // Address
                        ,)
                }, 

                0x02, 
                0x01, 
                0x01F4
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001015, // Address
                        ,)
                }, 

                0x03, 
                0x11, 
                0xFA
            }
        })
        Name (CST4, Package (0x04)
        {
            0x03, 
            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x00,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000000000, // Address
                        ,)
                }, 

                0x01, 
                0x01, 
                0x03E8
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001014, // Address
                        ,)
                }, 

                0x02, 
                0x01, 
                0x01F4
            }, 

            Package (0x04)
            {
                ResourceTemplate ()
                {
                    Register (SystemIO, 
                        0x08,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000001016, // Address
                        ,)
                }, 

                0x03, 
                0x39, 
                0x64
            }
        })
        Method (_CST, 0, NotSerialized)  // _CST: C-States
        {
            If (((CFGD & 0x01000000) && !(PDC0 & 0x10)))
            {
                Return (Package (0x02)
                {
                    0x01, 
                    Package (0x04)
                    {
                        ResourceTemplate ()
                        {
                            Register (FFixedHW, 
                                0x00,               // Bit Width
                                0x00,               // Bit Offset
                                0x0000000000000000, // Address
                                ,)
                        }, 

                        0x01, 
                        0x9D, 
                        0x03E8
                    }
                })
            }

            If (((CFGD & 0x00200000) && (PDC0 & 0x0200)))
            {
                If ((CFGD & 0x80))
                {
                    If (\C2NA)
                    {
                        Return (CMW1) /* \_PR_.CPU0.CMW1 */
                    }

                    If (\C3NA)
                    {
                        Return (CMW2) /* \_PR_.CPU0.CMW2 */
                    }

                    If (\_SB.PCI0.LPC.EC.HKEY.CKC4 (0x00))
                    {
                        Return (CMW3) /* \_PR_.CPU0.CMW3 */
                    }

                    Return (CMW4) /* \_PR_.CPU0.CMW4 */
                }

                If ((CFGD & 0x40))
                {
                    If (\C2NA)
                    {
                        Return (CMW1) /* \_PR_.CPU0.CMW1 */
                    }

                    If (\C3NA)
                    {
                        Return (CMW2) /* \_PR_.CPU0.CMW2 */
                    }

                    Return (CMW3) /* \_PR_.CPU0.CMW3 */
                }

                If ((CFGD & 0x20))
                {
                    If (\C2NA)
                    {
                        Return (CMW1) /* \_PR_.CPU0.CMW1 */
                    }

                    Return (CMW2) /* \_PR_.CPU0.CMW2 */
                }

                Return (CMW1) /* \_PR_.CPU0.CMW1 */
            }

            If (((CFGD & 0x00200000) && (PDC0 & 0x0100)))
            {
                If ((CFGD & 0x80))
                {
                    If (\C2NA)
                    {
                        Return (C1M1) /* \_PR_.CPU0.C1M1 */
                    }

                    If (\C3NA)
                    {
                        Return (C1M2) /* \_PR_.CPU0.C1M2 */
                    }

                    If (\_SB.PCI0.LPC.EC.HKEY.CKC4 (0x00))
                    {
                        Return (C1M3) /* \_PR_.CPU0.C1M3 */
                    }

                    Return (C1M4) /* \_PR_.CPU0.C1M4 */
                }

                If ((CFGD & 0x40))
                {
                    If (\C2NA)
                    {
                        Return (C1M1) /* \_PR_.CPU0.C1M1 */
                    }

                    If (\C3NA)
                    {
                        Return (C1M2) /* \_PR_.CPU0.C1M2 */
                    }

                    Return (C1M3) /* \_PR_.CPU0.C1M3 */
                }

                If ((CFGD & 0x20))
                {
                    If (\C2NA)
                    {
                        Return (C1M1) /* \_PR_.CPU0.C1M1 */
                    }

                    Return (C1M2) /* \_PR_.CPU0.C1M2 */
                }

                Return (C1M1) /* \_PR_.CPU0.C1M1 */
            }

            If ((CFGD & 0x80))
            {
                If (\C2NA)
                {
                    Return (CST1) /* \_PR_.CPU0.CST1 */
                }

                If (\C3NA)
                {
                    Return (CST2) /* \_PR_.CPU0.CST2 */
                }

                If (\_SB.PCI0.LPC.EC.HKEY.CKC4 (0x00))
                {
                    Return (CST3) /* \_PR_.CPU0.CST3 */
                }

                Return (CST4) /* \_PR_.CPU0.CST4 */
            }

            If ((CFGD & 0x40))
            {
                If (\C2NA)
                {
                    Return (CST1) /* \_PR_.CPU0.CST1 */
                }

                If (\C3NA)
                {
                    Return (CST2) /* \_PR_.CPU0.CST2 */
                }

                Return (CST3) /* \_PR_.CPU0.CST3 */
            }

            If ((CFGD & 0x20))
            {
                If (\C2NA)
                {
                    Return (CST1) /* \_PR_.CPU0.CST1 */
                }

                Return (CST2) /* \_PR_.CPU0.CST2 */
            }

            Return (CST1) /* \_PR_.CPU0.CST1 */
        }
    }
}



SSDT9
-----
DefinitionBlock ("ssdt9.aml", "SSDT", 1, "PmRef", "Cpu1Ist", 0x00000100)
{

    External (_PR_.CPU0._PPC, IntObj)
    External (_PR_.CPU0._PSS, IntObj)
    External (_PR_.CPU1, DeviceObj)
    External (PDC1, UnknownObj)

    Scope (\_PR.CPU1)
    {
        Method (_PPC, 0, NotSerialized)  // _PPC: Performance Present Capabilites
        {
            Return (\_PR.CPU0._PPC) /* External reference */
        }

        Method (_PCT, 0, NotSerialized)  // _PCT: Performance Control
        {
            Return (Package (0x02)
            {
                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x00,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000000000, // Address
                        ,)
                }, 

                ResourceTemplate ()
                {
                    Register (FFixedHW, 
                        0x00,               // Bit Width
                        0x00,               // Bit Offset
                        0x0000000000000000, // Address
                        ,)
                }
            })
        }

        Method (_PSS, 0, NotSerialized)  // _PSS: Performance Supported States
        {
            Return (\_PR.CPU0._PSS) /* External reference */
        }

        Method (_PSD, 0, NotSerialized)  // _PSD: Power State Dependencies
        {
            If ((PDC1 & 0x0800))
            {
                Return (Package (0x01)
                {
                    Package (0x05)
                    {
                        0x05, 
                        0x00, 
                        0x00, 
                        0xFE, 
                        0x02
                    }
                })
            }

            Return (Package (0x01)
            {
                Package (0x05)
                {
                    0x05, 
                    0x00, 
                    0x00, 
                    0xFC, 
                    0x02
                }
            })
        }
    }
}



TCPA
----
[000h 0000   4]                    Signature : "TCPA"    [Trusted Computing Platform Alliance table]
[004h 0004   4]                 Table Length : 00000032
[008h 0008   1]                     Revision : 02
[009h 0009   1]                     Checksum : E2
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : "LNVO"
[020h 0032   4]        Asl Compiler Revision : 00000001

[024h 0036   2]                     Reserved : 0000
[026h 0038   4]         Max Event Log Length : 00010000
[02Ah 0042   8]            Event Log Address : 000000007E6D1C9A

Raw Table Data: Length 50 (0x32)

  0000: 54 43 50 41 32 00 00 00 02 E2 4C 45 4E 4F 56 4F  TCPA2.....LENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 4C 4E 56 4F  TP-7S   @...LNVO
  0020: 01 00 00 00 00 00 00 00 01 00 9A 1C 6D 7E 00 00  ............m~..
  0030: 00 00                                            ..


XSDT
----
[000h 0000   4]                    Signature : "XSDT"    [Extended System Description Table]
[004h 0004   4]                 Table Length : 0000009C
[008h 0008   1]                     Revision : 01
[009h 0009   1]                     Checksum : 01
[00Ah 0010   6]                       Oem ID : "LENOVO"
[010h 0016   8]                 Oem Table ID : "TP-7S   "
[018h 0024   4]                 Oem Revision : 00001240
[01Ch 0028   4]              Asl Compiler ID : " LTP"
[020h 0032   4]        Asl Compiler Revision : 00000000

[024h 0036   8]       ACPI Table Address   0 : 000000007E6BCE00
[02Ch 0044   8]       ACPI Table Address   1 : 000000007E6BCFB4
[034h 0052   8]       ACPI Table Address   2 : 000000007E6CBB4E
[03Ch 0060   8]       ACPI Table Address   3 : 000000007E6CBBA0
[044h 0068   8]       ACPI Table Address   4 : 000000007E6CBBD2
[04Ch 0076   8]       ACPI Table Address   5 : 000000007E6CBC3A
[054h 0084   8]       ACPI Table Address   6 : 000000007E6CBC76
[05Ch 0092   8]       ACPI Table Address   7 : 000000007E6CBDF0
[064h 0100   8]       ACPI Table Address   8 : 000000007E6CBF66
[06Ch 0108   8]       ACPI Table Address   9 : 000000007E6CBF8E
[074h 0116   8]       ACPI Table Address  10 : 000000007E6E2697
[07Ch 0124   8]       ACPI Table Address  11 : 000000007E6E28F6
[084h 0132   8]       ACPI Table Address  12 : 000000007E6E299C
[08Ch 0140   8]       ACPI Table Address  13 : 000000007E6E2E93
[094h 0148   8]       ACPI Table Address  14 : 000000007E6E3750

Raw Table Data: Length 156 (0x9C)

  0000: 58 53 44 54 9C 00 00 00 01 01 4C 45 4E 4F 56 4F  XSDT......LENOVO
  0010: 54 50 2D 37 53 20 20 20 40 12 00 00 20 4C 54 50  TP-7S   @... LTP
  0020: 00 00 00 00 00 CE 6B 7E 00 00 00 00 B4 CF 6B 7E  ......k~......k~
  0030: 00 00 00 00 4E BB 6C 7E 00 00 00 00 A0 BB 6C 7E  ....N.l~......l~
  0040: 00 00 00 00 D2 BB 6C 7E 00 00 00 00 3A BC 6C 7E  ......l~....:.l~
  0050: 00 00 00 00 76 BC 6C 7E 00 00 00 00 F0 BD 6C 7E  ....v.l~......l~
  0060: 00 00 00 00 66 BF 6C 7E 00 00 00 00 8E BF 6C 7E  ....f.l~......l~
  0070: 00 00 00 00 97 26 6E 7E 00 00 00 00 F6 28 6E 7E  .....&n~.....(n~
  0080: 00 00 00 00 9C 29 6E 7E 00 00 00 00 93 2E 6E 7E  .....)n~......n~
  0090: 00 00 00 00 50 37 6E 7E 00 00 00 00              ....P7n~....


